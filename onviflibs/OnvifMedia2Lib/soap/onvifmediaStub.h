/* onvifmediaStub.h
   Generated by gSOAP 2.8.22 from ./include/onvif.h

Copyright(C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef onvifmediaStub_H
#define onvifmediaStub_H
#include <vector>
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_wsc	"http://schemas.xmlsoap.org/ws/2005/02/sc"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_wsrfbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_ns1	"http://www.onvif.org/ver20/media/wsdl"
#ifndef WITH_NONAMESPACES
#define WITH_NONAMESPACES
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20822
# error "GSOAP VERSION 20822 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (19)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType { http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0 };
typedef enum wsa5__RelationshipType wsa5__RelationshipType;
#endif

#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (20)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType { wsa5__InvalidAddressingHeader = 0, wsa5__InvalidAddress = 1, wsa5__InvalidEPR = 2, wsa5__InvalidCardinality = 3, wsa5__MissingAddressInEPR = 4, wsa5__DuplicateMessageID = 5, wsa5__ActionMismatch = 6, wsa5__MessageAddressingHeaderRequired = 7, wsa5__DestinationUnreachable = 8, wsa5__ActionNotSupported = 9, wsa5__EndpointUnavailable = 10 };
typedef enum wsa5__FaultCodesType wsa5__FaultCodesType;
#endif

#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (40)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter { _wsa5__IsReferenceParameter__false = 0, _wsa5__IsReferenceParameter__true = 1 };
typedef enum _wsa5__IsReferenceParameter _wsa5__IsReferenceParameter;
#endif

#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (57)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault { wsu__MessageExpired = 0 };
typedef enum wsu__tTimestampFault wsu__tTimestampFault;
#endif

#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (59)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum { wsse__UnsupportedSecurityToken = 0, wsse__UnsupportedAlgorithm = 1, wsse__InvalidSecurity = 2, wsse__InvalidSecurityToken = 3, wsse__FailedAuthentication = 4, wsse__FailedCheck = 5, wsse__SecurityTokenUnavailable = 6 };
typedef enum wsse__FaultcodeEnum wsse__FaultcodeEnum;
#endif

#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (131)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType { wsc__BadContextToken = 0, wsc__UnsupportedContextToken = 1, wsc__UnknownDerivationSource = 2, wsc__RenewNeeded = 3, wsc__UnableToRenew = 4 };
#endif

#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (791)
/* tt:RotateMode */
enum tt__RotateMode { tt__RotateMode__OFF = 0, tt__RotateMode__ON = 1, tt__RotateMode__AUTO = 2 };
#endif

#ifndef SOAP_TYPE_tt__SceneOrientationMode
#define SOAP_TYPE_tt__SceneOrientationMode (793)
/* tt:SceneOrientationMode */
enum tt__SceneOrientationMode { tt__SceneOrientationMode__MANUAL = 0, tt__SceneOrientationMode__AUTO = 1 };
#endif

#ifndef SOAP_TYPE_tt__SceneOrientationOption
#define SOAP_TYPE_tt__SceneOrientationOption (795)
/* tt:SceneOrientationOption */
enum tt__SceneOrientationOption { tt__SceneOrientationOption__Below = 0, tt__SceneOrientationOption__Horizon = 1, tt__SceneOrientationOption__Above = 2 };
#endif

#ifndef SOAP_TYPE_tt__ViewModes
#define SOAP_TYPE_tt__ViewModes (797)
/* tt:ViewModes */
enum tt__ViewModes { tt__ViewModes__tt_x003aFisheye = 0, tt__ViewModes__tt_x003a360Panorama = 1, tt__ViewModes__tt_x003a180Panorama = 2, tt__ViewModes__tt_x003aQuad = 3, tt__ViewModes__tt_x003aOriginal = 4, tt__ViewModes__tt_x003aLeftHalf = 5, tt__ViewModes__tt_x003aRightHalf = 6, tt__ViewModes__tt_x003aDewarp = 7 };
#endif

#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (799)
/* tt:VideoEncoding */
enum tt__VideoEncoding { tt__VideoEncoding__JPEG = 0, tt__VideoEncoding__MPEG4 = 1, tt__VideoEncoding__H264 = 2 };
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (801)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile { tt__Mpeg4Profile__SP = 0, tt__Mpeg4Profile__ASP = 1 };
#endif

#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (803)
/* tt:H264Profile */
enum tt__H264Profile { tt__H264Profile__Baseline = 0, tt__H264Profile__Main = 1, tt__H264Profile__Extended = 2, tt__H264Profile__High = 3 };
#endif

#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames
#define SOAP_TYPE_tt__VideoEncodingMimeNames (805)
/* tt:VideoEncodingMimeNames */
enum tt__VideoEncodingMimeNames { tt__VideoEncodingMimeNames__JPEG = 0, tt__VideoEncodingMimeNames__MPV4_ES = 1, tt__VideoEncodingMimeNames__H264 = 2, tt__VideoEncodingMimeNames__H265 = 3 };
#endif

#ifndef SOAP_TYPE_tt__VideoEncodingProfiles
#define SOAP_TYPE_tt__VideoEncodingProfiles (807)
/* tt:VideoEncodingProfiles */
enum tt__VideoEncodingProfiles { tt__VideoEncodingProfiles__Simple = 0, tt__VideoEncodingProfiles__AdvancedSimple = 1, tt__VideoEncodingProfiles__Baseline = 2, tt__VideoEncodingProfiles__Main = 3, tt__VideoEncodingProfiles__Main10 = 4, tt__VideoEncodingProfiles__Extended = 5, tt__VideoEncodingProfiles__High = 6 };
#endif

#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (809)
/* tt:AudioEncoding */
enum tt__AudioEncoding { tt__AudioEncoding__G711 = 0, tt__AudioEncoding__G726 = 1, tt__AudioEncoding__AAC = 2 };
#endif

#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames
#define SOAP_TYPE_tt__AudioEncodingMimeNames (811)
/* tt:AudioEncodingMimeNames */
enum tt__AudioEncodingMimeNames { tt__AudioEncodingMimeNames__PCMU = 0, tt__AudioEncodingMimeNames__G726 = 1, tt__AudioEncodingMimeNames__MP4A_LATM = 2, tt__AudioEncodingMimeNames__mpeg4_generic = 3 };
#endif

#ifndef SOAP_TYPE_tt__MetadataCompressionType
#define SOAP_TYPE_tt__MetadataCompressionType (813)
/* tt:MetadataCompressionType */
enum tt__MetadataCompressionType { tt__MetadataCompressionType__None = 0, tt__MetadataCompressionType__GZIP = 1, tt__MetadataCompressionType__EXI = 2 };
#endif

#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (815)
/* tt:StreamType */
enum tt__StreamType { tt__StreamType__RTP_Unicast = 0, tt__StreamType__RTP_Multicast = 1 };
#endif

#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (817)
/* tt:TransportProtocol */
enum tt__TransportProtocol { tt__TransportProtocol__UDP = 0, tt__TransportProtocol__TCP = 1, tt__TransportProtocol__RTSP = 2, tt__TransportProtocol__HTTP = 3 };
#endif

#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (819)
/* tt:ScopeDefinition */
enum tt__ScopeDefinition { tt__ScopeDefinition__Fixed = 0, tt__ScopeDefinition__Configurable = 1 };
#endif

#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (821)
/* tt:DiscoveryMode */
enum tt__DiscoveryMode { tt__DiscoveryMode__Discoverable = 0, tt__DiscoveryMode__NonDiscoverable = 1 };
#endif

#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (825)
/* tt:Duplex */
enum tt__Duplex { tt__Duplex__Full = 0, tt__Duplex__Half = 1 };
#endif

#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (829)
/* tt:IPv6DHCPConfiguration */
enum tt__IPv6DHCPConfiguration { tt__IPv6DHCPConfiguration__Auto = 0, tt__IPv6DHCPConfiguration__Stateful = 1, tt__IPv6DHCPConfiguration__Stateless = 2, tt__IPv6DHCPConfiguration__Off = 3 };
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (831)
/* tt:NetworkProtocolType */
enum tt__NetworkProtocolType { tt__NetworkProtocolType__HTTP = 0, tt__NetworkProtocolType__HTTPS = 1, tt__NetworkProtocolType__RTSP = 2 };
#endif

#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (833)
/* tt:NetworkHostType */
enum tt__NetworkHostType { tt__NetworkHostType__IPv4 = 0, tt__NetworkHostType__IPv6 = 1, tt__NetworkHostType__DNS = 2 };
#endif

#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (841)
/* tt:IPType */
enum tt__IPType { tt__IPType__IPv4 = 0, tt__IPType__IPv6 = 1 };
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (847)
/* tt:IPAddressFilterType */
enum tt__IPAddressFilterType { tt__IPAddressFilterType__Allow = 0, tt__IPAddressFilterType__Deny = 1 };
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (849)
/* tt:DynamicDNSType */
enum tt__DynamicDNSType { tt__DynamicDNSType__NoUpdate = 0, tt__DynamicDNSType__ClientUpdates = 1, tt__DynamicDNSType__ServerUpdates = 2 };
#endif

#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (853)
/* tt:Dot11StationMode */
enum tt__Dot11StationMode { tt__Dot11StationMode__Ad_hoc = 0, tt__Dot11StationMode__Infrastructure = 1, tt__Dot11StationMode__Extended = 2 };
#endif

#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (855)
/* tt:Dot11SecurityMode */
enum tt__Dot11SecurityMode { tt__Dot11SecurityMode__None = 0, tt__Dot11SecurityMode__WEP = 1, tt__Dot11SecurityMode__PSK = 2, tt__Dot11SecurityMode__Dot1X = 3, tt__Dot11SecurityMode__Extended = 4 };
#endif

#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (857)
/* tt:Dot11Cipher */
enum tt__Dot11Cipher { tt__Dot11Cipher__CCMP = 0, tt__Dot11Cipher__TKIP = 1, tt__Dot11Cipher__Any = 2, tt__Dot11Cipher__Extended = 3 };
#endif

#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (863)
/* tt:Dot11SignalStrength */
enum tt__Dot11SignalStrength { tt__Dot11SignalStrength__None = 0, tt__Dot11SignalStrength__Very_x0020Bad = 1, tt__Dot11SignalStrength__Bad = 2, tt__Dot11SignalStrength__Good = 3, tt__Dot11SignalStrength__Very_x0020Good = 4, tt__Dot11SignalStrength__Extended = 5 };
#endif

#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (865)
/* tt:Dot11AuthAndMangementSuite */
enum tt__Dot11AuthAndMangementSuite { tt__Dot11AuthAndMangementSuite__None = 0, tt__Dot11AuthAndMangementSuite__Dot1X = 1, tt__Dot11AuthAndMangementSuite__PSK = 2, tt__Dot11AuthAndMangementSuite__Extended = 3 };
#endif

#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (867)
/* tt:CapabilityCategory */
enum tt__CapabilityCategory { tt__CapabilityCategory__All = 0, tt__CapabilityCategory__Analytics = 1, tt__CapabilityCategory__Device = 2, tt__CapabilityCategory__Events = 3, tt__CapabilityCategory__Imaging = 4, tt__CapabilityCategory__Media = 5, tt__CapabilityCategory__PTZ = 6 };
#endif

#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (869)
/* tt:SystemLogType */
enum tt__SystemLogType { tt__SystemLogType__System = 0, tt__SystemLogType__Access = 1 };
#endif

#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (871)
/* tt:FactoryDefaultType */
enum tt__FactoryDefaultType { tt__FactoryDefaultType__Hard = 0, tt__FactoryDefaultType__Soft = 1 };
#endif

#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (873)
/* tt:SetDateTimeType */
enum tt__SetDateTimeType { tt__SetDateTimeType__Manual = 0, tt__SetDateTimeType__NTP = 1 };
#endif

#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (875)
/* tt:UserLevel */
enum tt__UserLevel { tt__UserLevel__Administrator = 0, tt__UserLevel__Operator = 1, tt__UserLevel__User = 2, tt__UserLevel__Anonymous = 3, tt__UserLevel__Extended = 4 };
#endif

#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (877)
/* tt:RelayLogicalState */
enum tt__RelayLogicalState { tt__RelayLogicalState__active = 0, tt__RelayLogicalState__inactive = 1 };
#endif

#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (879)
/* tt:RelayIdleState */
enum tt__RelayIdleState { tt__RelayIdleState__closed = 0, tt__RelayIdleState__open = 1 };
#endif

#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (881)
/* tt:RelayMode */
enum tt__RelayMode { tt__RelayMode__Monostable = 0, tt__RelayMode__Bistable = 1 };
#endif

#ifndef SOAP_TYPE_tt__DigitalIdleState
#define SOAP_TYPE_tt__DigitalIdleState (883)
/* tt:DigitalIdleState */
enum tt__DigitalIdleState { tt__DigitalIdleState__closed = 0, tt__DigitalIdleState__open = 1 };
#endif

#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (885)
/* tt:EFlipMode */
enum tt__EFlipMode { tt__EFlipMode__OFF = 0, tt__EFlipMode__ON = 1, tt__EFlipMode__Extended = 2 };
#endif

#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (887)
/* tt:ReverseMode */
enum tt__ReverseMode { tt__ReverseMode__OFF = 0, tt__ReverseMode__ON = 1, tt__ReverseMode__AUTO = 2, tt__ReverseMode__Extended = 3 };
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (891)
/* tt:PTZPresetTourState */
enum tt__PTZPresetTourState { tt__PTZPresetTourState__Idle = 0, tt__PTZPresetTourState__Touring = 1, tt__PTZPresetTourState__Paused = 2, tt__PTZPresetTourState__Extended = 3 };
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (893)
/* tt:PTZPresetTourDirection */
enum tt__PTZPresetTourDirection { tt__PTZPresetTourDirection__Forward = 0, tt__PTZPresetTourDirection__Backward = 1, tt__PTZPresetTourDirection__Extended = 2 };
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (895)
/* tt:PTZPresetTourOperation */
enum tt__PTZPresetTourOperation { tt__PTZPresetTourOperation__Start = 0, tt__PTZPresetTourOperation__Stop = 1, tt__PTZPresetTourOperation__Pause = 2, tt__PTZPresetTourOperation__Extended = 3 };
#endif

#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (897)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode { tt__AutoFocusMode__AUTO = 0, tt__AutoFocusMode__MANUAL = 1 };
#endif

#ifndef SOAP_TYPE_tt__AFModes
#define SOAP_TYPE_tt__AFModes (899)
/* tt:AFModes */
enum tt__AFModes { tt__AFModes__OnceAfterMove = 0 };
#endif

#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (901)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode { tt__WideDynamicMode__OFF = 0, tt__WideDynamicMode__ON = 1 };
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (903)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode { tt__BacklightCompensationMode__OFF = 0, tt__BacklightCompensationMode__ON = 1 };
#endif

#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (905)
/* tt:ExposurePriority */
enum tt__ExposurePriority { tt__ExposurePriority__LowNoise = 0, tt__ExposurePriority__FrameRate = 1 };
#endif

#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (907)
/* tt:ExposureMode */
enum tt__ExposureMode { tt__ExposureMode__AUTO = 0, tt__ExposureMode__MANUAL = 1 };
#endif

#ifndef SOAP_TYPE_tt__Enabled
#define SOAP_TYPE_tt__Enabled (909)
/* tt:Enabled */
enum tt__Enabled { tt__Enabled__ENABLED = 0, tt__Enabled__DISABLED = 1 };
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (911)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode { tt__WhiteBalanceMode__AUTO = 0, tt__WhiteBalanceMode__MANUAL = 1 };
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (913)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode { tt__IrCutFilterMode__ON = 0, tt__IrCutFilterMode__OFF = 1, tt__IrCutFilterMode__AUTO = 2 };
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (915)
/* tt:ImageStabilizationMode */
enum tt__ImageStabilizationMode { tt__ImageStabilizationMode__OFF = 0, tt__ImageStabilizationMode__ON = 1, tt__ImageStabilizationMode__AUTO = 2, tt__ImageStabilizationMode__Extended = 3 };
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType (917)
/* tt:IrCutFilterAutoBoundaryType */
enum tt__IrCutFilterAutoBoundaryType { tt__IrCutFilterAutoBoundaryType__Common = 0, tt__IrCutFilterAutoBoundaryType__ToOn = 1, tt__IrCutFilterAutoBoundaryType__ToOff = 2, tt__IrCutFilterAutoBoundaryType__Extended = 3 };
#endif

#ifndef SOAP_TYPE_tt__ToneCompensationMode
#define SOAP_TYPE_tt__ToneCompensationMode (919)
/* tt:ToneCompensationMode */
enum tt__ToneCompensationMode { tt__ToneCompensationMode__OFF = 0, tt__ToneCompensationMode__ON = 1, tt__ToneCompensationMode__AUTO = 2 };
#endif

#ifndef SOAP_TYPE_tt__DefoggingMode
#define SOAP_TYPE_tt__DefoggingMode (921)
/* tt:DefoggingMode */
enum tt__DefoggingMode { tt__DefoggingMode__OFF = 0, tt__DefoggingMode__ON = 1, tt__DefoggingMode__AUTO = 2 };
#endif

#ifndef SOAP_TYPE_tt__ImageSendingType
#define SOAP_TYPE_tt__ImageSendingType (923)
/* tt:ImageSendingType */
enum tt__ImageSendingType { tt__ImageSendingType__Embedded = 0, tt__ImageSendingType__LocalStorage = 1, tt__ImageSendingType__RemoteStorage = 2 };
#endif

#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (925)
/* tt:PropertyOperation */
enum tt__PropertyOperation { tt__PropertyOperation__Initialized = 0, tt__PropertyOperation__Deleted = 1, tt__PropertyOperation__Changed = 2 };
#endif

#ifndef SOAP_TYPE_tt__Direction
#define SOAP_TYPE_tt__Direction (927)
/* tt:Direction */
enum tt__Direction { tt__Direction__Left = 0, tt__Direction__Right = 1, tt__Direction__Any = 2 };
#endif

#ifndef SOAP_TYPE_tt__ReceiverMode
#define SOAP_TYPE_tt__ReceiverMode (929)
/* tt:ReceiverMode */
enum tt__ReceiverMode { tt__ReceiverMode__AutoConnect = 0, tt__ReceiverMode__AlwaysConnect = 1, tt__ReceiverMode__NeverConnect = 2, tt__ReceiverMode__Unknown = 3 };
#endif

#ifndef SOAP_TYPE_tt__ReceiverState
#define SOAP_TYPE_tt__ReceiverState (931)
/* tt:ReceiverState */
enum tt__ReceiverState { tt__ReceiverState__NotConnected = 0, tt__ReceiverState__Connecting = 1, tt__ReceiverState__Connected = 2, tt__ReceiverState__Unknown = 3 };
#endif

#ifndef SOAP_TYPE_tt__SearchState
#define SOAP_TYPE_tt__SearchState (937)
/* tt:SearchState */
enum tt__SearchState { tt__SearchState__Queued = 0, tt__SearchState__Searching = 1, tt__SearchState__Completed = 2, tt__SearchState__Unknown = 3 };
#endif

#ifndef SOAP_TYPE_tt__RecordingStatus
#define SOAP_TYPE_tt__RecordingStatus (939)
/* tt:RecordingStatus */
enum tt__RecordingStatus { tt__RecordingStatus__Initiated = 0, tt__RecordingStatus__Recording = 1, tt__RecordingStatus__Stopped = 2, tt__RecordingStatus__Removing = 3, tt__RecordingStatus__Removed = 4, tt__RecordingStatus__Unknown = 5 };
#endif

#ifndef SOAP_TYPE_tt__TrackType
#define SOAP_TYPE_tt__TrackType (941)
/* tt:TrackType */
enum tt__TrackType { tt__TrackType__Video = 0, tt__TrackType__Audio = 1, tt__TrackType__Metadata = 2, tt__TrackType__Extended = 3 };
#endif

#ifndef SOAP_TYPE_tt__ModeOfOperation
#define SOAP_TYPE_tt__ModeOfOperation (947)
/* tt:ModeOfOperation */
enum tt__ModeOfOperation { tt__ModeOfOperation__Idle = 0, tt__ModeOfOperation__Active = 1, tt__ModeOfOperation__Unknown = 2 };
#endif

#ifndef SOAP_TYPE_tt__OSDType
#define SOAP_TYPE_tt__OSDType (951)
/* tt:OSDType */
enum tt__OSDType { tt__OSDType__Text = 0, tt__OSDType__Image = 1, tt__OSDType__Extended = 2 };
#endif

#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (955)
/* tt:MoveStatus */
enum tt__MoveStatus { tt__MoveStatus__IDLE = 0, tt__MoveStatus__MOVING = 1, tt__MoveStatus__UNKNOWN = 2 };
#endif

#ifndef SOAP_TYPE_tt__Entity
#define SOAP_TYPE_tt__Entity (957)
/* tt:Entity */
enum tt__Entity { tt__Entity__Device = 0, tt__Entity__VideoSource = 1, tt__Entity__AudioSource = 2 };
#endif

#ifndef SOAP_TYPE_ns1__ConfigurationEnumeration
#define SOAP_TYPE_ns1__ConfigurationEnumeration (965)
/* ns1:ConfigurationEnumeration */
enum ns1__ConfigurationEnumeration { ns1__ConfigurationEnumeration__All = 0, ns1__ConfigurationEnumeration__VideoSource = 1, ns1__ConfigurationEnumeration__VideoEncoder = 2, ns1__ConfigurationEnumeration__AudioSource = 3, ns1__ConfigurationEnumeration__AudioEncoder = 4, ns1__ConfigurationEnumeration__AudioOutput = 5, ns1__ConfigurationEnumeration__AudioDecoder = 6, ns1__ConfigurationEnumeration__Metadata = 7, ns1__ConfigurationEnumeration__Analytics = 8, ns1__ConfigurationEnumeration__PTZ = 9 };
#endif

#ifndef SOAP_TYPE_ns1__TransportProtocol
#define SOAP_TYPE_ns1__TransportProtocol (967)
/* ns1:TransportProtocol */
enum ns1__TransportProtocol { ns1__TransportProtocol__RtspUnicast = 0, ns1__TransportProtocol__RtspMulticast = 1, ns1__TransportProtocol__RTSP = 2, ns1__TransportProtocol__RtspOverHttp = 3 };
#endif

#ifndef SOAP_TYPE_ns1__MaskType
#define SOAP_TYPE_ns1__MaskType (969)
/* ns1:MaskType */
enum ns1__MaskType { ns1__MaskType__Color = 0, ns1__MaskType__Pixelated = 1, ns1__MaskType__Blurred = 2 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (158)
typedef LONG64 xsd__duration;
#endif
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (153)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (8)
/* Base64 schema type: */
struct _xop__Include
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 8; } /* = unique type id SOAP_TYPE__xop__Include */
};
typedef struct _xop__Include _xop__Include;
#endif

#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (12)
/* wsa5:EndpointReferenceType */
struct wsa5__EndpointReferenceType
{
public:
	char *Address;	/* required element of type xsd:string */
	struct wsa5__ReferenceParametersType *ReferenceParameters;	/* optional element of type wsa5:ReferenceParametersType */
	struct wsa5__MetadataType *Metadata;	/* optional element of type wsa5:MetadataType */
	int __size;	/* sequence of elements <-any> */
	char **__any;
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
public:
	int soap_type() const { return 12; } /* = unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
};
typedef struct wsa5__EndpointReferenceType wsa5__EndpointReferenceType;
#endif

#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (13)
/* wsa5:ReferenceParametersType */
struct wsa5__ReferenceParametersType
{
public:
	int *chan__ChannelInstance;	/* optional element of type xsd:int */
	int __size;	/* sequence of elements <-any> */
	char **__any;
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
public:
	int soap_type() const { return 13; } /* = unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
};
typedef struct wsa5__ReferenceParametersType wsa5__ReferenceParametersType;
#endif

#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (14)
/* wsa5:MetadataType */
struct wsa5__MetadataType
{
public:
	int __size;	/* sequence of elements <-any> */
	char **__any;
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
public:
	int soap_type() const { return 14; } /* = unique type id SOAP_TYPE_wsa5__MetadataType */
};
typedef struct wsa5__MetadataType wsa5__MetadataType;
#endif

#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (16)
/* wsa5:ProblemActionType */
struct wsa5__ProblemActionType
{
public:
	char *Action;	/* optional element of type xsd:string */
	char *SoapAction;	/* optional element of type xsd:string */
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
public:
	int soap_type() const { return 16; } /* = unique type id SOAP_TYPE_wsa5__ProblemActionType */
};
typedef struct wsa5__ProblemActionType wsa5__ProblemActionType;
#endif

#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (15)
/* Primitive wsa5:RelatesToType schema type: */
struct wsa5__RelatesToType
{
public:
	char *__item;
	char *RelationshipType;	/* optional attribute of type wsa5:RelationshipTypeOpenEnum */
	char *__anyAttribute;	/* optional attribute of type xsd:anyType */
public:
	int soap_type() const { return 15; } /* = unique type id SOAP_TYPE_wsa5__RelatesToType */
};
typedef struct wsa5__RelatesToType wsa5__RelatesToType;
#endif

#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (41)
/* Primitive chan:ChannelInstanceType schema type: */
struct chan__ChannelInstanceType
{
public:
	int __item;
	enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	/* optional attribute of type wsa5:IsReferenceParameter */
public:
	int soap_type() const { return 41; } /* = unique type id SOAP_TYPE_chan__ChannelInstanceType */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (42)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	char *wsa5__MessageID;	/* optional element of type wsa5:MessageID */
	struct wsa5__RelatesToType *wsa5__RelatesTo;	/* optional element of type wsa5:RelatesTo */
	struct wsa5__EndpointReferenceType *wsa5__From;	/* optional element of type wsa5:From */
	struct wsa5__EndpointReferenceType *wsa5__ReplyTo;	/* mustUnderstand */
	struct wsa5__EndpointReferenceType *wsa5__FaultTo;	/* mustUnderstand */
	char *wsa5__To;	/* mustUnderstand */
	char *wsa5__Action;	/* mustUnderstand */
	struct chan__ChannelInstanceType *chan__ChannelInstance;	/* optional element of type chan:ChannelInstanceType */
	struct _wsse__Security *wsse__Security;	/* mustUnderstand */
public:
	int soap_type() const { return 42; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (48)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 48; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (50)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 50; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (52)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 52; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (56)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 56; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (58)
/* wsu:Timestamp */
struct _wsu__Timestamp
{
public:
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *Created;	/* optional element of type xsd:string */
	char *Expires;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 58; } /* = unique type id SOAP_TYPE__wsu__Timestamp */
};
typedef struct _wsu__Timestamp _wsu__Timestamp;
#endif

#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (60)
/* wsse:UsernameToken */
struct _wsse__UsernameToken
{
public:
	char *Username;	/* optional element of type xsd:string */
	struct _wsse__Password *Password;	/* optional element of type wsse:Password */
	char *Nonce;	/* optional element of type xsd:string */
	char *wsu__Created;	/* optional element of type xsd:string */
	char *wsu__Id;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 60; } /* = unique type id SOAP_TYPE__wsse__UsernameToken */
};
typedef struct _wsse__UsernameToken _wsse__UsernameToken;
#endif

#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (63)
/* Primitive wsse:BinarySecurityToken schema type: */
struct _wsse__BinarySecurityToken
{
public:
	char *__item;
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *ValueType;	/* optional attribute of type xsd:string */
	char *EncodingType;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 63; } /* = unique type id SOAP_TYPE__wsse__BinarySecurityToken */
};
typedef struct _wsse__BinarySecurityToken _wsse__BinarySecurityToken;
#endif

#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (64)
/* wsse:Reference */
struct _wsse__Reference
{
public:
	char *URI;	/* optional attribute of type xsd:string */
	char *ValueType;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 64; } /* = unique type id SOAP_TYPE__wsse__Reference */
};
typedef struct _wsse__Reference _wsse__Reference;
#endif

#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (65)
/* wsse:Embedded */
struct _wsse__Embedded
{
public:
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *ValueType;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 65; } /* = unique type id SOAP_TYPE__wsse__Embedded */
};
typedef struct _wsse__Embedded _wsse__Embedded;
#endif

#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (66)
/* Primitive wsse:KeyIdentifier schema type: */
struct _wsse__KeyIdentifier
{
public:
	char *__item;
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *ValueType;	/* optional attribute of type xsd:string */
	char *EncodingType;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 66; } /* = unique type id SOAP_TYPE__wsse__KeyIdentifier */
};
typedef struct _wsse__KeyIdentifier _wsse__KeyIdentifier;
#endif

#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (67)
/* wsse:SecurityTokenReference */
struct _wsse__SecurityTokenReference
{
public:
	struct _wsse__Reference *Reference;	/* optional element of type wsse:Reference */
	struct _wsse__KeyIdentifier *KeyIdentifier;	/* optional element of type wsse:KeyIdentifier */
	struct _wsse__Embedded *Embedded;	/* optional element of type wsse:Embedded */
	struct ds__X509DataType *ds__X509Data;	/* optional element of type ds:X509DataType */
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *wsc__Instance;	/* optional attribute of type xsd:string */
	char *Usage;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 67; } /* = unique type id SOAP_TYPE__wsse__SecurityTokenReference */
};
typedef struct _wsse__SecurityTokenReference _wsse__SecurityTokenReference;
#endif

#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (73)
/* ds:SignatureType */
struct ds__SignatureType
{
public:
	struct ds__SignedInfoType *SignedInfo;	/* optional element of type ds:SignedInfoType */
	char *SignatureValue;	/* optional element of type xsd:string */
	struct ds__KeyInfoType *KeyInfo;	/* optional element of type ds:KeyInfoType */
	char *Id;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 73; } /* = unique type id SOAP_TYPE_ds__SignatureType */
};
typedef struct ds__SignatureType ds__SignatureType;
#endif

#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (83)
/* c14n:InclusiveNamespaces */
struct _c14n__InclusiveNamespaces
{
public:
	char *PrefixList;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 83; } /* = unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
};
typedef struct _c14n__InclusiveNamespaces _c14n__InclusiveNamespaces;
#endif

#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (84)
/* ds:TransformType */
struct ds__TransformType
{
public:
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of type c14n:InclusiveNamespaces */
	char *__any;
	char *Algorithm;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 84; } /* = unique type id SOAP_TYPE_ds__TransformType */
};
typedef struct ds__TransformType ds__TransformType;
#endif

#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (76)
/* ds:KeyInfoType */
struct ds__KeyInfoType
{
public:
	char *KeyName;	/* optional element of type xsd:string */
	struct ds__KeyValueType *KeyValue;	/* optional element of type ds:KeyValueType */
	struct ds__RetrievalMethodType *RetrievalMethod;	/* optional element of type ds:RetrievalMethodType */
	struct ds__X509DataType *X509Data;	/* optional element of type ds:X509DataType */
	struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;	/* optional element of type wsse:SecurityTokenReference */
	char *Id;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 76; } /* = unique type id SOAP_TYPE_ds__KeyInfoType */
};
typedef struct ds__KeyInfoType ds__KeyInfoType;
#endif

#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (74)
/* ds:SignedInfoType */
struct ds__SignedInfoType
{
public:
	struct ds__CanonicalizationMethodType *CanonicalizationMethod;	/* required element of type ds:CanonicalizationMethodType */
	struct ds__SignatureMethodType *SignatureMethod;	/* required element of type ds:SignatureMethodType */
	int __sizeReference;	/* sequence of elements <Reference> */
	struct ds__ReferenceType **Reference;	/* required element of type ds:ReferenceType */
	char *Id;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 74; } /* = unique type id SOAP_TYPE_ds__SignedInfoType */
};
typedef struct ds__SignedInfoType ds__SignedInfoType;
#endif

#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (79)
/* ds:CanonicalizationMethodType */
struct ds__CanonicalizationMethodType
{
public:
	char *Algorithm;	/* required attribute of type xsd:string */
	struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;	/* optional element of type c14n:InclusiveNamespaces */
public:
	int soap_type() const { return 79; } /* = unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
};
typedef struct ds__CanonicalizationMethodType ds__CanonicalizationMethodType;
#endif

#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (80)
/* ds:SignatureMethodType */
struct ds__SignatureMethodType
{
public:
	int *HMACOutputLength;	/* optional element of type xsd:int */
	char *Algorithm;	/* required attribute of type xsd:string */
public:
	int soap_type() const { return 80; } /* = unique type id SOAP_TYPE_ds__SignatureMethodType */
};
typedef struct ds__SignatureMethodType ds__SignatureMethodType;
#endif

#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (81)
/* ds:ReferenceType */
struct ds__ReferenceType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of type ds:TransformsType */
	struct ds__DigestMethodType *DigestMethod;	/* required element of type ds:DigestMethodType */
	char *DigestValue;	/* required element of type xsd:string */
	char *Id;	/* optional attribute of type xsd:string */
	char *URI;	/* optional attribute of type xsd:string */
	char *Type;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 81; } /* = unique type id SOAP_TYPE_ds__ReferenceType */
};
typedef struct ds__ReferenceType ds__ReferenceType;
#endif

#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (82)
/* ds:TransformsType */
struct ds__TransformsType
{
public:
	int __sizeTransform;	/* sequence of elements <Transform> */
	struct ds__TransformType *Transform;	/* required element of type ds:TransformType */
public:
	int soap_type() const { return 82; } /* = unique type id SOAP_TYPE_ds__TransformsType */
};
typedef struct ds__TransformsType ds__TransformsType;
#endif

#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (87)
/* ds:DigestMethodType */
struct ds__DigestMethodType
{
public:
	char *Algorithm;	/* required attribute of type xsd:string */
public:
	int soap_type() const { return 87; } /* = unique type id SOAP_TYPE_ds__DigestMethodType */
};
typedef struct ds__DigestMethodType ds__DigestMethodType;
#endif

#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (88)
/* ds:KeyValueType */
struct ds__KeyValueType
{
public:
	struct ds__DSAKeyValueType *DSAKeyValue;	/* optional element of type ds:DSAKeyValueType */
	struct ds__RSAKeyValueType *RSAKeyValue;	/* optional element of type ds:RSAKeyValueType */
public:
	int soap_type() const { return 88; } /* = unique type id SOAP_TYPE_ds__KeyValueType */
};
typedef struct ds__KeyValueType ds__KeyValueType;
#endif

#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (90)
/* ds:RetrievalMethodType */
struct ds__RetrievalMethodType
{
public:
	struct ds__TransformsType *Transforms;	/* optional element of type ds:TransformsType */
	char *URI;	/* optional attribute of type xsd:string */
	char *Type;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 90; } /* = unique type id SOAP_TYPE_ds__RetrievalMethodType */
};
typedef struct ds__RetrievalMethodType ds__RetrievalMethodType;
#endif

#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (71)
/* ds:X509DataType */
struct ds__X509DataType
{
public:
	struct ds__X509IssuerSerialType *X509IssuerSerial;	/* optional element of type ds:X509IssuerSerialType */
	char *X509SKI;	/* optional element of type xsd:string */
	char *X509SubjectName;	/* optional element of type xsd:string */
	char *X509Certificate;	/* optional element of type xsd:string */
	char *X509CRL;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 71; } /* = unique type id SOAP_TYPE_ds__X509DataType */
};
typedef struct ds__X509DataType ds__X509DataType;
#endif

#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (94)
/* ds:X509IssuerSerialType */
struct ds__X509IssuerSerialType
{
public:
	char *X509IssuerName;	/* required element of type xsd:string */
	char *X509SerialNumber;	/* required element of type xsd:string */
public:
	int soap_type() const { return 94; } /* = unique type id SOAP_TYPE_ds__X509IssuerSerialType */
};
typedef struct ds__X509IssuerSerialType ds__X509IssuerSerialType;
#endif

#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (95)
/* ds:DSAKeyValueType */
struct ds__DSAKeyValueType
{
public:
	char *G;	/* optional element of type xsd:string */
	char *Y;	/* required element of type xsd:string */
	char *J;	/* optional element of type xsd:string */
	char *P;	/* required element of type xsd:string */
	char *Q;	/* required element of type xsd:string */
	char *Seed;	/* required element of type xsd:string */
	char *PgenCounter;	/* required element of type xsd:string */
public:
	int soap_type() const { return 95; } /* = unique type id SOAP_TYPE_ds__DSAKeyValueType */
};
typedef struct ds__DSAKeyValueType ds__DSAKeyValueType;
#endif

#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (96)
/* ds:RSAKeyValueType */
struct ds__RSAKeyValueType
{
public:
	char *Modulus;	/* required element of type xsd:string */
	char *Exponent;	/* required element of type xsd:string */
public:
	int soap_type() const { return 96; } /* = unique type id SOAP_TYPE_ds__RSAKeyValueType */
};
typedef struct ds__RSAKeyValueType ds__RSAKeyValueType;
#endif

#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (117)
/* xenc:EncryptionPropertyType */
struct xenc__EncryptionPropertyType
{
public:
	char *Target;	/* optional attribute of type xsd:string */
	char *Id;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 117; } /* = unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
};
typedef struct xenc__EncryptionPropertyType xenc__EncryptionPropertyType;
#endif

#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (107)
/* xenc:EncryptedType */
struct xenc__EncryptedType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of type xsd:string */
	char *Type;	/* optional attribute of type xsd:string */
	char *MimeType;	/* optional attribute of type xsd:string */
	char *Encoding;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 107; } /* = unique type id SOAP_TYPE_xenc__EncryptedType */
};
typedef struct xenc__EncryptedType xenc__EncryptedType;
#endif

#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (108)
/* xenc:EncryptionMethodType */
struct xenc__EncryptionMethodType
{
public:
	int *KeySize;	/* optional element of type xsd:int */
	char *OAEPparams;	/* optional element of type xsd:string */
	char *Algorithm;	/* required attribute of type xsd:string */
	struct ds__DigestMethodType *ds__DigestMethod;	/* optional element of type ds:DigestMethodType */
	char *__mixed;
public:
	int soap_type() const { return 108; } /* = unique type id SOAP_TYPE_xenc__EncryptionMethodType */
};
typedef struct xenc__EncryptionMethodType xenc__EncryptionMethodType;
#endif

#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (109)
/* xenc:CipherDataType */
struct xenc__CipherDataType
{
public:
	char *CipherValue;	/* optional element of type xsd:string */
	struct xenc__CipherReferenceType *CipherReference;	/* optional element of type xenc:CipherReferenceType */
public:
	int soap_type() const { return 109; } /* = unique type id SOAP_TYPE_xenc__CipherDataType */
};
typedef struct xenc__CipherDataType xenc__CipherDataType;
#endif

#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (110)
/* xenc:CipherReferenceType */
struct xenc__CipherReferenceType
{
public:
	struct xenc__TransformsType *Transforms;	/* optional element of type xenc:TransformsType */
	char *URI;	/* required attribute of type xsd:string */
public:
	int soap_type() const { return 110; } /* = unique type id SOAP_TYPE_xenc__CipherReferenceType */
};
typedef struct xenc__CipherReferenceType xenc__CipherReferenceType;
#endif

#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (111)
/* xenc:TransformsType */
struct xenc__TransformsType
{
public:
	struct ds__TransformType ds__Transform;	/* required element of type ds:Transform */
public:
	int soap_type() const { return 111; } /* = unique type id SOAP_TYPE_xenc__TransformsType */
};
typedef struct xenc__TransformsType xenc__TransformsType;
#endif

#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (114)
/* xenc:AgreementMethodType */
struct xenc__AgreementMethodType
{
public:
	char *KA_Nonce;	/* optional element of type xsd:string */
	struct ds__KeyInfoType *OriginatorKeyInfo;	/* optional element of type ds:KeyInfoType */
	struct ds__KeyInfoType *RecipientKeyInfo;	/* optional element of type ds:KeyInfoType */
	char *Algorithm;	/* required attribute of type xsd:string */
	char *__mixed;
public:
	int soap_type() const { return 114; } /* = unique type id SOAP_TYPE_xenc__AgreementMethodType */
};
typedef struct xenc__AgreementMethodType xenc__AgreementMethodType;
#endif

#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (115)
/* xenc:ReferenceType */
struct xenc__ReferenceType
{
public:
	char *URI;	/* required attribute of type xsd:string */
public:
	int soap_type() const { return 115; } /* = unique type id SOAP_TYPE_xenc__ReferenceType */
};
typedef struct xenc__ReferenceType xenc__ReferenceType;
#endif

#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (116)
/* xenc:EncryptionPropertiesType */
struct xenc__EncryptionPropertiesType
{
public:
	int __sizeEncryptionProperty;	/* sequence of elements <EncryptionProperty> */
	struct xenc__EncryptionPropertyType *EncryptionProperty;	/* required element of type xenc:EncryptionPropertyType */
	char *Id;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 116; } /* = unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
};
typedef struct xenc__EncryptionPropertiesType xenc__EncryptionPropertiesType;
#endif

#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (126)
/* Operation wrapper: */
struct __xenc__union_ReferenceList
{
public:
	struct xenc__ReferenceType *DataReference;	/* optional element of type xenc:ReferenceType */
	struct xenc__ReferenceType *KeyReference;	/* optional element of type xenc:ReferenceType */
public:
	int soap_type() const { return 126; } /* = unique type id SOAP_TYPE___xenc__union_ReferenceList */
};
#endif

#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (118)
/* xenc:ReferenceList */
struct _xenc__ReferenceList
{
public:
	int __size_ReferenceList;	/* sequence of elements <-union-ReferenceList> */
	struct __xenc__union_ReferenceList *__union_ReferenceList;
public:
	int soap_type() const { return 118; } /* = unique type id SOAP_TYPE__xenc__ReferenceList */
};
typedef struct _xenc__ReferenceList _xenc__ReferenceList;
#endif

#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (112)
/* xenc:EncryptedDataType */
struct xenc__EncryptedDataType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of type xsd:string */
	char *Type;	/* optional attribute of type xsd:string */
	char *MimeType;	/* optional attribute of type xsd:string */
	char *Encoding;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 112; } /* = unique type id SOAP_TYPE_xenc__EncryptedDataType */
};
typedef struct xenc__EncryptedDataType xenc__EncryptedDataType;
#endif

#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (113)
/* xenc:EncryptedKeyType */
struct xenc__EncryptedKeyType
{
public:
	struct xenc__EncryptionMethodType *EncryptionMethod;	/* optional element of type xenc:EncryptionMethodType */
	struct ds__KeyInfoType *ds__KeyInfo;	/* optional element of type ds:KeyInfo */
	struct xenc__CipherDataType *CipherData;	/* required element of type xenc:CipherDataType */
	struct xenc__EncryptionPropertiesType *EncryptionProperties;	/* optional element of type xenc:EncryptionPropertiesType */
	char *Id;	/* optional attribute of type xsd:string */
	char *Type;	/* optional attribute of type xsd:string */
	char *MimeType;	/* optional attribute of type xsd:string */
	char *Encoding;	/* optional attribute of type xsd:string */
	struct _xenc__ReferenceList *ReferenceList;	/* optional element of type xenc:ReferenceList */
	char *CarriedKeyName;	/* optional element of type xsd:string */
	char *Recipient;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 113; } /* = unique type id SOAP_TYPE_xenc__EncryptedKeyType */
};
typedef struct xenc__EncryptedKeyType xenc__EncryptedKeyType;
#endif

#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (132)
/* wsc:SecurityContextTokenType */
struct wsc__SecurityContextTokenType
{
public:
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *Identifier;	/* optional element of type xsd:string */
	char *Instance;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 132; } /* = unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
};
#endif

#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (137)
/* xsd:choice */
union _wsc__union_DerivedKeyTokenType
{
#define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)
	ULONG64 Generation;
#define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)
	ULONG64 Offset;
};
#endif

#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (136)
/* Operation wrapper: */
struct __wsc__DerivedKeyTokenType_sequence
{
public:
	int __union_DerivedKeyTokenType;	/* union discriminant (of union defined below) */
	union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;	/* required element of type xsd:choice */
	ULONG64 *Length;	/* optional element of type xsd:unsignedLong */
public:
	int soap_type() const { return 136; } /* = unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
};
#endif

#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (133)
/* wsc:DerivedKeyTokenType */
struct wsc__DerivedKeyTokenType
{
public:
	struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;	/* optional element of type wsse:SecurityTokenReference */
	struct wsc__PropertiesType *Properties;	/* optional element of type wsc:PropertiesType */
	int __size_DerivedKeyTokenType_sequence;	/* sequence of elements <-DerivedKeyTokenType-sequence> */
	struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
	char *Label;	/* optional element of type xsd:string */
	char *Nonce;	/* optional element of type xsd:string */
	char *wsu__Id;	/* optional attribute of type xsd:string */
	char *Algorithm;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 133; } /* = unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
};
#endif

#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (134)
/* wsc:PropertiesType */
struct wsc__PropertiesType
{
public:
	int soap_type() const { return 134; } /* = unique type id SOAP_TYPE_wsc__PropertiesType */
};
#endif

#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (140)
/* wsse:Security */
struct _wsse__Security
{
public:
	struct _wsu__Timestamp *wsu__Timestamp;	/* optional element of type wsu:Timestamp */
	struct _wsse__UsernameToken *UsernameToken;	/* optional element of type wsse:UsernameToken */
	struct _wsse__BinarySecurityToken *BinarySecurityToken;	/* optional element of type wsse:BinarySecurityToken */
	struct xenc__EncryptedKeyType *xenc__EncryptedKey;	/* optional element of type xenc:EncryptedKeyType */
	struct _xenc__ReferenceList *xenc__ReferenceList;	/* optional element of type xenc:ReferenceList */
	struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;	/* optional element of type wsc:SecurityContextTokenType */
	struct ds__SignatureType *ds__Signature;	/* optional element of type ds:SignatureType */
	char *SOAP_ENV__actor;	/* optional attribute of type xsd:string */
	char *SOAP_ENV__role;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 140; } /* = unique type id SOAP_TYPE__wsse__Security */
};
typedef struct _wsse__Security _wsse__Security;
#endif

#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (61)
/* Primitive wsse:Password schema type: */
struct _wsse__Password
{
public:
	char *__item;
	char *Type;	/* optional attribute of type xsd:string */
public:
	int soap_type() const { return 61; } /* = unique type id SOAP_TYPE__wsse__Password */
};
typedef struct _wsse__Password _wsse__Password;
#endif

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (148)
/* Primitive xsd:anyType schema type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 148; } /* = unique type id SOAP_TYPE_xsd__anyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyType() { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (150)
/* SOAP-ENV:Envelope */
struct SOAP_ENV__Envelope
{
public:
	struct SOAP_ENV__Header *SOAP_ENV__Header;	/* optional element of type SOAP-ENV:Header */
	char *SOAP_ENV__Body;	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 150; } /* = unique type id SOAP_TYPE_SOAP_ENV__Envelope */
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (154)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 154; } /* = unique type id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (159)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 159; } /* = unique type id SOAP_TYPE_xsd__hexBinary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__hexBinary() { xsd__hexBinary::soap_default(NULL); }
	virtual ~xsd__hexBinary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__NCName_
#define SOAP_TYPE_xsd__NCName_ (161)
/* Primitive xsd:NCName schema type: */
class SOAP_CMAC xsd__NCName_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 161; } /* = unique type id SOAP_TYPE_xsd__NCName_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__NCName_() { xsd__NCName_::soap_default(NULL); }
	virtual ~xsd__NCName_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (162)
/* Primitive xsd:QName schema type: */
class SOAP_CMAC xsd__QName_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 162; } /* = unique type id SOAP_TYPE_xsd__QName_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__QName_() { xsd__QName_::soap_default(NULL); }
	virtual ~xsd__QName_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__anySimpleType_
#define SOAP_TYPE_xsd__anySimpleType_ (164)
/* Primitive xsd:anySimpleType schema type: */
class SOAP_CMAC xsd__anySimpleType_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 164; } /* = unique type id SOAP_TYPE_xsd__anySimpleType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anySimpleType_() { xsd__anySimpleType_::soap_default(NULL); }
	virtual ~xsd__anySimpleType_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (166)
/* Primitive xsd:anyURI schema type: */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 166; } /* = unique type id SOAP_TYPE_xsd__anyURI_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyURI_() { xsd__anyURI_::soap_default(NULL); }
	virtual ~xsd__anyURI_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (167)
/* Primitive xsd:base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType
{
public:
	xsd__base64Binary __item;
public:
	virtual int soap_type() const { return 167; } /* = unique type id SOAP_TYPE_xsd__base64Binary_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary_() { xsd__base64Binary_::soap_default(NULL); }
	virtual ~xsd__base64Binary_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (168)
/* Primitive xsd:boolean schema type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;
public:
	virtual int soap_type() const { return 168; } /* = unique type id SOAP_TYPE_xsd__boolean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__boolean() { xsd__boolean::soap_default(NULL); }
	virtual ~xsd__boolean() { }
};
#endif

#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (170)
/* Primitive xsd:dateTime schema type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
	time_t __item;
public:
	virtual int soap_type() const { return 170; } /* = unique type id SOAP_TYPE_xsd__dateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
	virtual ~xsd__dateTime() { }
};
#endif

#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (172)
/* Primitive xsd:double schema type: */
class SOAP_CMAC xsd__double : public xsd__anyType
{
public:
	double __item;
public:
	virtual int soap_type() const { return 172; } /* = unique type id SOAP_TYPE_xsd__double */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__double() { xsd__double::soap_default(NULL); }
	virtual ~xsd__double() { }
};
#endif

#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (174)
/* Primitive xsd:duration schema type: */
class SOAP_CMAC xsd__duration_ : public xsd__anyType
{
public:
	LONG64 __item;	/* external */
public:
	virtual int soap_type() const { return 174; } /* = unique type id SOAP_TYPE_xsd__duration_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__duration_() { xsd__duration_::soap_default(NULL); }
	virtual ~xsd__duration_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (175)
/* Primitive xsd:float schema type: */
class SOAP_CMAC xsd__float : public xsd__anyType
{
public:
	float __item;
public:
	virtual int soap_type() const { return 175; } /* = unique type id SOAP_TYPE_xsd__float */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__float() { xsd__float::soap_default(NULL); }
	virtual ~xsd__float() { }
};
#endif

#ifndef SOAP_TYPE_xsd__hexBinary_
#define SOAP_TYPE_xsd__hexBinary_ (177)
/* Primitive xsd:hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary_ : public xsd__anyType
{
public:
	xsd__hexBinary __item;
public:
	virtual int soap_type() const { return 177; } /* = unique type id SOAP_TYPE_xsd__hexBinary_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__hexBinary_() { xsd__hexBinary_::soap_default(NULL); }
	virtual ~xsd__hexBinary_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (178)
/* Primitive xsd:int schema type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 178; } /* = unique type id SOAP_TYPE_xsd__int */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__int() { xsd__int::soap_default(NULL); }
	virtual ~xsd__int() { }
};
#endif

#ifndef SOAP_TYPE_xsd__integer_
#define SOAP_TYPE_xsd__integer_ (180)
/* Primitive xsd:integer schema type: */
class SOAP_CMAC xsd__integer_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 180; } /* = unique type id SOAP_TYPE_xsd__integer_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__integer_() { xsd__integer_::soap_default(NULL); }
	virtual ~xsd__integer_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger_
#define SOAP_TYPE_xsd__nonNegativeInteger_ (182)
/* Primitive xsd:nonNegativeInteger schema type: */
class SOAP_CMAC xsd__nonNegativeInteger_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 182; } /* = unique type id SOAP_TYPE_xsd__nonNegativeInteger_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__nonNegativeInteger_() { xsd__nonNegativeInteger_::soap_default(NULL); }
	virtual ~xsd__nonNegativeInteger_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (183)
/* Primitive xsd:string schema type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 183; } /* = unique type id SOAP_TYPE_xsd__string */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__string() { xsd__string::soap_default(NULL); }
	virtual ~xsd__string() { }
};
#endif

#ifndef SOAP_TYPE_xsd__token_
#define SOAP_TYPE_xsd__token_ (185)
/* Primitive xsd:token schema type: */
class SOAP_CMAC xsd__token_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 185; } /* = unique type id SOAP_TYPE_xsd__token_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__token_() { xsd__token_::soap_default(NULL); }
	virtual ~xsd__token_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Name__
#define SOAP_TYPE_tt__Name__ (790)
/* Primitive tt:Name schema type: */
class SOAP_CMAC tt__Name__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 790; } /* = unique type id SOAP_TYPE_tt__Name__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Name__() { tt__Name__::soap_default(NULL); }
	virtual ~tt__Name__() { }
};
#endif

#ifndef SOAP_TYPE_tt__RotateMode_
#define SOAP_TYPE_tt__RotateMode_ (792)
/* Primitive tt:RotateMode schema type: */
class SOAP_CMAC tt__RotateMode_ : public xsd__anyType
{
public:
	enum tt__RotateMode __item;
public:
	virtual int soap_type() const { return 792; } /* = unique type id SOAP_TYPE_tt__RotateMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RotateMode_() { tt__RotateMode_::soap_default(NULL); }
	virtual ~tt__RotateMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__SceneOrientationMode_
#define SOAP_TYPE_tt__SceneOrientationMode_ (794)
/* Primitive tt:SceneOrientationMode schema type: */
class SOAP_CMAC tt__SceneOrientationMode_ : public xsd__anyType
{
public:
	enum tt__SceneOrientationMode __item;
public:
	virtual int soap_type() const { return 794; } /* = unique type id SOAP_TYPE_tt__SceneOrientationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SceneOrientationMode_() { tt__SceneOrientationMode_::soap_default(NULL); }
	virtual ~tt__SceneOrientationMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__SceneOrientationOption_
#define SOAP_TYPE_tt__SceneOrientationOption_ (796)
/* Primitive tt:SceneOrientationOption schema type: */
class SOAP_CMAC tt__SceneOrientationOption_ : public xsd__anyType
{
public:
	enum tt__SceneOrientationOption __item;
public:
	virtual int soap_type() const { return 796; } /* = unique type id SOAP_TYPE_tt__SceneOrientationOption_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SceneOrientationOption_() { tt__SceneOrientationOption_::soap_default(NULL); }
	virtual ~tt__SceneOrientationOption_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ViewModes_
#define SOAP_TYPE_tt__ViewModes_ (798)
/* Primitive tt:ViewModes schema type: */
class SOAP_CMAC tt__ViewModes_ : public xsd__anyType
{
public:
	enum tt__ViewModes __item;
public:
	virtual int soap_type() const { return 798; } /* = unique type id SOAP_TYPE_tt__ViewModes_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ViewModes_() { tt__ViewModes_::soap_default(NULL); }
	virtual ~tt__ViewModes_() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoding_
#define SOAP_TYPE_tt__VideoEncoding_ (800)
/* Primitive tt:VideoEncoding schema type: */
class SOAP_CMAC tt__VideoEncoding_ : public xsd__anyType
{
public:
	enum tt__VideoEncoding __item;
public:
	virtual int soap_type() const { return 800; } /* = unique type id SOAP_TYPE_tt__VideoEncoding_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoding_() { tt__VideoEncoding_::soap_default(NULL); }
	virtual ~tt__VideoEncoding_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Profile_
#define SOAP_TYPE_tt__Mpeg4Profile_ (802)
/* Primitive tt:Mpeg4Profile schema type: */
class SOAP_CMAC tt__Mpeg4Profile_ : public xsd__anyType
{
public:
	enum tt__Mpeg4Profile __item;
public:
	virtual int soap_type() const { return 802; } /* = unique type id SOAP_TYPE_tt__Mpeg4Profile_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Profile_() { tt__Mpeg4Profile_::soap_default(NULL); }
	virtual ~tt__Mpeg4Profile_() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Profile_
#define SOAP_TYPE_tt__H264Profile_ (804)
/* Primitive tt:H264Profile schema type: */
class SOAP_CMAC tt__H264Profile_ : public xsd__anyType
{
public:
	enum tt__H264Profile __item;
public:
	virtual int soap_type() const { return 804; } /* = unique type id SOAP_TYPE_tt__H264Profile_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Profile_() { tt__H264Profile_::soap_default(NULL); }
	virtual ~tt__H264Profile_() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames_
#define SOAP_TYPE_tt__VideoEncodingMimeNames_ (806)
/* Primitive tt:VideoEncodingMimeNames schema type: */
class SOAP_CMAC tt__VideoEncodingMimeNames_ : public xsd__anyType
{
public:
	enum tt__VideoEncodingMimeNames __item;
public:
	virtual int soap_type() const { return 806; } /* = unique type id SOAP_TYPE_tt__VideoEncodingMimeNames_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncodingMimeNames_() { tt__VideoEncodingMimeNames_::soap_default(NULL); }
	virtual ~tt__VideoEncodingMimeNames_() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncodingProfiles_
#define SOAP_TYPE_tt__VideoEncodingProfiles_ (808)
/* Primitive tt:VideoEncodingProfiles schema type: */
class SOAP_CMAC tt__VideoEncodingProfiles_ : public xsd__anyType
{
public:
	enum tt__VideoEncodingProfiles __item;
public:
	virtual int soap_type() const { return 808; } /* = unique type id SOAP_TYPE_tt__VideoEncodingProfiles_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncodingProfiles_() { tt__VideoEncodingProfiles_::soap_default(NULL); }
	virtual ~tt__VideoEncodingProfiles_() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoding_
#define SOAP_TYPE_tt__AudioEncoding_ (810)
/* Primitive tt:AudioEncoding schema type: */
class SOAP_CMAC tt__AudioEncoding_ : public xsd__anyType
{
public:
	enum tt__AudioEncoding __item;
public:
	virtual int soap_type() const { return 810; } /* = unique type id SOAP_TYPE_tt__AudioEncoding_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoding_() { tt__AudioEncoding_::soap_default(NULL); }
	virtual ~tt__AudioEncoding_() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames_
#define SOAP_TYPE_tt__AudioEncodingMimeNames_ (812)
/* Primitive tt:AudioEncodingMimeNames schema type: */
class SOAP_CMAC tt__AudioEncodingMimeNames_ : public xsd__anyType
{
public:
	enum tt__AudioEncodingMimeNames __item;
public:
	virtual int soap_type() const { return 812; } /* = unique type id SOAP_TYPE_tt__AudioEncodingMimeNames_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncodingMimeNames_() { tt__AudioEncodingMimeNames_::soap_default(NULL); }
	virtual ~tt__AudioEncodingMimeNames_() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataCompressionType_
#define SOAP_TYPE_tt__MetadataCompressionType_ (814)
/* Primitive tt:MetadataCompressionType schema type: */
class SOAP_CMAC tt__MetadataCompressionType_ : public xsd__anyType
{
public:
	enum tt__MetadataCompressionType __item;
public:
	virtual int soap_type() const { return 814; } /* = unique type id SOAP_TYPE_tt__MetadataCompressionType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataCompressionType_() { tt__MetadataCompressionType_::soap_default(NULL); }
	virtual ~tt__MetadataCompressionType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__StreamType_
#define SOAP_TYPE_tt__StreamType_ (816)
/* Primitive tt:StreamType schema type: */
class SOAP_CMAC tt__StreamType_ : public xsd__anyType
{
public:
	enum tt__StreamType __item;
public:
	virtual int soap_type() const { return 816; } /* = unique type id SOAP_TYPE_tt__StreamType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__StreamType_() { tt__StreamType_::soap_default(NULL); }
	virtual ~tt__StreamType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__TransportProtocol_
#define SOAP_TYPE_tt__TransportProtocol_ (818)
/* Primitive tt:TransportProtocol schema type: */
class SOAP_CMAC tt__TransportProtocol_ : public xsd__anyType
{
public:
	enum tt__TransportProtocol __item;
public:
	virtual int soap_type() const { return 818; } /* = unique type id SOAP_TYPE_tt__TransportProtocol_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TransportProtocol_() { tt__TransportProtocol_::soap_default(NULL); }
	virtual ~tt__TransportProtocol_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ScopeDefinition_
#define SOAP_TYPE_tt__ScopeDefinition_ (820)
/* Primitive tt:ScopeDefinition schema type: */
class SOAP_CMAC tt__ScopeDefinition_ : public xsd__anyType
{
public:
	enum tt__ScopeDefinition __item;
public:
	virtual int soap_type() const { return 820; } /* = unique type id SOAP_TYPE_tt__ScopeDefinition_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ScopeDefinition_() { tt__ScopeDefinition_::soap_default(NULL); }
	virtual ~tt__ScopeDefinition_() { }
};
#endif

#ifndef SOAP_TYPE_tt__DiscoveryMode_
#define SOAP_TYPE_tt__DiscoveryMode_ (822)
/* Primitive tt:DiscoveryMode schema type: */
class SOAP_CMAC tt__DiscoveryMode_ : public xsd__anyType
{
public:
	enum tt__DiscoveryMode __item;
public:
	virtual int soap_type() const { return 822; } /* = unique type id SOAP_TYPE_tt__DiscoveryMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DiscoveryMode_() { tt__DiscoveryMode_::soap_default(NULL); }
	virtual ~tt__DiscoveryMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority__
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority__ (824)
/* Primitive tt:NetworkInterfaceConfigPriority schema type: */
class SOAP_CMAC tt__NetworkInterfaceConfigPriority__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 824; } /* = unique type id SOAP_TYPE_tt__NetworkInterfaceConfigPriority__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceConfigPriority__() { tt__NetworkInterfaceConfigPriority__::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConfigPriority__() { }
};
#endif

#ifndef SOAP_TYPE_tt__Duplex_
#define SOAP_TYPE_tt__Duplex_ (826)
/* Primitive tt:Duplex schema type: */
class SOAP_CMAC tt__Duplex_ : public xsd__anyType
{
public:
	enum tt__Duplex __item;
public:
	virtual int soap_type() const { return 826; } /* = unique type id SOAP_TYPE_tt__Duplex_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Duplex_() { tt__Duplex_::soap_default(NULL); }
	virtual ~tt__Duplex_() { }
};
#endif

#ifndef SOAP_TYPE_tt__IANA_IfTypes__
#define SOAP_TYPE_tt__IANA_IfTypes__ (828)
/* Primitive tt:IANA-IfTypes schema type: */
class SOAP_CMAC tt__IANA_IfTypes__ : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 828; } /* = unique type id SOAP_TYPE_tt__IANA_IfTypes__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IANA_IfTypes__() { tt__IANA_IfTypes__::soap_default(NULL); }
	virtual ~tt__IANA_IfTypes__() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration_
#define SOAP_TYPE_tt__IPv6DHCPConfiguration_ (830)
/* Primitive tt:IPv6DHCPConfiguration schema type: */
class SOAP_CMAC tt__IPv6DHCPConfiguration_ : public xsd__anyType
{
public:
	enum tt__IPv6DHCPConfiguration __item;
public:
	virtual int soap_type() const { return 830; } /* = unique type id SOAP_TYPE_tt__IPv6DHCPConfiguration_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6DHCPConfiguration_() { tt__IPv6DHCPConfiguration_::soap_default(NULL); }
	virtual ~tt__IPv6DHCPConfiguration_() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocolType_
#define SOAP_TYPE_tt__NetworkProtocolType_ (832)
/* Primitive tt:NetworkProtocolType schema type: */
class SOAP_CMAC tt__NetworkProtocolType_ : public xsd__anyType
{
public:
	enum tt__NetworkProtocolType __item;
public:
	virtual int soap_type() const { return 832; } /* = unique type id SOAP_TYPE_tt__NetworkProtocolType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkProtocolType_() { tt__NetworkProtocolType_::soap_default(NULL); }
	virtual ~tt__NetworkProtocolType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkHostType_
#define SOAP_TYPE_tt__NetworkHostType_ (834)
/* Primitive tt:NetworkHostType schema type: */
class SOAP_CMAC tt__NetworkHostType_ : public xsd__anyType
{
public:
	enum tt__NetworkHostType __item;
public:
	virtual int soap_type() const { return 834; } /* = unique type id SOAP_TYPE_tt__NetworkHostType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkHostType_() { tt__NetworkHostType_::soap_default(NULL); }
	virtual ~tt__NetworkHostType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4Address__
#define SOAP_TYPE_tt__IPv4Address__ (836)
/* Primitive tt:IPv4Address schema type: */
class SOAP_CMAC tt__IPv4Address__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 836; } /* = unique type id SOAP_TYPE_tt__IPv4Address__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4Address__() { tt__IPv4Address__::soap_default(NULL); }
	virtual ~tt__IPv4Address__() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6Address__
#define SOAP_TYPE_tt__IPv6Address__ (838)
/* Primitive tt:IPv6Address schema type: */
class SOAP_CMAC tt__IPv6Address__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 838; } /* = unique type id SOAP_TYPE_tt__IPv6Address__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6Address__() { tt__IPv6Address__::soap_default(NULL); }
	virtual ~tt__IPv6Address__() { }
};
#endif

#ifndef SOAP_TYPE_tt__HwAddress__
#define SOAP_TYPE_tt__HwAddress__ (840)
/* Primitive tt:HwAddress schema type: */
class SOAP_CMAC tt__HwAddress__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 840; } /* = unique type id SOAP_TYPE_tt__HwAddress__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__HwAddress__() { tt__HwAddress__::soap_default(NULL); }
	virtual ~tt__HwAddress__() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPType_
#define SOAP_TYPE_tt__IPType_ (842)
/* Primitive tt:IPType schema type: */
class SOAP_CMAC tt__IPType_ : public xsd__anyType
{
public:
	enum tt__IPType __item;
public:
	virtual int soap_type() const { return 842; } /* = unique type id SOAP_TYPE_tt__IPType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPType_() { tt__IPType_::soap_default(NULL); }
	virtual ~tt__IPType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__DNSName__
#define SOAP_TYPE_tt__DNSName__ (844)
/* Primitive tt:DNSName schema type: */
class SOAP_CMAC tt__DNSName__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 844; } /* = unique type id SOAP_TYPE_tt__DNSName__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DNSName__() { tt__DNSName__::soap_default(NULL); }
	virtual ~tt__DNSName__() { }
};
#endif

#ifndef SOAP_TYPE_tt__Domain__
#define SOAP_TYPE_tt__Domain__ (846)
/* Primitive tt:Domain schema type: */
class SOAP_CMAC tt__Domain__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 846; } /* = unique type id SOAP_TYPE_tt__Domain__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Domain__() { tt__Domain__::soap_default(NULL); }
	virtual ~tt__Domain__() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilterType_
#define SOAP_TYPE_tt__IPAddressFilterType_ (848)
/* Primitive tt:IPAddressFilterType schema type: */
class SOAP_CMAC tt__IPAddressFilterType_ : public xsd__anyType
{
public:
	enum tt__IPAddressFilterType __item;
public:
	virtual int soap_type() const { return 848; } /* = unique type id SOAP_TYPE_tt__IPAddressFilterType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddressFilterType_() { tt__IPAddressFilterType_::soap_default(NULL); }
	virtual ~tt__IPAddressFilterType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSType_
#define SOAP_TYPE_tt__DynamicDNSType_ (850)
/* Primitive tt:DynamicDNSType schema type: */
class SOAP_CMAC tt__DynamicDNSType_ : public xsd__anyType
{
public:
	enum tt__DynamicDNSType __item;
public:
	virtual int soap_type() const { return 850; } /* = unique type id SOAP_TYPE_tt__DynamicDNSType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DynamicDNSType_() { tt__DynamicDNSType_::soap_default(NULL); }
	virtual ~tt__DynamicDNSType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11SSIDType__
#define SOAP_TYPE_tt__Dot11SSIDType__ (852)
/* Primitive tt:Dot11SSIDType schema type: */
class SOAP_CMAC tt__Dot11SSIDType__ : public xsd__anyType
{
public:
	xsd__hexBinary __item;
public:
	virtual int soap_type() const { return 852; } /* = unique type id SOAP_TYPE_tt__Dot11SSIDType__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11SSIDType__() { tt__Dot11SSIDType__::soap_default(NULL); }
	virtual ~tt__Dot11SSIDType__() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11StationMode_
#define SOAP_TYPE_tt__Dot11StationMode_ (854)
/* Primitive tt:Dot11StationMode schema type: */
class SOAP_CMAC tt__Dot11StationMode_ : public xsd__anyType
{
public:
	enum tt__Dot11StationMode __item;
public:
	virtual int soap_type() const { return 854; } /* = unique type id SOAP_TYPE_tt__Dot11StationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11StationMode_() { tt__Dot11StationMode_::soap_default(NULL); }
	virtual ~tt__Dot11StationMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11SecurityMode_
#define SOAP_TYPE_tt__Dot11SecurityMode_ (856)
/* Primitive tt:Dot11SecurityMode schema type: */
class SOAP_CMAC tt__Dot11SecurityMode_ : public xsd__anyType
{
public:
	enum tt__Dot11SecurityMode __item;
public:
	virtual int soap_type() const { return 856; } /* = unique type id SOAP_TYPE_tt__Dot11SecurityMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11SecurityMode_() { tt__Dot11SecurityMode_::soap_default(NULL); }
	virtual ~tt__Dot11SecurityMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11Cipher_
#define SOAP_TYPE_tt__Dot11Cipher_ (858)
/* Primitive tt:Dot11Cipher schema type: */
class SOAP_CMAC tt__Dot11Cipher_ : public xsd__anyType
{
public:
	enum tt__Dot11Cipher __item;
public:
	virtual int soap_type() const { return 858; } /* = unique type id SOAP_TYPE_tt__Dot11Cipher_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11Cipher_() { tt__Dot11Cipher_::soap_default(NULL); }
	virtual ~tt__Dot11Cipher_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11PSK__
#define SOAP_TYPE_tt__Dot11PSK__ (860)
/* Primitive tt:Dot11PSK schema type: */
class SOAP_CMAC tt__Dot11PSK__ : public xsd__anyType
{
public:
	xsd__hexBinary __item;
public:
	virtual int soap_type() const { return 860; } /* = unique type id SOAP_TYPE_tt__Dot11PSK__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11PSK__() { tt__Dot11PSK__::soap_default(NULL); }
	virtual ~tt__Dot11PSK__() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase__
#define SOAP_TYPE_tt__Dot11PSKPassphrase__ (862)
/* Primitive tt:Dot11PSKPassphrase schema type: */
class SOAP_CMAC tt__Dot11PSKPassphrase__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 862; } /* = unique type id SOAP_TYPE_tt__Dot11PSKPassphrase__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11PSKPassphrase__() { tt__Dot11PSKPassphrase__::soap_default(NULL); }
	virtual ~tt__Dot11PSKPassphrase__() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11SignalStrength_
#define SOAP_TYPE_tt__Dot11SignalStrength_ (864)
/* Primitive tt:Dot11SignalStrength schema type: */
class SOAP_CMAC tt__Dot11SignalStrength_ : public xsd__anyType
{
public:
	enum tt__Dot11SignalStrength __item;
public:
	virtual int soap_type() const { return 864; } /* = unique type id SOAP_TYPE_tt__Dot11SignalStrength_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11SignalStrength_() { tt__Dot11SignalStrength_::soap_default(NULL); }
	virtual ~tt__Dot11SignalStrength_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite_
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite_ (866)
/* Primitive tt:Dot11AuthAndMangementSuite schema type: */
class SOAP_CMAC tt__Dot11AuthAndMangementSuite_ : public xsd__anyType
{
public:
	enum tt__Dot11AuthAndMangementSuite __item;
public:
	virtual int soap_type() const { return 866; } /* = unique type id SOAP_TYPE_tt__Dot11AuthAndMangementSuite_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11AuthAndMangementSuite_() { tt__Dot11AuthAndMangementSuite_::soap_default(NULL); }
	virtual ~tt__Dot11AuthAndMangementSuite_() { }
};
#endif

#ifndef SOAP_TYPE_tt__CapabilityCategory_
#define SOAP_TYPE_tt__CapabilityCategory_ (868)
/* Primitive tt:CapabilityCategory schema type: */
class SOAP_CMAC tt__CapabilityCategory_ : public xsd__anyType
{
public:
	enum tt__CapabilityCategory __item;
public:
	virtual int soap_type() const { return 868; } /* = unique type id SOAP_TYPE_tt__CapabilityCategory_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CapabilityCategory_() { tt__CapabilityCategory_::soap_default(NULL); }
	virtual ~tt__CapabilityCategory_() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemLogType_
#define SOAP_TYPE_tt__SystemLogType_ (870)
/* Primitive tt:SystemLogType schema type: */
class SOAP_CMAC tt__SystemLogType_ : public xsd__anyType
{
public:
	enum tt__SystemLogType __item;
public:
	virtual int soap_type() const { return 870; } /* = unique type id SOAP_TYPE_tt__SystemLogType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemLogType_() { tt__SystemLogType_::soap_default(NULL); }
	virtual ~tt__SystemLogType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__FactoryDefaultType_
#define SOAP_TYPE_tt__FactoryDefaultType_ (872)
/* Primitive tt:FactoryDefaultType schema type: */
class SOAP_CMAC tt__FactoryDefaultType_ : public xsd__anyType
{
public:
	enum tt__FactoryDefaultType __item;
public:
	virtual int soap_type() const { return 872; } /* = unique type id SOAP_TYPE_tt__FactoryDefaultType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FactoryDefaultType_() { tt__FactoryDefaultType_::soap_default(NULL); }
	virtual ~tt__FactoryDefaultType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__SetDateTimeType_
#define SOAP_TYPE_tt__SetDateTimeType_ (874)
/* Primitive tt:SetDateTimeType schema type: */
class SOAP_CMAC tt__SetDateTimeType_ : public xsd__anyType
{
public:
	enum tt__SetDateTimeType __item;
public:
	virtual int soap_type() const { return 874; } /* = unique type id SOAP_TYPE_tt__SetDateTimeType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SetDateTimeType_() { tt__SetDateTimeType_::soap_default(NULL); }
	virtual ~tt__SetDateTimeType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__UserLevel_
#define SOAP_TYPE_tt__UserLevel_ (876)
/* Primitive tt:UserLevel schema type: */
class SOAP_CMAC tt__UserLevel_ : public xsd__anyType
{
public:
	enum tt__UserLevel __item;
public:
	virtual int soap_type() const { return 876; } /* = unique type id SOAP_TYPE_tt__UserLevel_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__UserLevel_() { tt__UserLevel_::soap_default(NULL); }
	virtual ~tt__UserLevel_() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayLogicalState_
#define SOAP_TYPE_tt__RelayLogicalState_ (878)
/* Primitive tt:RelayLogicalState schema type: */
class SOAP_CMAC tt__RelayLogicalState_ : public xsd__anyType
{
public:
	enum tt__RelayLogicalState __item;
public:
	virtual int soap_type() const { return 878; } /* = unique type id SOAP_TYPE_tt__RelayLogicalState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayLogicalState_() { tt__RelayLogicalState_::soap_default(NULL); }
	virtual ~tt__RelayLogicalState_() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayIdleState_
#define SOAP_TYPE_tt__RelayIdleState_ (880)
/* Primitive tt:RelayIdleState schema type: */
class SOAP_CMAC tt__RelayIdleState_ : public xsd__anyType
{
public:
	enum tt__RelayIdleState __item;
public:
	virtual int soap_type() const { return 880; } /* = unique type id SOAP_TYPE_tt__RelayIdleState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayIdleState_() { tt__RelayIdleState_::soap_default(NULL); }
	virtual ~tt__RelayIdleState_() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayMode_
#define SOAP_TYPE_tt__RelayMode_ (882)
/* Primitive tt:RelayMode schema type: */
class SOAP_CMAC tt__RelayMode_ : public xsd__anyType
{
public:
	enum tt__RelayMode __item;
public:
	virtual int soap_type() const { return 882; } /* = unique type id SOAP_TYPE_tt__RelayMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayMode_() { tt__RelayMode_::soap_default(NULL); }
	virtual ~tt__RelayMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__DigitalIdleState_
#define SOAP_TYPE_tt__DigitalIdleState_ (884)
/* Primitive tt:DigitalIdleState schema type: */
class SOAP_CMAC tt__DigitalIdleState_ : public xsd__anyType
{
public:
	enum tt__DigitalIdleState __item;
public:
	virtual int soap_type() const { return 884; } /* = unique type id SOAP_TYPE_tt__DigitalIdleState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DigitalIdleState_() { tt__DigitalIdleState_::soap_default(NULL); }
	virtual ~tt__DigitalIdleState_() { }
};
#endif

#ifndef SOAP_TYPE_tt__EFlipMode_
#define SOAP_TYPE_tt__EFlipMode_ (886)
/* Primitive tt:EFlipMode schema type: */
class SOAP_CMAC tt__EFlipMode_ : public xsd__anyType
{
public:
	enum tt__EFlipMode __item;
public:
	virtual int soap_type() const { return 886; } /* = unique type id SOAP_TYPE_tt__EFlipMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EFlipMode_() { tt__EFlipMode_::soap_default(NULL); }
	virtual ~tt__EFlipMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReverseMode_
#define SOAP_TYPE_tt__ReverseMode_ (888)
/* Primitive tt:ReverseMode schema type: */
class SOAP_CMAC tt__ReverseMode_ : public xsd__anyType
{
public:
	enum tt__ReverseMode __item;
public:
	virtual int soap_type() const { return 888; } /* = unique type id SOAP_TYPE_tt__ReverseMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReverseMode_() { tt__ReverseMode_::soap_default(NULL); }
	virtual ~tt__ReverseMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__AuxiliaryData__
#define SOAP_TYPE_tt__AuxiliaryData__ (890)
/* Primitive tt:AuxiliaryData schema type: */
class SOAP_CMAC tt__AuxiliaryData__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 890; } /* = unique type id SOAP_TYPE_tt__AuxiliaryData__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AuxiliaryData__() { tt__AuxiliaryData__::soap_default(NULL); }
	virtual ~tt__AuxiliaryData__() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourState_
#define SOAP_TYPE_tt__PTZPresetTourState_ (892)
/* Primitive tt:PTZPresetTourState schema type: */
class SOAP_CMAC tt__PTZPresetTourState_ : public xsd__anyType
{
public:
	enum tt__PTZPresetTourState __item;
public:
	virtual int soap_type() const { return 892; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourState_() { tt__PTZPresetTourState_::soap_default(NULL); }
	virtual ~tt__PTZPresetTourState_() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourDirection_
#define SOAP_TYPE_tt__PTZPresetTourDirection_ (894)
/* Primitive tt:PTZPresetTourDirection schema type: */
class SOAP_CMAC tt__PTZPresetTourDirection_ : public xsd__anyType
{
public:
	enum tt__PTZPresetTourDirection __item;
public:
	virtual int soap_type() const { return 894; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourDirection_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourDirection_() { tt__PTZPresetTourDirection_::soap_default(NULL); }
	virtual ~tt__PTZPresetTourDirection_() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourOperation_
#define SOAP_TYPE_tt__PTZPresetTourOperation_ (896)
/* Primitive tt:PTZPresetTourOperation schema type: */
class SOAP_CMAC tt__PTZPresetTourOperation_ : public xsd__anyType
{
public:
	enum tt__PTZPresetTourOperation __item;
public:
	virtual int soap_type() const { return 896; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourOperation_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourOperation_() { tt__PTZPresetTourOperation_::soap_default(NULL); }
	virtual ~tt__PTZPresetTourOperation_() { }
};
#endif

#ifndef SOAP_TYPE_tt__AutoFocusMode_
#define SOAP_TYPE_tt__AutoFocusMode_ (898)
/* Primitive tt:AutoFocusMode schema type: */
class SOAP_CMAC tt__AutoFocusMode_ : public xsd__anyType
{
public:
	enum tt__AutoFocusMode __item;
public:
	virtual int soap_type() const { return 898; } /* = unique type id SOAP_TYPE_tt__AutoFocusMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AutoFocusMode_() { tt__AutoFocusMode_::soap_default(NULL); }
	virtual ~tt__AutoFocusMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__AFModes_
#define SOAP_TYPE_tt__AFModes_ (900)
/* Primitive tt:AFModes schema type: */
class SOAP_CMAC tt__AFModes_ : public xsd__anyType
{
public:
	enum tt__AFModes __item;
public:
	virtual int soap_type() const { return 900; } /* = unique type id SOAP_TYPE_tt__AFModes_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AFModes_() { tt__AFModes_::soap_default(NULL); }
	virtual ~tt__AFModes_() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicMode_
#define SOAP_TYPE_tt__WideDynamicMode_ (902)
/* Primitive tt:WideDynamicMode schema type: */
class SOAP_CMAC tt__WideDynamicMode_ : public xsd__anyType
{
public:
	enum tt__WideDynamicMode __item;
public:
	virtual int soap_type() const { return 902; } /* = unique type id SOAP_TYPE_tt__WideDynamicMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicMode_() { tt__WideDynamicMode_::soap_default(NULL); }
	virtual ~tt__WideDynamicMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationMode_
#define SOAP_TYPE_tt__BacklightCompensationMode_ (904)
/* Primitive tt:BacklightCompensationMode schema type: */
class SOAP_CMAC tt__BacklightCompensationMode_ : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode __item;
public:
	virtual int soap_type() const { return 904; } /* = unique type id SOAP_TYPE_tt__BacklightCompensationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensationMode_() { tt__BacklightCompensationMode_::soap_default(NULL); }
	virtual ~tt__BacklightCompensationMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposurePriority_
#define SOAP_TYPE_tt__ExposurePriority_ (906)
/* Primitive tt:ExposurePriority schema type: */
class SOAP_CMAC tt__ExposurePriority_ : public xsd__anyType
{
public:
	enum tt__ExposurePriority __item;
public:
	virtual int soap_type() const { return 906; } /* = unique type id SOAP_TYPE_tt__ExposurePriority_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposurePriority_() { tt__ExposurePriority_::soap_default(NULL); }
	virtual ~tt__ExposurePriority_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposureMode_
#define SOAP_TYPE_tt__ExposureMode_ (908)
/* Primitive tt:ExposureMode schema type: */
class SOAP_CMAC tt__ExposureMode_ : public xsd__anyType
{
public:
	enum tt__ExposureMode __item;
public:
	virtual int soap_type() const { return 908; } /* = unique type id SOAP_TYPE_tt__ExposureMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposureMode_() { tt__ExposureMode_::soap_default(NULL); }
	virtual ~tt__ExposureMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Enabled_
#define SOAP_TYPE_tt__Enabled_ (910)
/* Primitive tt:Enabled schema type: */
class SOAP_CMAC tt__Enabled_ : public xsd__anyType
{
public:
	enum tt__Enabled __item;
public:
	virtual int soap_type() const { return 910; } /* = unique type id SOAP_TYPE_tt__Enabled_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Enabled_() { tt__Enabled_::soap_default(NULL); }
	virtual ~tt__Enabled_() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceMode_
#define SOAP_TYPE_tt__WhiteBalanceMode_ (912)
/* Primitive tt:WhiteBalanceMode schema type: */
class SOAP_CMAC tt__WhiteBalanceMode_ : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode __item;
public:
	virtual int soap_type() const { return 912; } /* = unique type id SOAP_TYPE_tt__WhiteBalanceMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceMode_() { tt__WhiteBalanceMode_::soap_default(NULL); }
	virtual ~tt__WhiteBalanceMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterMode_
#define SOAP_TYPE_tt__IrCutFilterMode_ (914)
/* Primitive tt:IrCutFilterMode schema type: */
class SOAP_CMAC tt__IrCutFilterMode_ : public xsd__anyType
{
public:
	enum tt__IrCutFilterMode __item;
public:
	virtual int soap_type() const { return 914; } /* = unique type id SOAP_TYPE_tt__IrCutFilterMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IrCutFilterMode_() { tt__IrCutFilterMode_::soap_default(NULL); }
	virtual ~tt__IrCutFilterMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationMode_
#define SOAP_TYPE_tt__ImageStabilizationMode_ (916)
/* Primitive tt:ImageStabilizationMode schema type: */
class SOAP_CMAC tt__ImageStabilizationMode_ : public xsd__anyType
{
public:
	enum tt__ImageStabilizationMode __item;
public:
	virtual int soap_type() const { return 916; } /* = unique type id SOAP_TYPE_tt__ImageStabilizationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageStabilizationMode_() { tt__ImageStabilizationMode_::soap_default(NULL); }
	virtual ~tt__ImageStabilizationMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_ (918)
/* Primitive tt:IrCutFilterAutoBoundaryType schema type: */
class SOAP_CMAC tt__IrCutFilterAutoBoundaryType_ : public xsd__anyType
{
public:
	enum tt__IrCutFilterAutoBoundaryType __item;
public:
	virtual int soap_type() const { return 918; } /* = unique type id SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IrCutFilterAutoBoundaryType_() { tt__IrCutFilterAutoBoundaryType_::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoBoundaryType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ToneCompensationMode_
#define SOAP_TYPE_tt__ToneCompensationMode_ (920)
/* Primitive tt:ToneCompensationMode schema type: */
class SOAP_CMAC tt__ToneCompensationMode_ : public xsd__anyType
{
public:
	enum tt__ToneCompensationMode __item;
public:
	virtual int soap_type() const { return 920; } /* = unique type id SOAP_TYPE_tt__ToneCompensationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ToneCompensationMode_() { tt__ToneCompensationMode_::soap_default(NULL); }
	virtual ~tt__ToneCompensationMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__DefoggingMode_
#define SOAP_TYPE_tt__DefoggingMode_ (922)
/* Primitive tt:DefoggingMode schema type: */
class SOAP_CMAC tt__DefoggingMode_ : public xsd__anyType
{
public:
	enum tt__DefoggingMode __item;
public:
	virtual int soap_type() const { return 922; } /* = unique type id SOAP_TYPE_tt__DefoggingMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DefoggingMode_() { tt__DefoggingMode_::soap_default(NULL); }
	virtual ~tt__DefoggingMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageSendingType_
#define SOAP_TYPE_tt__ImageSendingType_ (924)
/* Primitive tt:ImageSendingType schema type: */
class SOAP_CMAC tt__ImageSendingType_ : public xsd__anyType
{
public:
	enum tt__ImageSendingType __item;
public:
	virtual int soap_type() const { return 924; } /* = unique type id SOAP_TYPE_tt__ImageSendingType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageSendingType_() { tt__ImageSendingType_::soap_default(NULL); }
	virtual ~tt__ImageSendingType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__PropertyOperation_
#define SOAP_TYPE_tt__PropertyOperation_ (926)
/* Primitive tt:PropertyOperation schema type: */
class SOAP_CMAC tt__PropertyOperation_ : public xsd__anyType
{
public:
	enum tt__PropertyOperation __item;
public:
	virtual int soap_type() const { return 926; } /* = unique type id SOAP_TYPE_tt__PropertyOperation_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PropertyOperation_() { tt__PropertyOperation_::soap_default(NULL); }
	virtual ~tt__PropertyOperation_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Direction_
#define SOAP_TYPE_tt__Direction_ (928)
/* Primitive tt:Direction schema type: */
class SOAP_CMAC tt__Direction_ : public xsd__anyType
{
public:
	enum tt__Direction __item;
public:
	virtual int soap_type() const { return 928; } /* = unique type id SOAP_TYPE_tt__Direction_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Direction_() { tt__Direction_::soap_default(NULL); }
	virtual ~tt__Direction_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReceiverMode_
#define SOAP_TYPE_tt__ReceiverMode_ (930)
/* Primitive tt:ReceiverMode schema type: */
class SOAP_CMAC tt__ReceiverMode_ : public xsd__anyType
{
public:
	enum tt__ReceiverMode __item;
public:
	virtual int soap_type() const { return 930; } /* = unique type id SOAP_TYPE_tt__ReceiverMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReceiverMode_() { tt__ReceiverMode_::soap_default(NULL); }
	virtual ~tt__ReceiverMode_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReceiverState_
#define SOAP_TYPE_tt__ReceiverState_ (932)
/* Primitive tt:ReceiverState schema type: */
class SOAP_CMAC tt__ReceiverState_ : public xsd__anyType
{
public:
	enum tt__ReceiverState __item;
public:
	virtual int soap_type() const { return 932; } /* = unique type id SOAP_TYPE_tt__ReceiverState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReceiverState_() { tt__ReceiverState_::soap_default(NULL); }
	virtual ~tt__ReceiverState_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Description__
#define SOAP_TYPE_tt__Description__ (934)
/* Primitive tt:Description schema type: */
class SOAP_CMAC tt__Description__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 934; } /* = unique type id SOAP_TYPE_tt__Description__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Description__() { tt__Description__::soap_default(NULL); }
	virtual ~tt__Description__() { }
};
#endif

#ifndef SOAP_TYPE_tt__XPathExpression__
#define SOAP_TYPE_tt__XPathExpression__ (936)
/* Primitive tt:XPathExpression schema type: */
class SOAP_CMAC tt__XPathExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 936; } /* = unique type id SOAP_TYPE_tt__XPathExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__XPathExpression__() { tt__XPathExpression__::soap_default(NULL); }
	virtual ~tt__XPathExpression__() { }
};
#endif

#ifndef SOAP_TYPE_tt__SearchState_
#define SOAP_TYPE_tt__SearchState_ (938)
/* Primitive tt:SearchState schema type: */
class SOAP_CMAC tt__SearchState_ : public xsd__anyType
{
public:
	enum tt__SearchState __item;
public:
	virtual int soap_type() const { return 938; } /* = unique type id SOAP_TYPE_tt__SearchState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SearchState_() { tt__SearchState_::soap_default(NULL); }
	virtual ~tt__SearchState_() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingStatus_
#define SOAP_TYPE_tt__RecordingStatus_ (940)
/* Primitive tt:RecordingStatus schema type: */
class SOAP_CMAC tt__RecordingStatus_ : public xsd__anyType
{
public:
	enum tt__RecordingStatus __item;
public:
	virtual int soap_type() const { return 940; } /* = unique type id SOAP_TYPE_tt__RecordingStatus_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingStatus_() { tt__RecordingStatus_::soap_default(NULL); }
	virtual ~tt__RecordingStatus_() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackType_
#define SOAP_TYPE_tt__TrackType_ (942)
/* Primitive tt:TrackType schema type: */
class SOAP_CMAC tt__TrackType_ : public xsd__anyType
{
public:
	enum tt__TrackType __item;
public:
	virtual int soap_type() const { return 942; } /* = unique type id SOAP_TYPE_tt__TrackType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackType_() { tt__TrackType_::soap_default(NULL); }
	virtual ~tt__TrackType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobMode__
#define SOAP_TYPE_tt__RecordingJobMode__ (944)
/* Primitive tt:RecordingJobMode schema type: */
class SOAP_CMAC tt__RecordingJobMode__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 944; } /* = unique type id SOAP_TYPE_tt__RecordingJobMode__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobMode__() { tt__RecordingJobMode__::soap_default(NULL); }
	virtual ~tt__RecordingJobMode__() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobState__
#define SOAP_TYPE_tt__RecordingJobState__ (946)
/* Primitive tt:RecordingJobState schema type: */
class SOAP_CMAC tt__RecordingJobState__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 946; } /* = unique type id SOAP_TYPE_tt__RecordingJobState__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobState__() { tt__RecordingJobState__::soap_default(NULL); }
	virtual ~tt__RecordingJobState__() { }
};
#endif

#ifndef SOAP_TYPE_tt__ModeOfOperation_
#define SOAP_TYPE_tt__ModeOfOperation_ (948)
/* Primitive tt:ModeOfOperation schema type: */
class SOAP_CMAC tt__ModeOfOperation_ : public xsd__anyType
{
public:
	enum tt__ModeOfOperation __item;
public:
	virtual int soap_type() const { return 948; } /* = unique type id SOAP_TYPE_tt__ModeOfOperation_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ModeOfOperation_() { tt__ModeOfOperation_::soap_default(NULL); }
	virtual ~tt__ModeOfOperation_() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioClassType__
#define SOAP_TYPE_tt__AudioClassType__ (950)
/* Primitive tt:AudioClassType schema type: */
class SOAP_CMAC tt__AudioClassType__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 950; } /* = unique type id SOAP_TYPE_tt__AudioClassType__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioClassType__() { tt__AudioClassType__::soap_default(NULL); }
	virtual ~tt__AudioClassType__() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDType_
#define SOAP_TYPE_tt__OSDType_ (952)
/* Primitive tt:OSDType schema type: */
class SOAP_CMAC tt__OSDType_ : public xsd__anyType
{
public:
	enum tt__OSDType __item;
public:
	virtual int soap_type() const { return 952; } /* = unique type id SOAP_TYPE_tt__OSDType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDType_() { tt__OSDType_::soap_default(NULL); }
	virtual ~tt__OSDType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReferenceToken__
#define SOAP_TYPE_tt__ReferenceToken__ (954)
/* Primitive tt:ReferenceToken schema type: */
class SOAP_CMAC tt__ReferenceToken__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 954; } /* = unique type id SOAP_TYPE_tt__ReferenceToken__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReferenceToken__() { tt__ReferenceToken__::soap_default(NULL); }
	virtual ~tt__ReferenceToken__() { }
};
#endif

#ifndef SOAP_TYPE_tt__MoveStatus_
#define SOAP_TYPE_tt__MoveStatus_ (956)
/* Primitive tt:MoveStatus schema type: */
class SOAP_CMAC tt__MoveStatus_ : public xsd__anyType
{
public:
	enum tt__MoveStatus __item;
public:
	virtual int soap_type() const { return 956; } /* = unique type id SOAP_TYPE_tt__MoveStatus_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MoveStatus_() { tt__MoveStatus_::soap_default(NULL); }
	virtual ~tt__MoveStatus_() { }
};
#endif

#ifndef SOAP_TYPE_tt__Entity_
#define SOAP_TYPE_tt__Entity_ (958)
/* Primitive tt:Entity schema type: */
class SOAP_CMAC tt__Entity_ : public xsd__anyType
{
public:
	enum tt__Entity __item;
public:
	virtual int soap_type() const { return 958; } /* = unique type id SOAP_TYPE_tt__Entity_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Entity_() { tt__Entity_::soap_default(NULL); }
	virtual ~tt__Entity_() { }
};
#endif

#ifndef SOAP_TYPE_wstop__FullTopicExpression__
#define SOAP_TYPE_wstop__FullTopicExpression__ (960)
/* Primitive wstop:FullTopicExpression schema type: */
class SOAP_CMAC wstop__FullTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 960; } /* = unique type id SOAP_TYPE_wstop__FullTopicExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__FullTopicExpression__() { wstop__FullTopicExpression__::soap_default(NULL); }
	virtual ~wstop__FullTopicExpression__() { }
};
#endif

#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression__
#define SOAP_TYPE_wstop__ConcreteTopicExpression__ (962)
/* Primitive wstop:ConcreteTopicExpression schema type: */
class SOAP_CMAC wstop__ConcreteTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 962; } /* = unique type id SOAP_TYPE_wstop__ConcreteTopicExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__ConcreteTopicExpression__() { wstop__ConcreteTopicExpression__::soap_default(NULL); }
	virtual ~wstop__ConcreteTopicExpression__() { }
};
#endif

#ifndef SOAP_TYPE_wstop__SimpleTopicExpression__
#define SOAP_TYPE_wstop__SimpleTopicExpression__ (964)
/* Primitive wstop:SimpleTopicExpression schema type: */
class SOAP_CMAC wstop__SimpleTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 964; } /* = unique type id SOAP_TYPE_wstop__SimpleTopicExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__SimpleTopicExpression__() { wstop__SimpleTopicExpression__::soap_default(NULL); }
	virtual ~wstop__SimpleTopicExpression__() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ConfigurationEnumeration_
#define SOAP_TYPE_ns1__ConfigurationEnumeration_ (966)
/* Primitive ns1:ConfigurationEnumeration schema type: */
class SOAP_CMAC ns1__ConfigurationEnumeration_ : public xsd__anyType
{
public:
	enum ns1__ConfigurationEnumeration __item;
public:
	virtual int soap_type() const { return 966; } /* = unique type id SOAP_TYPE_ns1__ConfigurationEnumeration_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ConfigurationEnumeration_() { ns1__ConfigurationEnumeration_::soap_default(NULL); }
	virtual ~ns1__ConfigurationEnumeration_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TransportProtocol_
#define SOAP_TYPE_ns1__TransportProtocol_ (968)
/* Primitive ns1:TransportProtocol schema type: */
class SOAP_CMAC ns1__TransportProtocol_ : public xsd__anyType
{
public:
	enum ns1__TransportProtocol __item;
public:
	virtual int soap_type() const { return 968; } /* = unique type id SOAP_TYPE_ns1__TransportProtocol_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TransportProtocol_() { ns1__TransportProtocol_::soap_default(NULL); }
	virtual ~ns1__TransportProtocol_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MaskType_
#define SOAP_TYPE_ns1__MaskType_ (970)
/* Primitive ns1:MaskType schema type: */
class SOAP_CMAC ns1__MaskType_ : public xsd__anyType
{
public:
	enum ns1__MaskType __item;
public:
	virtual int soap_type() const { return 970; } /* = unique type id SOAP_TYPE_ns1__MaskType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MaskType_() { ns1__MaskType_::soap_default(NULL); }
	virtual ~ns1__MaskType_() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReceiverReference__
#define SOAP_TYPE_tt__ReceiverReference__ (972)
/* Primitive tt:ReceiverReference schema type: */
class SOAP_CMAC tt__ReceiverReference__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 972; } /* = unique type id SOAP_TYPE_tt__ReceiverReference__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReceiverReference__() { tt__ReceiverReference__::soap_default(NULL); }
	virtual ~tt__ReceiverReference__() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingReference__
#define SOAP_TYPE_tt__RecordingReference__ (974)
/* Primitive tt:RecordingReference schema type: */
class SOAP_CMAC tt__RecordingReference__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 974; } /* = unique type id SOAP_TYPE_tt__RecordingReference__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingReference__() { tt__RecordingReference__::soap_default(NULL); }
	virtual ~tt__RecordingReference__() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackReference__
#define SOAP_TYPE_tt__TrackReference__ (976)
/* Primitive tt:TrackReference schema type: */
class SOAP_CMAC tt__TrackReference__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 976; } /* = unique type id SOAP_TYPE_tt__TrackReference__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackReference__() { tt__TrackReference__::soap_default(NULL); }
	virtual ~tt__TrackReference__() { }
};
#endif

#ifndef SOAP_TYPE_tt__JobToken__
#define SOAP_TYPE_tt__JobToken__ (978)
/* Primitive tt:JobToken schema type: */
class SOAP_CMAC tt__JobToken__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 978; } /* = unique type id SOAP_TYPE_tt__JobToken__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__JobToken__() { tt__JobToken__::soap_default(NULL); }
	virtual ~tt__JobToken__() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobReference__
#define SOAP_TYPE_tt__RecordingJobReference__ (980)
/* Primitive tt:RecordingJobReference schema type: */
class SOAP_CMAC tt__RecordingJobReference__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 980; } /* = unique type id SOAP_TYPE_tt__RecordingJobReference__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobReference__() { tt__RecordingJobReference__::soap_default(NULL); }
	virtual ~tt__RecordingJobReference__() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (187)
/* Primitive tt:DeviceEntity schema type: */
class SOAP_CMAC tt__DeviceEntity : public xsd__anyType
{
public:
	std::string token;	/* required attribute */
public:
	virtual int soap_type() const { return 187; } /* = unique type id SOAP_TYPE_tt__DeviceEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceEntity() { tt__DeviceEntity::soap_default(NULL); }
	virtual ~tt__DeviceEntity() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (188)
/* Primitive tt:IntRectangle schema type: */
class SOAP_CMAC tt__IntRectangle : public xsd__anyType
{
public:
	int x;	/* required attribute */
	int y;	/* required attribute */
	int width;	/* required attribute */
	int height;	/* required attribute */
public:
	virtual int soap_type() const { return 188; } /* = unique type id SOAP_TYPE_tt__IntRectangle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntRectangle() { tt__IntRectangle::soap_default(NULL); }
	virtual ~tt__IntRectangle() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (189)
/* tt:IntRectangleRange */
class SOAP_CMAC tt__IntRectangleRange : public xsd__anyType
{
public:
	class tt__IntRange *XRange;	/* required element of type tt:IntRange */
	tt__IntRange *YRange;	/* required element of type tt:IntRange */
	tt__IntRange *WidthRange;	/* required element of type tt:IntRange */
	tt__IntRange *HeightRange;	/* required element of type tt:IntRange */
public:
	virtual int soap_type() const { return 189; } /* = unique type id SOAP_TYPE_tt__IntRectangleRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntRectangleRange() { tt__IntRectangleRange::soap_default(NULL); }
	virtual ~tt__IntRectangleRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (190)
/* tt:FloatRange */
class SOAP_CMAC tt__FloatRange : public xsd__anyType
{
public:
	float Min;	/* required element of type xsd:float */
	float Max;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 190; } /* = unique type id SOAP_TYPE_tt__FloatRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FloatRange() { tt__FloatRange::soap_default(NULL); }
	virtual ~tt__FloatRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (191)
/* tt:DurationRange */
class SOAP_CMAC tt__DurationRange : public xsd__anyType
{
public:
	LONG64 Min;	/* external */
	LONG64 Max;	/* external */
public:
	virtual int soap_type() const { return 191; } /* = unique type id SOAP_TYPE_tt__DurationRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DurationRange() { tt__DurationRange::soap_default(NULL); }
	virtual ~tt__DurationRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntItems
#define SOAP_TYPE_tt__IntItems (192)
/* tt:IntItems */
class SOAP_CMAC tt__IntItems : public xsd__anyType
{
public:
	std::vector<int >Items;	/* optional element of type xsd:int */
public:
	virtual int soap_type() const { return 192; } /* = unique type id SOAP_TYPE_tt__IntItems */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntItems() { tt__IntItems::soap_default(NULL); }
	virtual ~tt__IntItems() { }
};
#endif

#ifndef SOAP_TYPE_tt__FloatItems
#define SOAP_TYPE_tt__FloatItems (193)
/* tt:FloatItems */
class SOAP_CMAC tt__FloatItems : public xsd__anyType
{
public:
	std::vector<float >Items;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 193; } /* = unique type id SOAP_TYPE_tt__FloatItems */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FloatItems() { tt__FloatItems::soap_default(NULL); }
	virtual ~tt__FloatItems() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnyHolder
#define SOAP_TYPE_tt__AnyHolder (194)
/* tt:AnyHolder */
class SOAP_CMAC tt__AnyHolder : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 194; } /* = unique type id SOAP_TYPE_tt__AnyHolder */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnyHolder() { tt__AnyHolder::soap_default(NULL); }
	virtual ~tt__AnyHolder() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (196)
/* tt:VideoSourceExtension */
class SOAP_CMAC tt__VideoSourceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class tt__ImagingSettings20 *Imaging;	/* optional element of type tt:ImagingSettings20 */
	class tt__VideoSourceExtension2 *Extension;	/* optional element of type tt:VideoSourceExtension2 */
public:
	virtual int soap_type() const { return 196; } /* = unique type id SOAP_TYPE_tt__VideoSourceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceExtension() { tt__VideoSourceExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (197)
/* tt:VideoSourceExtension2 */
class SOAP_CMAC tt__VideoSourceExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 197; } /* = unique type id SOAP_TYPE_tt__VideoSourceExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceExtension2() { tt__VideoSourceExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (199)
/* tt:Profile */
class SOAP_CMAC tt__Profile : public xsd__anyType
{
public:
	std::string Name;	/* required element of type tt:Name */
	class tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* optional element of type tt:VideoSourceConfiguration */
	class tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* optional element of type tt:AudioSourceConfiguration */
	class tt__VideoEncoderConfiguration *VideoEncoderConfiguration;	/* optional element of type tt:VideoEncoderConfiguration */
	class tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of type tt:AudioEncoderConfiguration */
	class tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* optional element of type tt:VideoAnalyticsConfiguration */
	class tt__PTZConfiguration *PTZConfiguration;	/* optional element of type tt:PTZConfiguration */
	class tt__MetadataConfiguration *MetadataConfiguration;	/* optional element of type tt:MetadataConfiguration */
	class tt__ProfileExtension *Extension;	/* optional element of type tt:ProfileExtension */
	std::string token;	/* required attribute */
	bool *fixed;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 199; } /* = unique type id SOAP_TYPE_tt__Profile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Profile() { tt__Profile::soap_default(NULL); }
	virtual ~tt__Profile() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (200)
/* tt:ProfileExtension */
class SOAP_CMAC tt__ProfileExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class tt__AudioOutputConfiguration *AudioOutputConfiguration;	/* optional element of type tt:AudioOutputConfiguration */
	class tt__AudioDecoderConfiguration *AudioDecoderConfiguration;	/* optional element of type tt:AudioDecoderConfiguration */
	class tt__ProfileExtension2 *Extension;	/* optional element of type tt:ProfileExtension2 */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 200; } /* = unique type id SOAP_TYPE_tt__ProfileExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileExtension() { tt__ProfileExtension::soap_default(NULL); }
	virtual ~tt__ProfileExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (201)
/* tt:ProfileExtension2 */
class SOAP_CMAC tt__ProfileExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 201; } /* = unique type id SOAP_TYPE_tt__ProfileExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileExtension2() { tt__ProfileExtension2::soap_default(NULL); }
	virtual ~tt__ProfileExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (202)
/* tt:ConfigurationEntity */
class SOAP_CMAC tt__ConfigurationEntity : public xsd__anyType
{
public:
	std::string Name;	/* required element of type tt:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
public:
	virtual int soap_type() const { return 202; } /* = unique type id SOAP_TYPE_tt__ConfigurationEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ConfigurationEntity() { tt__ConfigurationEntity::soap_default(NULL); }
	virtual ~tt__ConfigurationEntity() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (204)
/* tt:VideoSourceConfigurationExtension */
class SOAP_CMAC tt__VideoSourceConfigurationExtension : public xsd__anyType
{
public:
	class tt__Rotate *Rotate;	/* optional element of type tt:Rotate */
	class tt__VideoSourceConfigurationExtension2 *Extension;	/* optional element of type tt:VideoSourceConfigurationExtension2 */
public:
	virtual int soap_type() const { return 204; } /* = unique type id SOAP_TYPE_tt__VideoSourceConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationExtension() { tt__VideoSourceConfigurationExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (205)
/* tt:VideoSourceConfigurationExtension2 */
class SOAP_CMAC tt__VideoSourceConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<class tt__LensDescription * >LensDescription;	/* optional element of type tt:LensDescription */
	class tt__SceneOrientation *SceneOrientation;	/* optional element of type tt:SceneOrientation */
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 205; } /* = unique type id SOAP_TYPE_tt__VideoSourceConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationExtension2() { tt__VideoSourceConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (206)
/* tt:Rotate */
class SOAP_CMAC tt__Rotate : public xsd__anyType
{
public:
	enum tt__RotateMode Mode;	/* required element of type tt:RotateMode */
	int *Degree;	/* optional element of type xsd:int */
	class tt__RotateExtension *Extension;	/* optional element of type tt:RotateExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 206; } /* = unique type id SOAP_TYPE_tt__Rotate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Rotate() { tt__Rotate::soap_default(NULL); }
	virtual ~tt__Rotate() { }
};
#endif

#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (207)
/* tt:RotateExtension */
class SOAP_CMAC tt__RotateExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 207; } /* = unique type id SOAP_TYPE_tt__RotateExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RotateExtension() { tt__RotateExtension::soap_default(NULL); }
	virtual ~tt__RotateExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (208)
/* tt:LensProjection */
class SOAP_CMAC tt__LensProjection : public xsd__anyType
{
public:
	float Angle;	/* required element of type xsd:float */
	float Radius;	/* required element of type xsd:float */
	float *Transmittance;	/* optional element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 208; } /* = unique type id SOAP_TYPE_tt__LensProjection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LensProjection() { tt__LensProjection::soap_default(NULL); }
	virtual ~tt__LensProjection() { }
};
#endif

#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (209)
/* Primitive tt:LensOffset schema type: */
class SOAP_CMAC tt__LensOffset : public xsd__anyType
{
public:
	float *x;	/* optional attribute */
	float *y;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 209; } /* = unique type id SOAP_TYPE_tt__LensOffset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LensOffset() { tt__LensOffset::soap_default(NULL); }
	virtual ~tt__LensOffset() { }
};
#endif

#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (210)
/* tt:LensDescription */
class SOAP_CMAC tt__LensDescription : public xsd__anyType
{
public:
	tt__LensOffset *Offset;	/* required element of type tt:LensOffset */
	std::vector<tt__LensProjection * >Projection;	/* required element of type tt:LensProjection */
	float XFactor;	/* required element of type xsd:float */
	std::vector<char * >__any;
	float *FocalLength;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 210; } /* = unique type id SOAP_TYPE_tt__LensDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LensDescription() { tt__LensDescription::soap_default(NULL); }
	virtual ~tt__LensDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (211)
/* tt:VideoSourceConfigurationOptions */
class SOAP_CMAC tt__VideoSourceConfigurationOptions : public xsd__anyType
{
public:
	tt__IntRectangleRange *BoundsRange;	/* required element of type tt:IntRectangleRange */
	std::vector<std::string >VideoSourceTokensAvailable;	/* required element of type tt:ReferenceToken */
	class tt__VideoSourceConfigurationOptionsExtension *Extension;	/* optional element of type tt:VideoSourceConfigurationOptionsExtension */
	int *MaximumNumberOfProfiles;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 211; } /* = unique type id SOAP_TYPE_tt__VideoSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationOptions() { tt__VideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (212)
/* tt:VideoSourceConfigurationOptionsExtension */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class tt__RotateOptions *Rotate;	/* optional element of type tt:RotateOptions */
	class tt__VideoSourceConfigurationOptionsExtension2 *Extension;	/* optional element of type tt:VideoSourceConfigurationOptionsExtension2 */
public:
	virtual int soap_type() const { return 212; } /* = unique type id SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationOptionsExtension() { tt__VideoSourceConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (213)
/* tt:VideoSourceConfigurationOptionsExtension2 */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension2 : public xsd__anyType
{
public:
	std::vector<enum tt__SceneOrientationMode >SceneOrientationMode;	/* optional element of type tt:SceneOrientationMode */
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 213; } /* = unique type id SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationOptionsExtension2() { tt__VideoSourceConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (214)
/* tt:RotateOptions */
class SOAP_CMAC tt__RotateOptions : public xsd__anyType
{
public:
	std::vector<enum tt__RotateMode >Mode;	/* required element of type tt:RotateMode */
	tt__IntItems *DegreeList;	/* optional element of type tt:IntItems */
	class tt__RotateOptionsExtension *Extension;	/* optional element of type tt:RotateOptionsExtension */
	bool *Reboot;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 214; } /* = unique type id SOAP_TYPE_tt__RotateOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RotateOptions() { tt__RotateOptions::soap_default(NULL); }
	virtual ~tt__RotateOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (215)
/* tt:RotateOptionsExtension */
class SOAP_CMAC tt__RotateOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 215; } /* = unique type id SOAP_TYPE_tt__RotateOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RotateOptionsExtension() { tt__RotateOptionsExtension::soap_default(NULL); }
	virtual ~tt__RotateOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SceneOrientation
#define SOAP_TYPE_tt__SceneOrientation (216)
/* tt:SceneOrientation */
class SOAP_CMAC tt__SceneOrientation : public xsd__anyType
{
public:
	enum tt__SceneOrientationMode Mode;	/* required element of type tt:SceneOrientationMode */
	std::string *Orientation;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 216; } /* = unique type id SOAP_TYPE_tt__SceneOrientation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SceneOrientation() { tt__SceneOrientation::soap_default(NULL); }
	virtual ~tt__SceneOrientation() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (218)
/* tt:VideoResolution */
class SOAP_CMAC tt__VideoResolution : public xsd__anyType
{
public:
	int Width;	/* required element of type xsd:int */
	int Height;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 218; } /* = unique type id SOAP_TYPE_tt__VideoResolution */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoResolution() { tt__VideoResolution::soap_default(NULL); }
	virtual ~tt__VideoResolution() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (219)
/* tt:VideoRateControl */
class SOAP_CMAC tt__VideoRateControl : public xsd__anyType
{
public:
	int FrameRateLimit;	/* required element of type xsd:int */
	int EncodingInterval;	/* required element of type xsd:int */
	int BitrateLimit;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 219; } /* = unique type id SOAP_TYPE_tt__VideoRateControl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoRateControl() { tt__VideoRateControl::soap_default(NULL); }
	virtual ~tt__VideoRateControl() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (220)
/* tt:Mpeg4Configuration */
class SOAP_CMAC tt__Mpeg4Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of type xsd:int */
	enum tt__Mpeg4Profile Mpeg4Profile;	/* required element of type tt:Mpeg4Profile */
public:
	virtual int soap_type() const { return 220; } /* = unique type id SOAP_TYPE_tt__Mpeg4Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Configuration() { tt__Mpeg4Configuration::soap_default(NULL); }
	virtual ~tt__Mpeg4Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (221)
/* tt:H264Configuration */
class SOAP_CMAC tt__H264Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of type xsd:int */
	enum tt__H264Profile H264Profile;	/* required element of type tt:H264Profile */
public:
	virtual int soap_type() const { return 221; } /* = unique type id SOAP_TYPE_tt__H264Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Configuration() { tt__H264Configuration::soap_default(NULL); }
	virtual ~tt__H264Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (222)
/* tt:VideoEncoderConfigurationOptions */
class SOAP_CMAC tt__VideoEncoderConfigurationOptions : public xsd__anyType
{
public:
	tt__IntRange *QualityRange;	/* required element of type tt:IntRange */
	class tt__JpegOptions *JPEG;	/* optional element of type tt:JpegOptions */
	class tt__Mpeg4Options *MPEG4;	/* optional element of type tt:Mpeg4Options */
	class tt__H264Options *H264;	/* optional element of type tt:H264Options */
	class tt__VideoEncoderOptionsExtension *Extension;	/* optional element of type tt:VideoEncoderOptionsExtension */
	bool *GuaranteedFrameRateSupported;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 222; } /* = unique type id SOAP_TYPE_tt__VideoEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderConfigurationOptions() { tt__VideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (223)
/* tt:VideoEncoderOptionsExtension */
class SOAP_CMAC tt__VideoEncoderOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class tt__JpegOptions2 *JPEG;	/* optional element of type tt:JpegOptions2 */
	class tt__Mpeg4Options2 *MPEG4;	/* optional element of type tt:Mpeg4Options2 */
	class tt__H264Options2 *H264;	/* optional element of type tt:H264Options2 */
	class tt__VideoEncoderOptionsExtension2 *Extension;	/* optional element of type tt:VideoEncoderOptionsExtension2 */
public:
	virtual int soap_type() const { return 223; } /* = unique type id SOAP_TYPE_tt__VideoEncoderOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderOptionsExtension() { tt__VideoEncoderOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (224)
/* tt:VideoEncoderOptionsExtension2 */
class SOAP_CMAC tt__VideoEncoderOptionsExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 224; } /* = unique type id SOAP_TYPE_tt__VideoEncoderOptionsExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderOptionsExtension2() { tt__VideoEncoderOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (225)
/* tt:JpegOptions */
class SOAP_CMAC tt__JpegOptions : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution * >ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *FrameRateRange;	/* required element of type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of type tt:IntRange */
public:
	virtual int soap_type() const { return 225; } /* = unique type id SOAP_TYPE_tt__JpegOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__JpegOptions() { tt__JpegOptions::soap_default(NULL); }
	virtual ~tt__JpegOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (227)
/* tt:Mpeg4Options */
class SOAP_CMAC tt__Mpeg4Options : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution * >ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of type tt:IntRange */
	std::vector<enum tt__Mpeg4Profile >Mpeg4ProfilesSupported;	/* required element of type tt:Mpeg4Profile */
public:
	virtual int soap_type() const { return 227; } /* = unique type id SOAP_TYPE_tt__Mpeg4Options */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Options() { tt__Mpeg4Options::soap_default(NULL); }
	virtual ~tt__Mpeg4Options() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (229)
/* tt:H264Options */
class SOAP_CMAC tt__H264Options : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution * >ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of type tt:IntRange */
	std::vector<enum tt__H264Profile >H264ProfilesSupported;	/* required element of type tt:H264Profile */
public:
	virtual int soap_type() const { return 229; } /* = unique type id SOAP_TYPE_tt__H264Options */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Options() { tt__H264Options::soap_default(NULL); }
	virtual ~tt__H264Options() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoResolution2
#define SOAP_TYPE_tt__VideoResolution2 (232)
/* tt:VideoResolution2 */
class SOAP_CMAC tt__VideoResolution2 : public xsd__anyType
{
public:
	int Width;	/* required element of type xsd:int */
	int Height;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 232; } /* = unique type id SOAP_TYPE_tt__VideoResolution2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoResolution2() { tt__VideoResolution2::soap_default(NULL); }
	virtual ~tt__VideoResolution2() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoRateControl2
#define SOAP_TYPE_tt__VideoRateControl2 (233)
/* tt:VideoRateControl2 */
class SOAP_CMAC tt__VideoRateControl2 : public xsd__anyType
{
public:
	float FrameRateLimit;	/* required element of type xsd:float */
	int BitrateLimit;	/* required element of type xsd:int */
	std::vector<char * >__any;
	bool *ConstantBitRate;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 233; } /* = unique type id SOAP_TYPE_tt__VideoRateControl2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoRateControl2() { tt__VideoRateControl2::soap_default(NULL); }
	virtual ~tt__VideoRateControl2() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions (234)
/* tt:VideoEncoder2ConfigurationOptions */
class SOAP_CMAC tt__VideoEncoder2ConfigurationOptions : public xsd__anyType
{
public:
	std::string Encoding;	/* required element of type xsd:string */
	tt__FloatRange *QualityRange;	/* required element of type tt:FloatRange */
	std::vector<tt__VideoResolution2 * >ResolutionsAvailable;	/* required element of type tt:VideoResolution2 */
	tt__IntRange *BitrateRange;	/* required element of type tt:IntRange */
	std::vector<char * >__any;
	std::string *GovLengthRange;	/* optional attribute */
	std::string *FrameRatesSupported;	/* optional attribute */
	std::string *ProfilesSupported;	/* optional attribute */
	bool *ConstantBitRateSupported;	/* optional attribute */
	bool *GuaranteedFrameRateSupported;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 234; } /* = unique type id SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoder2ConfigurationOptions() { tt__VideoEncoder2ConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoder2ConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (236)
/* tt:AudioSourceConfigurationOptions */
class SOAP_CMAC tt__AudioSourceConfigurationOptions : public xsd__anyType
{
public:
	std::vector<std::string >InputTokensAvailable;	/* required element of type tt:ReferenceToken */
	class tt__AudioSourceOptionsExtension *Extension;	/* optional element of type tt:AudioSourceOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 236; } /* = unique type id SOAP_TYPE_tt__AudioSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSourceConfigurationOptions() { tt__AudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (237)
/* tt:AudioSourceOptionsExtension */
class SOAP_CMAC tt__AudioSourceOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 237; } /* = unique type id SOAP_TYPE_tt__AudioSourceOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSourceOptionsExtension() { tt__AudioSourceOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioSourceOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (239)
/* tt:AudioEncoderConfigurationOptions */
class SOAP_CMAC tt__AudioEncoderConfigurationOptions : public xsd__anyType
{
public:
	std::vector<class tt__AudioEncoderConfigurationOption * >Options;	/* optional element of type tt:AudioEncoderConfigurationOption */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 239; } /* = unique type id SOAP_TYPE_tt__AudioEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoderConfigurationOptions() { tt__AudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (240)
/* tt:AudioEncoderConfigurationOption */
class SOAP_CMAC tt__AudioEncoderConfigurationOption : public xsd__anyType
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of type tt:AudioEncoding */
	tt__IntItems *BitrateList;	/* required element of type tt:IntItems */
	tt__IntItems *SampleRateList;	/* required element of type tt:IntItems */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 240; } /* = unique type id SOAP_TYPE_tt__AudioEncoderConfigurationOption */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoderConfigurationOption() { tt__AudioEncoderConfigurationOption::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOption() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions (242)
/* tt:AudioEncoder2ConfigurationOptions */
class SOAP_CMAC tt__AudioEncoder2ConfigurationOptions : public xsd__anyType
{
public:
	std::string Encoding;	/* required element of type xsd:string */
	tt__IntItems *BitrateList;	/* required element of type tt:IntItems */
	tt__IntItems *SampleRateList;	/* required element of type tt:IntItems */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 242; } /* = unique type id SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoder2ConfigurationOptions() { tt__AudioEncoder2ConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoder2ConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (245)
/* tt:MetadataConfigurationExtension */
class SOAP_CMAC tt__MetadataConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 245; } /* = unique type id SOAP_TYPE_tt__MetadataConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfigurationExtension() { tt__MetadataConfigurationExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (246)
/* tt:PTZFilter */
class SOAP_CMAC tt__PTZFilter : public xsd__anyType
{
public:
	bool Status;	/* required element of type xsd:boolean */
	bool Position;	/* required element of type xsd:boolean */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 246; } /* = unique type id SOAP_TYPE_tt__PTZFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZFilter() { tt__PTZFilter::soap_default(NULL); }
	virtual ~tt__PTZFilter() { }
};
#endif

#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1041)
/* tt:EventSubscription-SubscriptionPolicy */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1041; } /* = unique type id SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__EventSubscription_SubscriptionPolicy() { _tt__EventSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (247)
/* tt:EventSubscription */
class SOAP_CMAC tt__EventSubscription : public xsd__anyType
{
public:
	class wsnt__FilterType *Filter;	/* optional element of type wsnt:FilterType */
	_tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of type tt:EventSubscription-SubscriptionPolicy */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 247; } /* = unique type id SOAP_TYPE_tt__EventSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventSubscription() { tt__EventSubscription::soap_default(NULL); }
	virtual ~tt__EventSubscription() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (248)
/* tt:MetadataConfigurationOptions */
class SOAP_CMAC tt__MetadataConfigurationOptions : public xsd__anyType
{
public:
	class tt__PTZStatusFilterOptions *PTZStatusFilterOptions;	/* required element of type tt:PTZStatusFilterOptions */
	std::vector<char * >__any;
	class tt__MetadataConfigurationOptionsExtension *Extension;	/* optional element of type tt:MetadataConfigurationOptionsExtension */
	bool *GeoLocation;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 248; } /* = unique type id SOAP_TYPE_tt__MetadataConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfigurationOptions() { tt__MetadataConfigurationOptions::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (249)
/* tt:MetadataConfigurationOptionsExtension */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<std::string >CompressionType;	/* optional element of type xsd:string */
	class tt__MetadataConfigurationOptionsExtension2 *Extension;	/* optional element of type tt:MetadataConfigurationOptionsExtension2 */
public:
	virtual int soap_type() const { return 249; } /* = unique type id SOAP_TYPE_tt__MetadataConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfigurationOptionsExtension() { tt__MetadataConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (250)
/* tt:MetadataConfigurationOptionsExtension2 */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 250; } /* = unique type id SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfigurationOptionsExtension2() { tt__MetadataConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptionsExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (251)
/* tt:PTZStatusFilterOptions */
class SOAP_CMAC tt__PTZStatusFilterOptions : public xsd__anyType
{
public:
	bool PanTiltStatusSupported;	/* required element of type xsd:boolean */
	bool ZoomStatusSupported;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	bool *PanTiltPositionSupported;	/* optional element of type xsd:boolean */
	bool *ZoomPositionSupported;	/* optional element of type xsd:boolean */
	class tt__PTZStatusFilterOptionsExtension *Extension;	/* optional element of type tt:PTZStatusFilterOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 251; } /* = unique type id SOAP_TYPE_tt__PTZStatusFilterOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStatusFilterOptions() { tt__PTZStatusFilterOptions::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (252)
/* tt:PTZStatusFilterOptionsExtension */
class SOAP_CMAC tt__PTZStatusFilterOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 252; } /* = unique type id SOAP_TYPE_tt__PTZStatusFilterOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStatusFilterOptionsExtension() { tt__PTZStatusFilterOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (254)
/* tt:VideoOutputExtension */
class SOAP_CMAC tt__VideoOutputExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 254; } /* = unique type id SOAP_TYPE_tt__VideoOutputExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoOutputExtension() { tt__VideoOutputExtension::soap_default(NULL); }
	virtual ~tt__VideoOutputExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (256)
/* tt:VideoOutputConfigurationOptions */
class SOAP_CMAC tt__VideoOutputConfigurationOptions : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 256; } /* = unique type id SOAP_TYPE_tt__VideoOutputConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoOutputConfigurationOptions() { tt__VideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoOutputConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptions
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptions (257)
/* tt:VideoDecoderConfigurationOptions */
class SOAP_CMAC tt__VideoDecoderConfigurationOptions : public xsd__anyType
{
public:
	class tt__JpegDecOptions *JpegDecOptions;	/* optional element of type tt:JpegDecOptions */
	class tt__H264DecOptions *H264DecOptions;	/* optional element of type tt:H264DecOptions */
	class tt__Mpeg4DecOptions *Mpeg4DecOptions;	/* optional element of type tt:Mpeg4DecOptions */
	class tt__VideoDecoderConfigurationOptionsExtension *Extension;	/* optional element of type tt:VideoDecoderConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 257; } /* = unique type id SOAP_TYPE_tt__VideoDecoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoDecoderConfigurationOptions() { tt__VideoDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264DecOptions
#define SOAP_TYPE_tt__H264DecOptions (258)
/* tt:H264DecOptions */
class SOAP_CMAC tt__H264DecOptions : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution * >ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	std::vector<enum tt__H264Profile >SupportedH264Profiles;	/* required element of type tt:H264Profile */
	tt__IntRange *SupportedInputBitrate;	/* required element of type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of type tt:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 258; } /* = unique type id SOAP_TYPE_tt__H264DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264DecOptions() { tt__H264DecOptions::soap_default(NULL); }
	virtual ~tt__H264DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__JpegDecOptions
#define SOAP_TYPE_tt__JpegDecOptions (259)
/* tt:JpegDecOptions */
class SOAP_CMAC tt__JpegDecOptions : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution * >ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *SupportedInputBitrate;	/* required element of type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of type tt:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 259; } /* = unique type id SOAP_TYPE_tt__JpegDecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__JpegDecOptions() { tt__JpegDecOptions::soap_default(NULL); }
	virtual ~tt__JpegDecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4DecOptions
#define SOAP_TYPE_tt__Mpeg4DecOptions (260)
/* tt:Mpeg4DecOptions */
class SOAP_CMAC tt__Mpeg4DecOptions : public xsd__anyType
{
public:
	std::vector<tt__VideoResolution * >ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	std::vector<enum tt__Mpeg4Profile >SupportedMpeg4Profiles;	/* required element of type tt:Mpeg4Profile */
	tt__IntRange *SupportedInputBitrate;	/* required element of type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of type tt:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 260; } /* = unique type id SOAP_TYPE_tt__Mpeg4DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4DecOptions() { tt__Mpeg4DecOptions::soap_default(NULL); }
	virtual ~tt__Mpeg4DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (261)
/* tt:VideoDecoderConfigurationOptionsExtension */
class SOAP_CMAC tt__VideoDecoderConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 261; } /* = unique type id SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoDecoderConfigurationOptionsExtension() { tt__VideoDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (264)
/* tt:AudioOutputConfigurationOptions */
class SOAP_CMAC tt__AudioOutputConfigurationOptions : public xsd__anyType
{
public:
	std::vector<std::string >OutputTokensAvailable;	/* required element of type tt:ReferenceToken */
	std::vector<std::string >SendPrimacyOptions;	/* optional element of type xsd:anyURI */
	tt__IntRange *OutputLevelRange;	/* required element of type tt:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 264; } /* = unique type id SOAP_TYPE_tt__AudioOutputConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioOutputConfigurationOptions() { tt__AudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioOutputConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (266)
/* tt:AudioDecoderConfigurationOptions */
class SOAP_CMAC tt__AudioDecoderConfigurationOptions : public xsd__anyType
{
public:
	class tt__AACDecOptions *AACDecOptions;	/* optional element of type tt:AACDecOptions */
	class tt__G711DecOptions *G711DecOptions;	/* optional element of type tt:G711DecOptions */
	class tt__G726DecOptions *G726DecOptions;	/* optional element of type tt:G726DecOptions */
	class tt__AudioDecoderConfigurationOptionsExtension *Extension;	/* optional element of type tt:AudioDecoderConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 266; } /* = unique type id SOAP_TYPE_tt__AudioDecoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioDecoderConfigurationOptions() { tt__AudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (267)
/* tt:G711DecOptions */
class SOAP_CMAC tt__G711DecOptions : public xsd__anyType
{
public:
	tt__IntItems *Bitrate;	/* required element of type tt:IntItems */
	tt__IntItems *SampleRateRange;	/* required element of type tt:IntItems */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 267; } /* = unique type id SOAP_TYPE_tt__G711DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__G711DecOptions() { tt__G711DecOptions::soap_default(NULL); }
	virtual ~tt__G711DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (268)
/* tt:AACDecOptions */
class SOAP_CMAC tt__AACDecOptions : public xsd__anyType
{
public:
	tt__IntItems *Bitrate;	/* required element of type tt:IntItems */
	tt__IntItems *SampleRateRange;	/* required element of type tt:IntItems */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 268; } /* = unique type id SOAP_TYPE_tt__AACDecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AACDecOptions() { tt__AACDecOptions::soap_default(NULL); }
	virtual ~tt__AACDecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (269)
/* tt:G726DecOptions */
class SOAP_CMAC tt__G726DecOptions : public xsd__anyType
{
public:
	tt__IntItems *Bitrate;	/* required element of type tt:IntItems */
	tt__IntItems *SampleRateRange;	/* required element of type tt:IntItems */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 269; } /* = unique type id SOAP_TYPE_tt__G726DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__G726DecOptions() { tt__G726DecOptions::soap_default(NULL); }
	virtual ~tt__G726DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (270)
/* tt:AudioDecoderConfigurationOptionsExtension */
class SOAP_CMAC tt__AudioDecoderConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 270; } /* = unique type id SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioDecoderConfigurationOptionsExtension() { tt__AudioDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (271)
/* tt:MulticastConfiguration */
class SOAP_CMAC tt__MulticastConfiguration : public xsd__anyType
{
public:
	class tt__IPAddress *Address;	/* required element of type tt:IPAddress */
	int Port;	/* required element of type xsd:int */
	int TTL;	/* required element of type xsd:int */
	bool AutoStart;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 271; } /* = unique type id SOAP_TYPE_tt__MulticastConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MulticastConfiguration() { tt__MulticastConfiguration::soap_default(NULL); }
	virtual ~tt__MulticastConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (272)
/* tt:StreamSetup */
class SOAP_CMAC tt__StreamSetup : public xsd__anyType
{
public:
	enum tt__StreamType Stream;	/* required element of type tt:StreamType */
	class tt__Transport *Transport;	/* required element of type tt:Transport */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 272; } /* = unique type id SOAP_TYPE_tt__StreamSetup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__StreamSetup() { tt__StreamSetup::soap_default(NULL); }
	virtual ~tt__StreamSetup() { }
};
#endif

#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (273)
/* tt:Transport */
class SOAP_CMAC tt__Transport : public xsd__anyType
{
public:
	enum tt__TransportProtocol Protocol;	/* required element of type tt:TransportProtocol */
	tt__Transport *Tunnel;	/* optional element of type tt:Transport */
public:
	virtual int soap_type() const { return 273; } /* = unique type id SOAP_TYPE_tt__Transport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Transport() { tt__Transport::soap_default(NULL); }
	virtual ~tt__Transport() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (274)
/* tt:MediaUri */
class SOAP_CMAC tt__MediaUri : public xsd__anyType
{
public:
	std::string Uri;	/* required element of type xsd:anyURI */
	bool InvalidAfterConnect;	/* required element of type xsd:boolean */
	bool InvalidAfterReboot;	/* required element of type xsd:boolean */
	LONG64 Timeout;	/* external */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 274; } /* = unique type id SOAP_TYPE_tt__MediaUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaUri() { tt__MediaUri::soap_default(NULL); }
	virtual ~tt__MediaUri() { }
};
#endif

#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (275)
/* tt:Scope */
class SOAP_CMAC tt__Scope : public xsd__anyType
{
public:
	enum tt__ScopeDefinition ScopeDef;	/* required element of type tt:ScopeDefinition */
	std::string ScopeItem;	/* required element of type xsd:anyURI */
public:
	virtual int soap_type() const { return 275; } /* = unique type id SOAP_TYPE_tt__Scope */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Scope() { tt__Scope::soap_default(NULL); }
	virtual ~tt__Scope() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (277)
/* tt:NetworkInterfaceExtension */
class SOAP_CMAC tt__NetworkInterfaceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	int InterfaceType;	/* required element of type tt:IANA-IfTypes */
	std::vector<class tt__Dot3Configuration * >Dot3;	/* optional element of type tt:Dot3Configuration */
	std::vector<class tt__Dot11Configuration * >Dot11;	/* optional element of type tt:Dot11Configuration */
	class tt__NetworkInterfaceExtension2 *Extension;	/* optional element of type tt:NetworkInterfaceExtension2 */
public:
	virtual int soap_type() const { return 277; } /* = unique type id SOAP_TYPE_tt__NetworkInterfaceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceExtension() { tt__NetworkInterfaceExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (278)
/* tt:Dot3Configuration */
class SOAP_CMAC tt__Dot3Configuration : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 278; } /* = unique type id SOAP_TYPE_tt__Dot3Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot3Configuration() { tt__Dot3Configuration::soap_default(NULL); }
	virtual ~tt__Dot3Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (279)
/* tt:NetworkInterfaceExtension2 */
class SOAP_CMAC tt__NetworkInterfaceExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 279; } /* = unique type id SOAP_TYPE_tt__NetworkInterfaceExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceExtension2() { tt__NetworkInterfaceExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (280)
/* tt:NetworkInterfaceLink */
class SOAP_CMAC tt__NetworkInterfaceLink : public xsd__anyType
{
public:
	class tt__NetworkInterfaceConnectionSetting *AdminSettings;	/* required element of type tt:NetworkInterfaceConnectionSetting */
	tt__NetworkInterfaceConnectionSetting *OperSettings;	/* required element of type tt:NetworkInterfaceConnectionSetting */
	int InterfaceType;	/* required element of type tt:IANA-IfTypes */
public:
	virtual int soap_type() const { return 280; } /* = unique type id SOAP_TYPE_tt__NetworkInterfaceLink */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceLink() { tt__NetworkInterfaceLink::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceLink() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (281)
/* tt:NetworkInterfaceConnectionSetting */
class SOAP_CMAC tt__NetworkInterfaceConnectionSetting : public xsd__anyType
{
public:
	bool AutoNegotiation;	/* required element of type xsd:boolean */
	int Speed;	/* required element of type xsd:int */
	enum tt__Duplex Duplex;	/* required element of type tt:Duplex */
public:
	virtual int soap_type() const { return 281; } /* = unique type id SOAP_TYPE_tt__NetworkInterfaceConnectionSetting */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceConnectionSetting() { tt__NetworkInterfaceConnectionSetting::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConnectionSetting() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (282)
/* tt:NetworkInterfaceInfo */
class SOAP_CMAC tt__NetworkInterfaceInfo : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of type xsd:string */
	std::string HwAddress;	/* required element of type tt:HwAddress */
	int *MTU;	/* optional element of type xsd:int */
public:
	virtual int soap_type() const { return 282; } /* = unique type id SOAP_TYPE_tt__NetworkInterfaceInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceInfo() { tt__NetworkInterfaceInfo::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceInfo() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (283)
/* tt:IPv6NetworkInterface */
class SOAP_CMAC tt__IPv6NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	class tt__IPv6Configuration *Config;	/* optional element of type tt:IPv6Configuration */
public:
	virtual int soap_type() const { return 283; } /* = unique type id SOAP_TYPE_tt__IPv6NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6NetworkInterface() { tt__IPv6NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (284)
/* tt:IPv4NetworkInterface */
class SOAP_CMAC tt__IPv4NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	class tt__IPv4Configuration *Config;	/* required element of type tt:IPv4Configuration */
public:
	virtual int soap_type() const { return 284; } /* = unique type id SOAP_TYPE_tt__IPv4NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4NetworkInterface() { tt__IPv4NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (285)
/* tt:IPv4Configuration */
class SOAP_CMAC tt__IPv4Configuration : public xsd__anyType
{
public:
	std::vector<class tt__PrefixedIPv4Address * >Manual;	/* optional element of type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *LinkLocal;	/* optional element of type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *FromDHCP;	/* optional element of type tt:PrefixedIPv4Address */
	bool DHCP;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 285; } /* = unique type id SOAP_TYPE_tt__IPv4Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4Configuration() { tt__IPv4Configuration::soap_default(NULL); }
	virtual ~tt__IPv4Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (286)
/* tt:IPv6Configuration */
class SOAP_CMAC tt__IPv6Configuration : public xsd__anyType
{
public:
	bool *AcceptRouterAdvert;	/* optional element of type xsd:boolean */
	enum tt__IPv6DHCPConfiguration DHCP;	/* required element of type tt:IPv6DHCPConfiguration */
	std::vector<class tt__PrefixedIPv6Address * >Manual;	/* optional element of type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address * >LinkLocal;	/* optional element of type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address * >FromDHCP;	/* optional element of type tt:PrefixedIPv6Address */
	std::vector<tt__PrefixedIPv6Address * >FromRA;	/* optional element of type tt:PrefixedIPv6Address */
	class tt__IPv6ConfigurationExtension *Extension;	/* optional element of type tt:IPv6ConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 286; } /* = unique type id SOAP_TYPE_tt__IPv6Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6Configuration() { tt__IPv6Configuration::soap_default(NULL); }
	virtual ~tt__IPv6Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (287)
/* tt:IPv6ConfigurationExtension */
class SOAP_CMAC tt__IPv6ConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 287; } /* = unique type id SOAP_TYPE_tt__IPv6ConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6ConfigurationExtension() { tt__IPv6ConfigurationExtension::soap_default(NULL); }
	virtual ~tt__IPv6ConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (288)
/* tt:NetworkProtocol */
class SOAP_CMAC tt__NetworkProtocol : public xsd__anyType
{
public:
	enum tt__NetworkProtocolType Name;	/* required element of type tt:NetworkProtocolType */
	bool Enabled;	/* required element of type xsd:boolean */
	std::vector<int >Port;	/* required element of type xsd:int */
	class tt__NetworkProtocolExtension *Extension;	/* optional element of type tt:NetworkProtocolExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 288; } /* = unique type id SOAP_TYPE_tt__NetworkProtocol */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkProtocol() { tt__NetworkProtocol::soap_default(NULL); }
	virtual ~tt__NetworkProtocol() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (289)
/* tt:NetworkProtocolExtension */
class SOAP_CMAC tt__NetworkProtocolExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 289; } /* = unique type id SOAP_TYPE_tt__NetworkProtocolExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkProtocolExtension() { tt__NetworkProtocolExtension::soap_default(NULL); }
	virtual ~tt__NetworkProtocolExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (290)
/* tt:NetworkHost */
class SOAP_CMAC tt__NetworkHost : public xsd__anyType
{
public:
	enum tt__NetworkHostType Type;	/* required element of type tt:NetworkHostType */
	std::string *IPv4Address;	/* optional element of type tt:IPv4Address */
	std::string *IPv6Address;	/* optional element of type tt:IPv6Address */
	std::string *DNSname;	/* optional element of type tt:DNSName */
	class tt__NetworkHostExtension *Extension;	/* optional element of type tt:NetworkHostExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 290; } /* = unique type id SOAP_TYPE_tt__NetworkHost */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkHost() { tt__NetworkHost::soap_default(NULL); }
	virtual ~tt__NetworkHost() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (291)
/* tt:NetworkHostExtension */
class SOAP_CMAC tt__NetworkHostExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 291; } /* = unique type id SOAP_TYPE_tt__NetworkHostExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkHostExtension() { tt__NetworkHostExtension::soap_default(NULL); }
	virtual ~tt__NetworkHostExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (292)
/* tt:IPAddress */
class SOAP_CMAC tt__IPAddress : public xsd__anyType
{
public:
	enum tt__IPType Type;	/* required element of type tt:IPType */
	std::string *IPv4Address;	/* optional element of type tt:IPv4Address */
	std::string *IPv6Address;	/* optional element of type tt:IPv6Address */
public:
	virtual int soap_type() const { return 292; } /* = unique type id SOAP_TYPE_tt__IPAddress */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddress() { tt__IPAddress::soap_default(NULL); }
	virtual ~tt__IPAddress() { }
};
#endif

#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (293)
/* tt:PrefixedIPv4Address */
class SOAP_CMAC tt__PrefixedIPv4Address : public xsd__anyType
{
public:
	std::string Address;	/* required element of type tt:IPv4Address */
	int PrefixLength;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 293; } /* = unique type id SOAP_TYPE_tt__PrefixedIPv4Address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PrefixedIPv4Address() { tt__PrefixedIPv4Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv4Address() { }
};
#endif

#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (294)
/* tt:PrefixedIPv6Address */
class SOAP_CMAC tt__PrefixedIPv6Address : public xsd__anyType
{
public:
	std::string Address;	/* required element of type tt:IPv6Address */
	int PrefixLength;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 294; } /* = unique type id SOAP_TYPE_tt__PrefixedIPv6Address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PrefixedIPv6Address() { tt__PrefixedIPv6Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv6Address() { }
};
#endif

#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (295)
/* tt:HostnameInformation */
class SOAP_CMAC tt__HostnameInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::string *Name;	/* optional element of type xsd:token */
	class tt__HostnameInformationExtension *Extension;	/* optional element of type tt:HostnameInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 295; } /* = unique type id SOAP_TYPE_tt__HostnameInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__HostnameInformation() { tt__HostnameInformation::soap_default(NULL); }
	virtual ~tt__HostnameInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (296)
/* tt:HostnameInformationExtension */
class SOAP_CMAC tt__HostnameInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 296; } /* = unique type id SOAP_TYPE_tt__HostnameInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__HostnameInformationExtension() { tt__HostnameInformationExtension::soap_default(NULL); }
	virtual ~tt__HostnameInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (297)
/* tt:DNSInformation */
class SOAP_CMAC tt__DNSInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::vector<std::string >SearchDomain;	/* optional element of type xsd:token */
	std::vector<tt__IPAddress * >DNSFromDHCP;	/* optional element of type tt:IPAddress */
	std::vector<tt__IPAddress * >DNSManual;	/* optional element of type tt:IPAddress */
	class tt__DNSInformationExtension *Extension;	/* optional element of type tt:DNSInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 297; } /* = unique type id SOAP_TYPE_tt__DNSInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DNSInformation() { tt__DNSInformation::soap_default(NULL); }
	virtual ~tt__DNSInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (298)
/* tt:DNSInformationExtension */
class SOAP_CMAC tt__DNSInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 298; } /* = unique type id SOAP_TYPE_tt__DNSInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DNSInformationExtension() { tt__DNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DNSInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (299)
/* tt:NTPInformation */
class SOAP_CMAC tt__NTPInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::vector<tt__NetworkHost * >NTPFromDHCP;	/* optional element of type tt:NetworkHost */
	std::vector<tt__NetworkHost * >NTPManual;	/* optional element of type tt:NetworkHost */
	class tt__NTPInformationExtension *Extension;	/* optional element of type tt:NTPInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 299; } /* = unique type id SOAP_TYPE_tt__NTPInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NTPInformation() { tt__NTPInformation::soap_default(NULL); }
	virtual ~tt__NTPInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (300)
/* tt:NTPInformationExtension */
class SOAP_CMAC tt__NTPInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 300; } /* = unique type id SOAP_TYPE_tt__NTPInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NTPInformationExtension() { tt__NTPInformationExtension::soap_default(NULL); }
	virtual ~tt__NTPInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (301)
/* tt:DynamicDNSInformation */
class SOAP_CMAC tt__DynamicDNSInformation : public xsd__anyType
{
public:
	enum tt__DynamicDNSType Type;	/* required element of type tt:DynamicDNSType */
	std::string *Name;	/* optional element of type tt:DNSName */
	LONG64 *TTL;	/* optional element of type xsd:duration */
	class tt__DynamicDNSInformationExtension *Extension;	/* optional element of type tt:DynamicDNSInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 301; } /* = unique type id SOAP_TYPE_tt__DynamicDNSInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DynamicDNSInformation() { tt__DynamicDNSInformation::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (302)
/* tt:DynamicDNSInformationExtension */
class SOAP_CMAC tt__DynamicDNSInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 302; } /* = unique type id SOAP_TYPE_tt__DynamicDNSInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DynamicDNSInformationExtension() { tt__DynamicDNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (303)
/* tt:NetworkInterfaceSetConfiguration */
class SOAP_CMAC tt__NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	tt__NetworkInterfaceConnectionSetting *Link;	/* optional element of type tt:NetworkInterfaceConnectionSetting */
	int *MTU;	/* optional element of type xsd:int */
	class tt__IPv4NetworkInterfaceSetConfiguration *IPv4;	/* optional element of type tt:IPv4NetworkInterfaceSetConfiguration */
	class tt__IPv6NetworkInterfaceSetConfiguration *IPv6;	/* optional element of type tt:IPv6NetworkInterfaceSetConfiguration */
	class tt__NetworkInterfaceSetConfigurationExtension *Extension;	/* optional element of type tt:NetworkInterfaceSetConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 303; } /* = unique type id SOAP_TYPE_tt__NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceSetConfiguration() { tt__NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (304)
/* tt:NetworkInterfaceSetConfigurationExtension */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	std::vector<tt__Dot3Configuration * >Dot3;	/* optional element of type tt:Dot3Configuration */
	std::vector<tt__Dot11Configuration * >Dot11;	/* optional element of type tt:Dot11Configuration */
	class tt__NetworkInterfaceSetConfigurationExtension2 *Extension;	/* optional element of type tt:NetworkInterfaceSetConfigurationExtension2 */
public:
	virtual int soap_type() const { return 304; } /* = unique type id SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceSetConfigurationExtension() { tt__NetworkInterfaceSetConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (305)
/* tt:IPv6NetworkInterfaceSetConfiguration */
class SOAP_CMAC tt__IPv6NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	bool *AcceptRouterAdvert;	/* optional element of type xsd:boolean */
	std::vector<tt__PrefixedIPv6Address * >Manual;	/* optional element of type tt:PrefixedIPv6Address */
	enum tt__IPv6DHCPConfiguration *DHCP;	/* optional element of type tt:IPv6DHCPConfiguration */
public:
	virtual int soap_type() const { return 305; } /* = unique type id SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6NetworkInterfaceSetConfiguration() { tt__IPv6NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (306)
/* tt:IPv4NetworkInterfaceSetConfiguration */
class SOAP_CMAC tt__IPv4NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	std::vector<tt__PrefixedIPv4Address * >Manual;	/* optional element of type tt:PrefixedIPv4Address */
	bool *DHCP;	/* optional element of type xsd:boolean */
public:
	virtual int soap_type() const { return 306; } /* = unique type id SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4NetworkInterfaceSetConfiguration() { tt__IPv4NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (307)
/* tt:NetworkGateway */
class SOAP_CMAC tt__NetworkGateway : public xsd__anyType
{
public:
	std::vector<std::string >IPv4Address;	/* optional element of type tt:IPv4Address */
	std::vector<std::string >IPv6Address;	/* optional element of type tt:IPv6Address */
public:
	virtual int soap_type() const { return 307; } /* = unique type id SOAP_TYPE_tt__NetworkGateway */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkGateway() { tt__NetworkGateway::soap_default(NULL); }
	virtual ~tt__NetworkGateway() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (308)
/* tt:NetworkZeroConfiguration */
class SOAP_CMAC tt__NetworkZeroConfiguration : public xsd__anyType
{
public:
	std::string InterfaceToken;	/* required element of type tt:ReferenceToken */
	bool Enabled;	/* required element of type xsd:boolean */
	std::vector<std::string >Addresses;	/* optional element of type tt:IPv4Address */
	class tt__NetworkZeroConfigurationExtension *Extension;	/* optional element of type tt:NetworkZeroConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 308; } /* = unique type id SOAP_TYPE_tt__NetworkZeroConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkZeroConfiguration() { tt__NetworkZeroConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (309)
/* tt:NetworkZeroConfigurationExtension */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	std::vector<tt__NetworkZeroConfiguration * >Additional;	/* optional element of type tt:NetworkZeroConfiguration */
	class tt__NetworkZeroConfigurationExtension2 *Extension;	/* optional element of type tt:NetworkZeroConfigurationExtension2 */
public:
	virtual int soap_type() const { return 309; } /* = unique type id SOAP_TYPE_tt__NetworkZeroConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkZeroConfigurationExtension() { tt__NetworkZeroConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (310)
/* tt:NetworkZeroConfigurationExtension2 */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 310; } /* = unique type id SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkZeroConfigurationExtension2() { tt__NetworkZeroConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (311)
/* tt:IPAddressFilter */
class SOAP_CMAC tt__IPAddressFilter : public xsd__anyType
{
public:
	enum tt__IPAddressFilterType Type;	/* required element of type tt:IPAddressFilterType */
	std::vector<tt__PrefixedIPv4Address * >IPv4Address;	/* optional element of type tt:PrefixedIPv4Address */
	std::vector<tt__PrefixedIPv6Address * >IPv6Address;	/* optional element of type tt:PrefixedIPv6Address */
	class tt__IPAddressFilterExtension *Extension;	/* optional element of type tt:IPAddressFilterExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 311; } /* = unique type id SOAP_TYPE_tt__IPAddressFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddressFilter() { tt__IPAddressFilter::soap_default(NULL); }
	virtual ~tt__IPAddressFilter() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (312)
/* tt:IPAddressFilterExtension */
class SOAP_CMAC tt__IPAddressFilterExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 312; } /* = unique type id SOAP_TYPE_tt__IPAddressFilterExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddressFilterExtension() { tt__IPAddressFilterExtension::soap_default(NULL); }
	virtual ~tt__IPAddressFilterExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (313)
/* tt:Dot11Configuration */
class SOAP_CMAC tt__Dot11Configuration : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of type tt:Dot11SSIDType */
	enum tt__Dot11StationMode Mode;	/* required element of type tt:Dot11StationMode */
	std::string Alias;	/* required element of type tt:Name */
	std::string Priority;	/* required element of type tt:NetworkInterfaceConfigPriority */
	class tt__Dot11SecurityConfiguration *Security;	/* required element of type tt:Dot11SecurityConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 313; } /* = unique type id SOAP_TYPE_tt__Dot11Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11Configuration() { tt__Dot11Configuration::soap_default(NULL); }
	virtual ~tt__Dot11Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (314)
/* tt:Dot11SecurityConfiguration */
class SOAP_CMAC tt__Dot11SecurityConfiguration : public xsd__anyType
{
public:
	enum tt__Dot11SecurityMode Mode;	/* required element of type tt:Dot11SecurityMode */
	enum tt__Dot11Cipher *Algorithm;	/* optional element of type tt:Dot11Cipher */
	class tt__Dot11PSKSet *PSK;	/* optional element of type tt:Dot11PSKSet */
	std::string *Dot1X;	/* optional element of type tt:ReferenceToken */
	class tt__Dot11SecurityConfigurationExtension *Extension;	/* optional element of type tt:Dot11SecurityConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 314; } /* = unique type id SOAP_TYPE_tt__Dot11SecurityConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11SecurityConfiguration() { tt__Dot11SecurityConfiguration::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (315)
/* tt:Dot11SecurityConfigurationExtension */
class SOAP_CMAC tt__Dot11SecurityConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 315; } /* = unique type id SOAP_TYPE_tt__Dot11SecurityConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11SecurityConfigurationExtension() { tt__Dot11SecurityConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (316)
/* tt:Dot11PSKSet */
class SOAP_CMAC tt__Dot11PSKSet : public xsd__anyType
{
public:
	xsd__hexBinary *Key;	/* optional element of type tt:Dot11PSK */
	std::string *Passphrase;	/* optional element of type tt:Dot11PSKPassphrase */
	class tt__Dot11PSKSetExtension *Extension;	/* optional element of type tt:Dot11PSKSetExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 316; } /* = unique type id SOAP_TYPE_tt__Dot11PSKSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11PSKSet() { tt__Dot11PSKSet::soap_default(NULL); }
	virtual ~tt__Dot11PSKSet() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (317)
/* tt:Dot11PSKSetExtension */
class SOAP_CMAC tt__Dot11PSKSetExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 317; } /* = unique type id SOAP_TYPE_tt__Dot11PSKSetExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11PSKSetExtension() { tt__Dot11PSKSetExtension::soap_default(NULL); }
	virtual ~tt__Dot11PSKSetExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (318)
/* tt:NetworkInterfaceSetConfigurationExtension2 */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 318; } /* = unique type id SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceSetConfigurationExtension2() { tt__NetworkInterfaceSetConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (319)
/* tt:Dot11Capabilities */
class SOAP_CMAC tt__Dot11Capabilities : public xsd__anyType
{
public:
	bool TKIP;	/* required element of type xsd:boolean */
	bool ScanAvailableNetworks;	/* required element of type xsd:boolean */
	bool MultipleConfiguration;	/* required element of type xsd:boolean */
	bool AdHocStationMode;	/* required element of type xsd:boolean */
	bool WEP;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 319; } /* = unique type id SOAP_TYPE_tt__Dot11Capabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11Capabilities() { tt__Dot11Capabilities::soap_default(NULL); }
	virtual ~tt__Dot11Capabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (320)
/* tt:Dot11Status */
class SOAP_CMAC tt__Dot11Status : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of type tt:Dot11SSIDType */
	std::string *BSSID;	/* optional element of type xsd:string */
	enum tt__Dot11Cipher *PairCipher;	/* optional element of type tt:Dot11Cipher */
	enum tt__Dot11Cipher *GroupCipher;	/* optional element of type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of type tt:Dot11SignalStrength */
	std::string ActiveConfigAlias;	/* required element of type tt:ReferenceToken */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 320; } /* = unique type id SOAP_TYPE_tt__Dot11Status */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11Status() { tt__Dot11Status::soap_default(NULL); }
	virtual ~tt__Dot11Status() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (321)
/* tt:Dot11AvailableNetworks */
class SOAP_CMAC tt__Dot11AvailableNetworks : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of type tt:Dot11SSIDType */
	std::string *BSSID;	/* optional element of type xsd:string */
	std::vector<enum tt__Dot11AuthAndMangementSuite >AuthAndMangementSuite;	/* optional element of type tt:Dot11AuthAndMangementSuite */
	std::vector<enum tt__Dot11Cipher >PairCipher;	/* optional element of type tt:Dot11Cipher */
	std::vector<enum tt__Dot11Cipher >GroupCipher;	/* optional element of type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of type tt:Dot11SignalStrength */
	class tt__Dot11AvailableNetworksExtension *Extension;	/* optional element of type tt:Dot11AvailableNetworksExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 321; } /* = unique type id SOAP_TYPE_tt__Dot11AvailableNetworks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11AvailableNetworks() { tt__Dot11AvailableNetworks::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworks() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (322)
/* tt:Dot11AvailableNetworksExtension */
class SOAP_CMAC tt__Dot11AvailableNetworksExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 322; } /* = unique type id SOAP_TYPE_tt__Dot11AvailableNetworksExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11AvailableNetworksExtension() { tt__Dot11AvailableNetworksExtension::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworksExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (323)
/* tt:Capabilities */
class SOAP_CMAC tt__Capabilities : public xsd__anyType
{
public:
	class tt__AnalyticsCapabilities *Analytics;	/* optional element of type tt:AnalyticsCapabilities */
	class tt__DeviceCapabilities *Device;	/* optional element of type tt:DeviceCapabilities */
	class tt__EventCapabilities *Events;	/* optional element of type tt:EventCapabilities */
	class tt__ImagingCapabilities *Imaging;	/* optional element of type tt:ImagingCapabilities */
	class tt__MediaCapabilities *Media;	/* optional element of type tt:MediaCapabilities */
	class tt__PTZCapabilities *PTZ;	/* optional element of type tt:PTZCapabilities */
	class tt__CapabilitiesExtension *Extension;	/* optional element of type tt:CapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 323; } /* = unique type id SOAP_TYPE_tt__Capabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Capabilities() { tt__Capabilities::soap_default(NULL); }
	virtual ~tt__Capabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (324)
/* tt:CapabilitiesExtension */
class SOAP_CMAC tt__CapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class tt__DeviceIOCapabilities *DeviceIO;	/* optional element of type tt:DeviceIOCapabilities */
	class tt__DisplayCapabilities *Display;	/* optional element of type tt:DisplayCapabilities */
	class tt__RecordingCapabilities *Recording;	/* optional element of type tt:RecordingCapabilities */
	class tt__SearchCapabilities *Search;	/* optional element of type tt:SearchCapabilities */
	class tt__ReplayCapabilities *Replay;	/* optional element of type tt:ReplayCapabilities */
	class tt__ReceiverCapabilities *Receiver;	/* optional element of type tt:ReceiverCapabilities */
	class tt__AnalyticsDeviceCapabilities *AnalyticsDevice;	/* optional element of type tt:AnalyticsDeviceCapabilities */
	class tt__CapabilitiesExtension2 *Extensions;	/* optional element of type tt:CapabilitiesExtension2 */
public:
	virtual int soap_type() const { return 324; } /* = unique type id SOAP_TYPE_tt__CapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CapabilitiesExtension() { tt__CapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (325)
/* tt:CapabilitiesExtension2 */
class SOAP_CMAC tt__CapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 325; } /* = unique type id SOAP_TYPE_tt__CapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CapabilitiesExtension2() { tt__CapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (326)
/* tt:AnalyticsCapabilities */
class SOAP_CMAC tt__AnalyticsCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool RuleSupport;	/* required element of type xsd:boolean */
	bool AnalyticsModuleSupport;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 326; } /* = unique type id SOAP_TYPE_tt__AnalyticsCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsCapabilities() { tt__AnalyticsCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (327)
/* tt:DeviceCapabilities */
class SOAP_CMAC tt__DeviceCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	class tt__NetworkCapabilities *Network;	/* optional element of type tt:NetworkCapabilities */
	class tt__SystemCapabilities *System;	/* optional element of type tt:SystemCapabilities */
	class tt__IOCapabilities *IO;	/* optional element of type tt:IOCapabilities */
	class tt__SecurityCapabilities *Security;	/* optional element of type tt:SecurityCapabilities */
	class tt__DeviceCapabilitiesExtension *Extension;	/* optional element of type tt:DeviceCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 327; } /* = unique type id SOAP_TYPE_tt__DeviceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceCapabilities() { tt__DeviceCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (328)
/* tt:DeviceCapabilitiesExtension */
class SOAP_CMAC tt__DeviceCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 328; } /* = unique type id SOAP_TYPE_tt__DeviceCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceCapabilitiesExtension() { tt__DeviceCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__DeviceCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (329)
/* tt:EventCapabilities */
class SOAP_CMAC tt__EventCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool WSSubscriptionPolicySupport;	/* required element of type xsd:boolean */
	bool WSPullPointSupport;	/* required element of type xsd:boolean */
	bool WSPausableSubscriptionManagerInterfaceSupport;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 329; } /* = unique type id SOAP_TYPE_tt__EventCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventCapabilities() { tt__EventCapabilities::soap_default(NULL); }
	virtual ~tt__EventCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (330)
/* tt:IOCapabilities */
class SOAP_CMAC tt__IOCapabilities : public xsd__anyType
{
public:
	int *InputConnectors;	/* optional element of type xsd:int */
	int *RelayOutputs;	/* optional element of type xsd:int */
	class tt__IOCapabilitiesExtension *Extension;	/* optional element of type tt:IOCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 330; } /* = unique type id SOAP_TYPE_tt__IOCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IOCapabilities() { tt__IOCapabilities::soap_default(NULL); }
	virtual ~tt__IOCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (331)
/* tt:IOCapabilitiesExtension */
class SOAP_CMAC tt__IOCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	bool *Auxiliary;	/* optional element of type xsd:boolean */
	std::vector<std::string >AuxiliaryCommands;	/* optional element of type tt:AuxiliaryData */
	class tt__IOCapabilitiesExtension2 *Extension;	/* required element of type tt:IOCapabilitiesExtension2 */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 331; } /* = unique type id SOAP_TYPE_tt__IOCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IOCapabilitiesExtension() { tt__IOCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (332)
/* tt:IOCapabilitiesExtension2 */
class SOAP_CMAC tt__IOCapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 332; } /* = unique type id SOAP_TYPE_tt__IOCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IOCapabilitiesExtension2() { tt__IOCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (333)
/* tt:MediaCapabilities */
class SOAP_CMAC tt__MediaCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	class tt__RealTimeStreamingCapabilities *StreamingCapabilities;	/* required element of type tt:RealTimeStreamingCapabilities */
	std::vector<char * >__any;
	class tt__MediaCapabilitiesExtension *Extension;	/* optional element of type tt:MediaCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 333; } /* = unique type id SOAP_TYPE_tt__MediaCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaCapabilities() { tt__MediaCapabilities::soap_default(NULL); }
	virtual ~tt__MediaCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (334)
/* tt:MediaCapabilitiesExtension */
class SOAP_CMAC tt__MediaCapabilitiesExtension : public xsd__anyType
{
public:
	class tt__ProfileCapabilities *ProfileCapabilities;	/* required element of type tt:ProfileCapabilities */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 334; } /* = unique type id SOAP_TYPE_tt__MediaCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaCapabilitiesExtension() { tt__MediaCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__MediaCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (335)
/* tt:RealTimeStreamingCapabilities */
class SOAP_CMAC tt__RealTimeStreamingCapabilities : public xsd__anyType
{
public:
	bool *RTPMulticast;	/* optional element of type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional element of type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional element of type xsd:boolean */
	class tt__RealTimeStreamingCapabilitiesExtension *Extension;	/* optional element of type tt:RealTimeStreamingCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 335; } /* = unique type id SOAP_TYPE_tt__RealTimeStreamingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RealTimeStreamingCapabilities() { tt__RealTimeStreamingCapabilities::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (336)
/* tt:RealTimeStreamingCapabilitiesExtension */
class SOAP_CMAC tt__RealTimeStreamingCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 336; } /* = unique type id SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RealTimeStreamingCapabilitiesExtension() { tt__RealTimeStreamingCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (337)
/* tt:ProfileCapabilities */
class SOAP_CMAC tt__ProfileCapabilities : public xsd__anyType
{
public:
	int MaximumNumberOfProfiles;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 337; } /* = unique type id SOAP_TYPE_tt__ProfileCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileCapabilities() { tt__ProfileCapabilities::soap_default(NULL); }
	virtual ~tt__ProfileCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (338)
/* tt:NetworkCapabilities */
class SOAP_CMAC tt__NetworkCapabilities : public xsd__anyType
{
public:
	bool *IPFilter;	/* optional element of type xsd:boolean */
	bool *ZeroConfiguration;	/* optional element of type xsd:boolean */
	bool *IPVersion6;	/* optional element of type xsd:boolean */
	bool *DynDNS;	/* optional element of type xsd:boolean */
	class tt__NetworkCapabilitiesExtension *Extension;	/* optional element of type tt:NetworkCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 338; } /* = unique type id SOAP_TYPE_tt__NetworkCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkCapabilities() { tt__NetworkCapabilities::soap_default(NULL); }
	virtual ~tt__NetworkCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (339)
/* tt:NetworkCapabilitiesExtension */
class SOAP_CMAC tt__NetworkCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	bool *Dot11Configuration;	/* optional element of type xsd:boolean */
	class tt__NetworkCapabilitiesExtension2 *Extension;	/* optional element of type tt:NetworkCapabilitiesExtension2 */
public:
	virtual int soap_type() const { return 339; } /* = unique type id SOAP_TYPE_tt__NetworkCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkCapabilitiesExtension() { tt__NetworkCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (340)
/* tt:NetworkCapabilitiesExtension2 */
class SOAP_CMAC tt__NetworkCapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 340; } /* = unique type id SOAP_TYPE_tt__NetworkCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkCapabilitiesExtension2() { tt__NetworkCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (341)
/* tt:SecurityCapabilities */
class SOAP_CMAC tt__SecurityCapabilities : public xsd__anyType
{
public:
	bool TLS1_x002e1;	/* required element of type xsd:boolean */
	bool TLS1_x002e2;	/* required element of type xsd:boolean */
	bool OnboardKeyGeneration;	/* required element of type xsd:boolean */
	bool AccessPolicyConfig;	/* required element of type xsd:boolean */
	bool X_x002e509Token;	/* required element of type xsd:boolean */
	bool SAMLToken;	/* required element of type xsd:boolean */
	bool KerberosToken;	/* required element of type xsd:boolean */
	bool RELToken;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	class tt__SecurityCapabilitiesExtension *Extension;	/* optional element of type tt:SecurityCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 341; } /* = unique type id SOAP_TYPE_tt__SecurityCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SecurityCapabilities() { tt__SecurityCapabilities::soap_default(NULL); }
	virtual ~tt__SecurityCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (342)
/* tt:SecurityCapabilitiesExtension */
class SOAP_CMAC tt__SecurityCapabilitiesExtension : public xsd__anyType
{
public:
	bool TLS1_x002e0;	/* required element of type xsd:boolean */
	class tt__SecurityCapabilitiesExtension2 *Extension;	/* optional element of type tt:SecurityCapabilitiesExtension2 */
public:
	virtual int soap_type() const { return 342; } /* = unique type id SOAP_TYPE_tt__SecurityCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SecurityCapabilitiesExtension() { tt__SecurityCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (343)
/* tt:SecurityCapabilitiesExtension2 */
class SOAP_CMAC tt__SecurityCapabilitiesExtension2 : public xsd__anyType
{
public:
	bool Dot1X;	/* required element of type xsd:boolean */
	std::vector<int >SupportedEAPMethod;	/* optional element of type xsd:int */
	bool RemoteUserHandling;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 343; } /* = unique type id SOAP_TYPE_tt__SecurityCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SecurityCapabilitiesExtension2() { tt__SecurityCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (344)
/* tt:SystemCapabilities */
class SOAP_CMAC tt__SystemCapabilities : public xsd__anyType
{
public:
	bool DiscoveryResolve;	/* required element of type xsd:boolean */
	bool DiscoveryBye;	/* required element of type xsd:boolean */
	bool RemoteDiscovery;	/* required element of type xsd:boolean */
	bool SystemBackup;	/* required element of type xsd:boolean */
	bool SystemLogging;	/* required element of type xsd:boolean */
	bool FirmwareUpgrade;	/* required element of type xsd:boolean */
	std::vector<class tt__OnvifVersion * >SupportedVersions;	/* required element of type tt:OnvifVersion */
	class tt__SystemCapabilitiesExtension *Extension;	/* optional element of type tt:SystemCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 344; } /* = unique type id SOAP_TYPE_tt__SystemCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemCapabilities() { tt__SystemCapabilities::soap_default(NULL); }
	virtual ~tt__SystemCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (345)
/* tt:SystemCapabilitiesExtension */
class SOAP_CMAC tt__SystemCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	bool *HttpFirmwareUpgrade;	/* optional element of type xsd:boolean */
	bool *HttpSystemBackup;	/* optional element of type xsd:boolean */
	bool *HttpSystemLogging;	/* optional element of type xsd:boolean */
	bool *HttpSupportInformation;	/* optional element of type xsd:boolean */
	class tt__SystemCapabilitiesExtension2 *Extension;	/* optional element of type tt:SystemCapabilitiesExtension2 */
public:
	virtual int soap_type() const { return 345; } /* = unique type id SOAP_TYPE_tt__SystemCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemCapabilitiesExtension() { tt__SystemCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (346)
/* tt:SystemCapabilitiesExtension2 */
class SOAP_CMAC tt__SystemCapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 346; } /* = unique type id SOAP_TYPE_tt__SystemCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemCapabilitiesExtension2() { tt__SystemCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (347)
/* tt:OnvifVersion */
class SOAP_CMAC tt__OnvifVersion : public xsd__anyType
{
public:
	int Major;	/* required element of type xsd:int */
	int Minor;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 347; } /* = unique type id SOAP_TYPE_tt__OnvifVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OnvifVersion() { tt__OnvifVersion::soap_default(NULL); }
	virtual ~tt__OnvifVersion() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (348)
/* tt:ImagingCapabilities */
class SOAP_CMAC tt__ImagingCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 348; } /* = unique type id SOAP_TYPE_tt__ImagingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingCapabilities() { tt__ImagingCapabilities::soap_default(NULL); }
	virtual ~tt__ImagingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (349)
/* tt:PTZCapabilities */
class SOAP_CMAC tt__PTZCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 349; } /* = unique type id SOAP_TYPE_tt__PTZCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZCapabilities() { tt__PTZCapabilities::soap_default(NULL); }
	virtual ~tt__PTZCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (350)
/* tt:DeviceIOCapabilities */
class SOAP_CMAC tt__DeviceIOCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	int VideoSources;	/* required element of type xsd:int */
	int VideoOutputs;	/* required element of type xsd:int */
	int AudioSources;	/* required element of type xsd:int */
	int AudioOutputs;	/* required element of type xsd:int */
	int RelayOutputs;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 350; } /* = unique type id SOAP_TYPE_tt__DeviceIOCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceIOCapabilities() { tt__DeviceIOCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceIOCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (351)
/* tt:DisplayCapabilities */
class SOAP_CMAC tt__DisplayCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool FixedLayout;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 351; } /* = unique type id SOAP_TYPE_tt__DisplayCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DisplayCapabilities() { tt__DisplayCapabilities::soap_default(NULL); }
	virtual ~tt__DisplayCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (352)
/* tt:RecordingCapabilities */
class SOAP_CMAC tt__RecordingCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool ReceiverSource;	/* required element of type xsd:boolean */
	bool MediaProfileSource;	/* required element of type xsd:boolean */
	bool DynamicRecordings;	/* required element of type xsd:boolean */
	bool DynamicTracks;	/* required element of type xsd:boolean */
	int MaxStringLength;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 352; } /* = unique type id SOAP_TYPE_tt__RecordingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingCapabilities() { tt__RecordingCapabilities::soap_default(NULL); }
	virtual ~tt__RecordingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (353)
/* tt:SearchCapabilities */
class SOAP_CMAC tt__SearchCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool MetadataSearch;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 353; } /* = unique type id SOAP_TYPE_tt__SearchCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SearchCapabilities() { tt__SearchCapabilities::soap_default(NULL); }
	virtual ~tt__SearchCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (354)
/* tt:ReplayCapabilities */
class SOAP_CMAC tt__ReplayCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 354; } /* = unique type id SOAP_TYPE_tt__ReplayCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReplayCapabilities() { tt__ReplayCapabilities::soap_default(NULL); }
	virtual ~tt__ReplayCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (355)
/* tt:ReceiverCapabilities */
class SOAP_CMAC tt__ReceiverCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool RTP_USCOREMulticast;	/* required element of type xsd:boolean */
	bool RTP_USCORETCP;	/* required element of type xsd:boolean */
	bool RTP_USCORERTSP_USCORETCP;	/* required element of type xsd:boolean */
	int SupportedReceivers;	/* required element of type xsd:int */
	int MaximumRTSPURILength;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 355; } /* = unique type id SOAP_TYPE_tt__ReceiverCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReceiverCapabilities() { tt__ReceiverCapabilities::soap_default(NULL); }
	virtual ~tt__ReceiverCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (356)
/* tt:AnalyticsDeviceCapabilities */
class SOAP_CMAC tt__AnalyticsDeviceCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool *RuleSupport;	/* optional element of type xsd:boolean */
	class tt__AnalyticsDeviceExtension *Extension;	/* optional element of type tt:AnalyticsDeviceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 356; } /* = unique type id SOAP_TYPE_tt__AnalyticsDeviceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsDeviceCapabilities() { tt__AnalyticsDeviceCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (357)
/* tt:AnalyticsDeviceExtension */
class SOAP_CMAC tt__AnalyticsDeviceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 357; } /* = unique type id SOAP_TYPE_tt__AnalyticsDeviceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsDeviceExtension() { tt__AnalyticsDeviceExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (358)
/* tt:SystemLog */
class SOAP_CMAC tt__SystemLog : public xsd__anyType
{
public:
	class tt__AttachmentData *Binary;	/* optional element of type tt:AttachmentData */
	std::string *String;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 358; } /* = unique type id SOAP_TYPE_tt__SystemLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemLog() { tt__SystemLog::soap_default(NULL); }
	virtual ~tt__SystemLog() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (359)
/* tt:SupportInformation */
class SOAP_CMAC tt__SupportInformation : public xsd__anyType
{
public:
	tt__AttachmentData *Binary;	/* optional element of type tt:AttachmentData */
	std::string *String;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 359; } /* = unique type id SOAP_TYPE_tt__SupportInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportInformation() { tt__SupportInformation::soap_default(NULL); }
	virtual ~tt__SupportInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (360)
/* tt:BinaryData */
class SOAP_CMAC tt__BinaryData : public xsd__anyType
{
public:
	xsd__base64Binary Data;	/* required element of type xsd:base64Binary */
	char *xmime__contentType;	/* optional attribute */
public:
	virtual int soap_type() const { return 360; } /* = unique type id SOAP_TYPE_tt__BinaryData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BinaryData() { tt__BinaryData::soap_default(NULL); }
	virtual ~tt__BinaryData() { }
};
#endif

#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (361)
/* tt:AttachmentData */
class SOAP_CMAC tt__AttachmentData : public xsd__anyType
{
public:
	struct _xop__Include xop__Include;	/* required element of type xop:Include */
	char *xmime__contentType;	/* optional attribute */
public:
	virtual int soap_type() const { return 361; } /* = unique type id SOAP_TYPE_tt__AttachmentData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AttachmentData() { tt__AttachmentData::soap_default(NULL); }
	virtual ~tt__AttachmentData() { }
};
#endif

#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (362)
/* tt:BackupFile */
class SOAP_CMAC tt__BackupFile : public xsd__anyType
{
public:
	std::string Name;	/* required element of type xsd:string */
	tt__AttachmentData *Data;	/* required element of type tt:AttachmentData */
public:
	virtual int soap_type() const { return 362; } /* = unique type id SOAP_TYPE_tt__BackupFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BackupFile() { tt__BackupFile::soap_default(NULL); }
	virtual ~tt__BackupFile() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (363)
/* tt:SystemLogUriList */
class SOAP_CMAC tt__SystemLogUriList : public xsd__anyType
{
public:
	std::vector<class tt__SystemLogUri * >SystemLog;	/* optional element of type tt:SystemLogUri */
public:
	virtual int soap_type() const { return 363; } /* = unique type id SOAP_TYPE_tt__SystemLogUriList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemLogUriList() { tt__SystemLogUriList::soap_default(NULL); }
	virtual ~tt__SystemLogUriList() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (364)
/* tt:SystemLogUri */
class SOAP_CMAC tt__SystemLogUri : public xsd__anyType
{
public:
	enum tt__SystemLogType Type;	/* required element of type tt:SystemLogType */
	std::string Uri;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 364; } /* = unique type id SOAP_TYPE_tt__SystemLogUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemLogUri() { tt__SystemLogUri::soap_default(NULL); }
	virtual ~tt__SystemLogUri() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (365)
/* tt:SystemDateTime */
class SOAP_CMAC tt__SystemDateTime : public xsd__anyType
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of type xsd:boolean */
	class tt__TimeZone *TimeZone;	/* optional element of type tt:TimeZone */
	class tt__DateTime *UTCDateTime;	/* optional element of type tt:DateTime */
	tt__DateTime *LocalDateTime;	/* optional element of type tt:DateTime */
	class tt__SystemDateTimeExtension *Extension;	/* optional element of type tt:SystemDateTimeExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 365; } /* = unique type id SOAP_TYPE_tt__SystemDateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemDateTime() { tt__SystemDateTime::soap_default(NULL); }
	virtual ~tt__SystemDateTime() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (366)
/* tt:SystemDateTimeExtension */
class SOAP_CMAC tt__SystemDateTimeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 366; } /* = unique type id SOAP_TYPE_tt__SystemDateTimeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemDateTimeExtension() { tt__SystemDateTimeExtension::soap_default(NULL); }
	virtual ~tt__SystemDateTimeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (367)
/* tt:DateTime */
class SOAP_CMAC tt__DateTime : public xsd__anyType
{
public:
	class tt__Time *Time;	/* required element of type tt:Time */
	class tt__Date *Date;	/* required element of type tt:Date */
public:
	virtual int soap_type() const { return 367; } /* = unique type id SOAP_TYPE_tt__DateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DateTime() { tt__DateTime::soap_default(NULL); }
	virtual ~tt__DateTime() { }
};
#endif

#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (368)
/* tt:Date */
class SOAP_CMAC tt__Date : public xsd__anyType
{
public:
	int Year;	/* required element of type xsd:int */
	int Month;	/* required element of type xsd:int */
	int Day;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 368; } /* = unique type id SOAP_TYPE_tt__Date */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Date() { tt__Date::soap_default(NULL); }
	virtual ~tt__Date() { }
};
#endif

#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (369)
/* tt:Time */
class SOAP_CMAC tt__Time : public xsd__anyType
{
public:
	int Hour;	/* required element of type xsd:int */
	int Minute;	/* required element of type xsd:int */
	int Second;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 369; } /* = unique type id SOAP_TYPE_tt__Time */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Time() { tt__Time::soap_default(NULL); }
	virtual ~tt__Time() { }
};
#endif

#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (370)
/* tt:TimeZone */
class SOAP_CMAC tt__TimeZone : public xsd__anyType
{
public:
	std::string TZ;	/* required element of type xsd:token */
public:
	virtual int soap_type() const { return 370; } /* = unique type id SOAP_TYPE_tt__TimeZone */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TimeZone() { tt__TimeZone::soap_default(NULL); }
	virtual ~tt__TimeZone() { }
};
#endif

#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (371)
/* tt:RemoteUser */
class SOAP_CMAC tt__RemoteUser : public xsd__anyType
{
public:
	std::string Username;	/* required element of type xsd:string */
	std::string *Password;	/* optional element of type xsd:string */
	bool UseDerivedPassword;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 371; } /* = unique type id SOAP_TYPE_tt__RemoteUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RemoteUser() { tt__RemoteUser::soap_default(NULL); }
	virtual ~tt__RemoteUser() { }
};
#endif

#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (372)
/* tt:User */
class SOAP_CMAC tt__User : public xsd__anyType
{
public:
	std::string Username;	/* required element of type xsd:string */
	std::string *Password;	/* optional element of type xsd:string */
	enum tt__UserLevel UserLevel;	/* required element of type tt:UserLevel */
	class tt__UserExtension *Extension;	/* optional element of type tt:UserExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 372; } /* = unique type id SOAP_TYPE_tt__User */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__User() { tt__User::soap_default(NULL); }
	virtual ~tt__User() { }
};
#endif

#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (373)
/* tt:UserExtension */
class SOAP_CMAC tt__UserExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 373; } /* = unique type id SOAP_TYPE_tt__UserExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__UserExtension() { tt__UserExtension::soap_default(NULL); }
	virtual ~tt__UserExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateGenerationParameters
#define SOAP_TYPE_tt__CertificateGenerationParameters (374)
/* tt:CertificateGenerationParameters */
class SOAP_CMAC tt__CertificateGenerationParameters : public xsd__anyType
{
public:
	std::string *CertificateID;	/* optional element of type xsd:token */
	std::string *Subject;	/* optional element of type xsd:string */
	std::string *ValidNotBefore;	/* optional element of type xsd:token */
	std::string *ValidNotAfter;	/* optional element of type xsd:token */
	class tt__CertificateGenerationParametersExtension *Extension;	/* optional element of type tt:CertificateGenerationParametersExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 374; } /* = unique type id SOAP_TYPE_tt__CertificateGenerationParameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateGenerationParameters() { tt__CertificateGenerationParameters::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParameters() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateGenerationParametersExtension
#define SOAP_TYPE_tt__CertificateGenerationParametersExtension (375)
/* tt:CertificateGenerationParametersExtension */
class SOAP_CMAC tt__CertificateGenerationParametersExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 375; } /* = unique type id SOAP_TYPE_tt__CertificateGenerationParametersExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateGenerationParametersExtension() { tt__CertificateGenerationParametersExtension::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParametersExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (376)
/* tt:Certificate */
class SOAP_CMAC tt__Certificate : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	tt__BinaryData *Certificate;	/* required element of type tt:BinaryData */
public:
	virtual int soap_type() const { return 376; } /* = unique type id SOAP_TYPE_tt__Certificate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Certificate() { tt__Certificate::soap_default(NULL); }
	virtual ~tt__Certificate() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (377)
/* tt:CertificateStatus */
class SOAP_CMAC tt__CertificateStatus : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	bool Status;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 377; } /* = unique type id SOAP_TYPE_tt__CertificateStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateStatus() { tt__CertificateStatus::soap_default(NULL); }
	virtual ~tt__CertificateStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (378)
/* tt:CertificateWithPrivateKey */
class SOAP_CMAC tt__CertificateWithPrivateKey : public xsd__anyType
{
public:
	std::string *CertificateID;	/* optional element of type xsd:token */
	tt__BinaryData *Certificate;	/* required element of type tt:BinaryData */
	tt__BinaryData *PrivateKey;	/* required element of type tt:BinaryData */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 378; } /* = unique type id SOAP_TYPE_tt__CertificateWithPrivateKey */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateWithPrivateKey() { tt__CertificateWithPrivateKey::soap_default(NULL); }
	virtual ~tt__CertificateWithPrivateKey() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (379)
/* tt:CertificateInformation */
class SOAP_CMAC tt__CertificateInformation : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	std::string *IssuerDN;	/* optional element of type xsd:string */
	std::string *SubjectDN;	/* optional element of type xsd:string */
	class tt__CertificateUsage *KeyUsage;	/* optional element of type tt:CertificateUsage */
	tt__CertificateUsage *ExtendedKeyUsage;	/* optional element of type tt:CertificateUsage */
	int *KeyLength;	/* optional element of type xsd:int */
	std::string *Version;	/* optional element of type xsd:string */
	std::string *SerialNum;	/* optional element of type xsd:string */
	std::string *SignatureAlgorithm;	/* optional element of type xsd:string */
	class tt__DateTimeRange *Validity;	/* optional element of type tt:DateTimeRange */
	class tt__CertificateInformationExtension *Extension;	/* optional element of type tt:CertificateInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 379; } /* = unique type id SOAP_TYPE_tt__CertificateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateInformation() { tt__CertificateInformation::soap_default(NULL); }
	virtual ~tt__CertificateInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (381)
/* tt:CertificateInformationExtension */
class SOAP_CMAC tt__CertificateInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 381; } /* = unique type id SOAP_TYPE_tt__CertificateInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateInformationExtension() { tt__CertificateInformationExtension::soap_default(NULL); }
	virtual ~tt__CertificateInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (382)
/* tt:Dot1XConfiguration */
class SOAP_CMAC tt__Dot1XConfiguration : public xsd__anyType
{
public:
	std::string Dot1XConfigurationToken;	/* required element of type tt:ReferenceToken */
	std::string Identity;	/* required element of type xsd:string */
	std::string *AnonymousID;	/* optional element of type xsd:string */
	int EAPMethod;	/* required element of type xsd:int */
	std::vector<std::string >CACertificateID;	/* optional element of type xsd:token */
	class tt__EAPMethodConfiguration *EAPMethodConfiguration;	/* optional element of type tt:EAPMethodConfiguration */
	class tt__Dot1XConfigurationExtension *Extension;	/* optional element of type tt:Dot1XConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 382; } /* = unique type id SOAP_TYPE_tt__Dot1XConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot1XConfiguration() { tt__Dot1XConfiguration::soap_default(NULL); }
	virtual ~tt__Dot1XConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (383)
/* tt:Dot1XConfigurationExtension */
class SOAP_CMAC tt__Dot1XConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 383; } /* = unique type id SOAP_TYPE_tt__Dot1XConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot1XConfigurationExtension() { tt__Dot1XConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot1XConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (384)
/* tt:EAPMethodConfiguration */
class SOAP_CMAC tt__EAPMethodConfiguration : public xsd__anyType
{
public:
	class tt__TLSConfiguration *TLSConfiguration;	/* optional element of type tt:TLSConfiguration */
	std::string *Password;	/* optional element of type xsd:string */
	class tt__EapMethodExtension *Extension;	/* optional element of type tt:EapMethodExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 384; } /* = unique type id SOAP_TYPE_tt__EAPMethodConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EAPMethodConfiguration() { tt__EAPMethodConfiguration::soap_default(NULL); }
	virtual ~tt__EAPMethodConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (385)
/* tt:EapMethodExtension */
class SOAP_CMAC tt__EapMethodExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 385; } /* = unique type id SOAP_TYPE_tt__EapMethodExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EapMethodExtension() { tt__EapMethodExtension::soap_default(NULL); }
	virtual ~tt__EapMethodExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (386)
/* tt:TLSConfiguration */
class SOAP_CMAC tt__TLSConfiguration : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 386; } /* = unique type id SOAP_TYPE_tt__TLSConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TLSConfiguration() { tt__TLSConfiguration::soap_default(NULL); }
	virtual ~tt__TLSConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (387)
/* tt:GenericEapPwdConfigurationExtension */
class SOAP_CMAC tt__GenericEapPwdConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 387; } /* = unique type id SOAP_TYPE_tt__GenericEapPwdConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GenericEapPwdConfigurationExtension() { tt__GenericEapPwdConfigurationExtension::soap_default(NULL); }
	virtual ~tt__GenericEapPwdConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (388)
/* tt:RelayOutputSettings */
class SOAP_CMAC tt__RelayOutputSettings : public xsd__anyType
{
public:
	enum tt__RelayMode Mode;	/* required element of type tt:RelayMode */
	LONG64 DelayTime;	/* external */
	enum tt__RelayIdleState IdleState;	/* required element of type tt:RelayIdleState */
public:
	virtual int soap_type() const { return 388; } /* = unique type id SOAP_TYPE_tt__RelayOutputSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayOutputSettings() { tt__RelayOutputSettings::soap_default(NULL); }
	virtual ~tt__RelayOutputSettings() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (392)
/* tt:PTZNodeExtension */
class SOAP_CMAC tt__PTZNodeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class tt__PTZPresetTourSupported *SupportedPresetTour;	/* optional element of type tt:PTZPresetTourSupported */
	class tt__PTZNodeExtension2 *Extension;	/* optional element of type tt:PTZNodeExtension2 */
public:
	virtual int soap_type() const { return 392; } /* = unique type id SOAP_TYPE_tt__PTZNodeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZNodeExtension() { tt__PTZNodeExtension::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (393)
/* tt:PTZNodeExtension2 */
class SOAP_CMAC tt__PTZNodeExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 393; } /* = unique type id SOAP_TYPE_tt__PTZNodeExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZNodeExtension2() { tt__PTZNodeExtension2::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (394)
/* tt:PTZPresetTourSupported */
class SOAP_CMAC tt__PTZPresetTourSupported : public xsd__anyType
{
public:
	int MaximumNumberOfPresetTours;	/* required element of type xsd:int */
	std::vector<enum tt__PTZPresetTourOperation >PTZPresetTourOperation;	/* optional element of type tt:PTZPresetTourOperation */
	class tt__PTZPresetTourSupportedExtension *Extension;	/* optional element of type tt:PTZPresetTourSupportedExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 394; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourSupported */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSupported() { tt__PTZPresetTourSupported::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupported() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (395)
/* tt:PTZPresetTourSupportedExtension */
class SOAP_CMAC tt__PTZPresetTourSupportedExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 395; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourSupportedExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSupportedExtension() { tt__PTZPresetTourSupportedExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupportedExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (397)
/* tt:PTZConfigurationExtension */
class SOAP_CMAC tt__PTZConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class tt__PTControlDirection *PTControlDirection;	/* optional element of type tt:PTControlDirection */
	class tt__PTZConfigurationExtension2 *Extension;	/* optional element of type tt:PTZConfigurationExtension2 */
public:
	virtual int soap_type() const { return 397; } /* = unique type id SOAP_TYPE_tt__PTZConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationExtension() { tt__PTZConfigurationExtension::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (398)
/* tt:PTZConfigurationExtension2 */
class SOAP_CMAC tt__PTZConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 398; } /* = unique type id SOAP_TYPE_tt__PTZConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationExtension2() { tt__PTZConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (399)
/* tt:PTControlDirection */
class SOAP_CMAC tt__PTControlDirection : public xsd__anyType
{
public:
	class tt__EFlip *EFlip;	/* optional element of type tt:EFlip */
	class tt__Reverse *Reverse;	/* optional element of type tt:Reverse */
	class tt__PTControlDirectionExtension *Extension;	/* optional element of type tt:PTControlDirectionExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 399; } /* = unique type id SOAP_TYPE_tt__PTControlDirection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTControlDirection() { tt__PTControlDirection::soap_default(NULL); }
	virtual ~tt__PTControlDirection() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (400)
/* tt:PTControlDirectionExtension */
class SOAP_CMAC tt__PTControlDirectionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 400; } /* = unique type id SOAP_TYPE_tt__PTControlDirectionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTControlDirectionExtension() { tt__PTControlDirectionExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (401)
/* tt:EFlip */
class SOAP_CMAC tt__EFlip : public xsd__anyType
{
public:
	enum tt__EFlipMode Mode;	/* required element of type tt:EFlipMode */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 401; } /* = unique type id SOAP_TYPE_tt__EFlip */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EFlip() { tt__EFlip::soap_default(NULL); }
	virtual ~tt__EFlip() { }
};
#endif

#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (402)
/* tt:Reverse */
class SOAP_CMAC tt__Reverse : public xsd__anyType
{
public:
	enum tt__ReverseMode Mode;	/* required element of type tt:ReverseMode */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 402; } /* = unique type id SOAP_TYPE_tt__Reverse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Reverse() { tt__Reverse::soap_default(NULL); }
	virtual ~tt__Reverse() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (403)
/* tt:PTZConfigurationOptions */
class SOAP_CMAC tt__PTZConfigurationOptions : public xsd__anyType
{
public:
	class tt__PTZSpaces *Spaces;	/* required element of type tt:PTZSpaces */
	tt__DurationRange *PTZTimeout;	/* required element of type tt:DurationRange */
	std::vector<char * >__any;
	class tt__PTControlDirectionOptions *PTControlDirection;	/* optional element of type tt:PTControlDirectionOptions */
	class tt__PTZConfigurationOptions2 *Extension;	/* optional element of type tt:PTZConfigurationOptions2 */
	std::string *PTZRamps;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 403; } /* = unique type id SOAP_TYPE_tt__PTZConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationOptions() { tt__PTZConfigurationOptions::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (404)
/* tt:PTZConfigurationOptions2 */
class SOAP_CMAC tt__PTZConfigurationOptions2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 404; } /* = unique type id SOAP_TYPE_tt__PTZConfigurationOptions2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationOptions2() { tt__PTZConfigurationOptions2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions2() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (405)
/* tt:PTControlDirectionOptions */
class SOAP_CMAC tt__PTControlDirectionOptions : public xsd__anyType
{
public:
	class tt__EFlipOptions *EFlip;	/* optional element of type tt:EFlipOptions */
	class tt__ReverseOptions *Reverse;	/* optional element of type tt:ReverseOptions */
	class tt__PTControlDirectionOptionsExtension *Extension;	/* optional element of type tt:PTControlDirectionOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 405; } /* = unique type id SOAP_TYPE_tt__PTControlDirectionOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTControlDirectionOptions() { tt__PTControlDirectionOptions::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (406)
/* tt:PTControlDirectionOptionsExtension */
class SOAP_CMAC tt__PTControlDirectionOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 406; } /* = unique type id SOAP_TYPE_tt__PTControlDirectionOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTControlDirectionOptionsExtension() { tt__PTControlDirectionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (407)
/* tt:EFlipOptions */
class SOAP_CMAC tt__EFlipOptions : public xsd__anyType
{
public:
	std::vector<enum tt__EFlipMode >Mode;	/* optional element of type tt:EFlipMode */
	class tt__EFlipOptionsExtension *Extension;	/* optional element of type tt:EFlipOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 407; } /* = unique type id SOAP_TYPE_tt__EFlipOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EFlipOptions() { tt__EFlipOptions::soap_default(NULL); }
	virtual ~tt__EFlipOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (408)
/* tt:EFlipOptionsExtension */
class SOAP_CMAC tt__EFlipOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 408; } /* = unique type id SOAP_TYPE_tt__EFlipOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EFlipOptionsExtension() { tt__EFlipOptionsExtension::soap_default(NULL); }
	virtual ~tt__EFlipOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (409)
/* tt:ReverseOptions */
class SOAP_CMAC tt__ReverseOptions : public xsd__anyType
{
public:
	std::vector<enum tt__ReverseMode >Mode;	/* optional element of type tt:ReverseMode */
	class tt__ReverseOptionsExtension *Extension;	/* optional element of type tt:ReverseOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 409; } /* = unique type id SOAP_TYPE_tt__ReverseOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReverseOptions() { tt__ReverseOptions::soap_default(NULL); }
	virtual ~tt__ReverseOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (410)
/* tt:ReverseOptionsExtension */
class SOAP_CMAC tt__ReverseOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 410; } /* = unique type id SOAP_TYPE_tt__ReverseOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReverseOptionsExtension() { tt__ReverseOptionsExtension::soap_default(NULL); }
	virtual ~tt__ReverseOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (411)
/* tt:PanTiltLimits */
class SOAP_CMAC tt__PanTiltLimits : public xsd__anyType
{
public:
	class tt__Space2DDescription *Range;	/* required element of type tt:Space2DDescription */
public:
	virtual int soap_type() const { return 411; } /* = unique type id SOAP_TYPE_tt__PanTiltLimits */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PanTiltLimits() { tt__PanTiltLimits::soap_default(NULL); }
	virtual ~tt__PanTiltLimits() { }
};
#endif

#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (412)
/* tt:ZoomLimits */
class SOAP_CMAC tt__ZoomLimits : public xsd__anyType
{
public:
	class tt__Space1DDescription *Range;	/* required element of type tt:Space1DDescription */
public:
	virtual int soap_type() const { return 412; } /* = unique type id SOAP_TYPE_tt__ZoomLimits */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ZoomLimits() { tt__ZoomLimits::soap_default(NULL); }
	virtual ~tt__ZoomLimits() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (413)
/* tt:PTZSpaces */
class SOAP_CMAC tt__PTZSpaces : public xsd__anyType
{
public:
	std::vector<tt__Space2DDescription * >AbsolutePanTiltPositionSpace;	/* optional element of type tt:Space2DDescription */
	std::vector<tt__Space1DDescription * >AbsoluteZoomPositionSpace;	/* optional element of type tt:Space1DDescription */
	std::vector<tt__Space2DDescription * >RelativePanTiltTranslationSpace;	/* optional element of type tt:Space2DDescription */
	std::vector<tt__Space1DDescription * >RelativeZoomTranslationSpace;	/* optional element of type tt:Space1DDescription */
	std::vector<tt__Space2DDescription * >ContinuousPanTiltVelocitySpace;	/* optional element of type tt:Space2DDescription */
	std::vector<tt__Space1DDescription * >ContinuousZoomVelocitySpace;	/* optional element of type tt:Space1DDescription */
	std::vector<tt__Space1DDescription * >PanTiltSpeedSpace;	/* optional element of type tt:Space1DDescription */
	std::vector<tt__Space1DDescription * >ZoomSpeedSpace;	/* optional element of type tt:Space1DDescription */
	class tt__PTZSpacesExtension *Extension;	/* optional element of type tt:PTZSpacesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 413; } /* = unique type id SOAP_TYPE_tt__PTZSpaces */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZSpaces() { tt__PTZSpaces::soap_default(NULL); }
	virtual ~tt__PTZSpaces() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (414)
/* tt:PTZSpacesExtension */
class SOAP_CMAC tt__PTZSpacesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 414; } /* = unique type id SOAP_TYPE_tt__PTZSpacesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZSpacesExtension() { tt__PTZSpacesExtension::soap_default(NULL); }
	virtual ~tt__PTZSpacesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (415)
/* tt:Space2DDescription */
class SOAP_CMAC tt__Space2DDescription : public xsd__anyType
{
public:
	std::string URI;	/* required element of type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of type tt:FloatRange */
	tt__FloatRange *YRange;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 415; } /* = unique type id SOAP_TYPE_tt__Space2DDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Space2DDescription() { tt__Space2DDescription::soap_default(NULL); }
	virtual ~tt__Space2DDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (416)
/* tt:Space1DDescription */
class SOAP_CMAC tt__Space1DDescription : public xsd__anyType
{
public:
	std::string URI;	/* required element of type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 416; } /* = unique type id SOAP_TYPE_tt__Space1DDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Space1DDescription() { tt__Space1DDescription::soap_default(NULL); }
	virtual ~tt__Space1DDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (417)
/* tt:PTZSpeed */
class SOAP_CMAC tt__PTZSpeed : public xsd__anyType
{
public:
	class tt__Vector2D *PanTilt;	/* optional element of type tt:Vector2D */
	class tt__Vector1D *Zoom;	/* optional element of type tt:Vector1D */
public:
	virtual int soap_type() const { return 417; } /* = unique type id SOAP_TYPE_tt__PTZSpeed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZSpeed() { tt__PTZSpeed::soap_default(NULL); }
	virtual ~tt__PTZSpeed() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (418)
/* tt:PTZPreset */
class SOAP_CMAC tt__PTZPreset : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of type tt:Name */
	class tt__PTZVector *PTZPosition;	/* optional element of type tt:PTZVector */
	std::string *token;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 418; } /* = unique type id SOAP_TYPE_tt__PTZPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPreset() { tt__PTZPreset::soap_default(NULL); }
	virtual ~tt__PTZPreset() { }
};
#endif

#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (419)
/* tt:PresetTour */
class SOAP_CMAC tt__PresetTour : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of type tt:Name */
	class tt__PTZPresetTourStatus *Status;	/* required element of type tt:PTZPresetTourStatus */
	bool AutoStart;	/* required element of type xsd:boolean */
	class tt__PTZPresetTourStartingCondition *StartingCondition;	/* required element of type tt:PTZPresetTourStartingCondition */
	std::vector<class tt__PTZPresetTourSpot * >TourSpot;	/* optional element of type tt:PTZPresetTourSpot */
	class tt__PTZPresetTourExtension *Extension;	/* optional element of type tt:PTZPresetTourExtension */
	std::string *token;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 419; } /* = unique type id SOAP_TYPE_tt__PresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PresetTour() { tt__PresetTour::soap_default(NULL); }
	virtual ~tt__PresetTour() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (420)
/* tt:PTZPresetTourExtension */
class SOAP_CMAC tt__PTZPresetTourExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 420; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourExtension() { tt__PTZPresetTourExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (421)
/* tt:PTZPresetTourSpot */
class SOAP_CMAC tt__PTZPresetTourSpot : public xsd__anyType
{
public:
	class tt__PTZPresetTourPresetDetail *PresetDetail;	/* required element of type tt:PTZPresetTourPresetDetail */
	tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	LONG64 *StayTime;	/* optional element of type xsd:duration */
	class tt__PTZPresetTourSpotExtension *Extension;	/* optional element of type tt:PTZPresetTourSpotExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 421; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourSpot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSpot() { tt__PTZPresetTourSpot::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpot() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (422)
/* tt:PTZPresetTourSpotExtension */
class SOAP_CMAC tt__PTZPresetTourSpotExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 422; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourSpotExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSpotExtension() { tt__PTZPresetTourSpotExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__tt__union_PTZPresetTourPresetDetail (1203)
/* xsd:choice */
union _tt__union_PTZPresetTourPresetDetail
{
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken	(1)
	std::string *PresetToken;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home	(2)
	bool Home;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition	(3)
	tt__PTZVector *PTZPosition;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension	(4)
	class tt__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (423)
/* tt:PTZPresetTourPresetDetail */
class SOAP_CMAC tt__PTZPresetTourPresetDetail : public xsd__anyType
{
public:
	int __union_PTZPresetTourPresetDetail;	/* union discriminant (of union defined below) */
	union _tt__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;	/* required element of type xsd:choice */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 423; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourPresetDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourPresetDetail() { tt__PTZPresetTourPresetDetail::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetail() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (424)
/* tt:PTZPresetTourTypeExtension */
class SOAP_CMAC tt__PTZPresetTourTypeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 424; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourTypeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourTypeExtension() { tt__PTZPresetTourTypeExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourTypeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (425)
/* tt:PTZPresetTourStatus */
class SOAP_CMAC tt__PTZPresetTourStatus : public xsd__anyType
{
public:
	enum tt__PTZPresetTourState State;	/* required element of type tt:PTZPresetTourState */
	tt__PTZPresetTourSpot *CurrentTourSpot;	/* optional element of type tt:PTZPresetTourSpot */
	class tt__PTZPresetTourStatusExtension *Extension;	/* optional element of type tt:PTZPresetTourStatusExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 425; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStatus() { tt__PTZPresetTourStatus::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (426)
/* tt:PTZPresetTourStatusExtension */
class SOAP_CMAC tt__PTZPresetTourStatusExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 426; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourStatusExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStatusExtension() { tt__PTZPresetTourStatusExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatusExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (427)
/* tt:PTZPresetTourStartingCondition */
class SOAP_CMAC tt__PTZPresetTourStartingCondition : public xsd__anyType
{
public:
	int *RecurringTime;	/* optional element of type xsd:int */
	LONG64 *RecurringDuration;	/* optional element of type xsd:duration */
	enum tt__PTZPresetTourDirection *Direction;	/* optional element of type tt:PTZPresetTourDirection */
	class tt__PTZPresetTourStartingConditionExtension *Extension;	/* optional element of type tt:PTZPresetTourStartingConditionExtension */
	bool *RandomPresetOrder;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 427; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourStartingCondition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStartingCondition() { tt__PTZPresetTourStartingCondition::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingCondition() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (428)
/* tt:PTZPresetTourStartingConditionExtension */
class SOAP_CMAC tt__PTZPresetTourStartingConditionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 428; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStartingConditionExtension() { tt__PTZPresetTourStartingConditionExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (429)
/* tt:PTZPresetTourOptions */
class SOAP_CMAC tt__PTZPresetTourOptions : public xsd__anyType
{
public:
	bool AutoStart;	/* required element of type xsd:boolean */
	class tt__PTZPresetTourStartingConditionOptions *StartingCondition;	/* required element of type tt:PTZPresetTourStartingConditionOptions */
	class tt__PTZPresetTourSpotOptions *TourSpot;	/* required element of type tt:PTZPresetTourSpotOptions */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 429; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourOptions() { tt__PTZPresetTourOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (430)
/* tt:PTZPresetTourSpotOptions */
class SOAP_CMAC tt__PTZPresetTourSpotOptions : public xsd__anyType
{
public:
	class tt__PTZPresetTourPresetDetailOptions *PresetDetail;	/* required element of type tt:PTZPresetTourPresetDetailOptions */
	tt__DurationRange *StayTime;	/* required element of type tt:DurationRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 430; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourSpotOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSpotOptions() { tt__PTZPresetTourSpotOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (431)
/* tt:PTZPresetTourPresetDetailOptions */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptions : public xsd__anyType
{
public:
	std::vector<std::string >PresetToken;	/* optional element of type tt:ReferenceToken */
	bool *Home;	/* optional element of type xsd:boolean */
	tt__Space2DDescription *PanTiltPositionSpace;	/* optional element of type tt:Space2DDescription */
	tt__Space1DDescription *ZoomPositionSpace;	/* optional element of type tt:Space1DDescription */
	class tt__PTZPresetTourPresetDetailOptionsExtension *Extension;	/* optional element of type tt:PTZPresetTourPresetDetailOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 431; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourPresetDetailOptions() { tt__PTZPresetTourPresetDetailOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (432)
/* tt:PTZPresetTourPresetDetailOptionsExtension */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 432; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourPresetDetailOptionsExtension() { tt__PTZPresetTourPresetDetailOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (433)
/* tt:PTZPresetTourStartingConditionOptions */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptions : public xsd__anyType
{
public:
	tt__IntRange *RecurringTime;	/* optional element of type tt:IntRange */
	tt__DurationRange *RecurringDuration;	/* optional element of type tt:DurationRange */
	std::vector<enum tt__PTZPresetTourDirection >Direction;	/* optional element of type tt:PTZPresetTourDirection */
	class tt__PTZPresetTourStartingConditionOptionsExtension *Extension;	/* optional element of type tt:PTZPresetTourStartingConditionOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 433; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStartingConditionOptions() { tt__PTZPresetTourStartingConditionOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (434)
/* tt:PTZPresetTourStartingConditionOptionsExtension */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 434; } /* = unique type id SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStartingConditionOptionsExtension() { tt__PTZPresetTourStartingConditionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus
#define SOAP_TYPE_tt__ImagingStatus (435)
/* tt:ImagingStatus */
class SOAP_CMAC tt__ImagingStatus : public xsd__anyType
{
public:
	class tt__FocusStatus *FocusStatus;	/* required element of type tt:FocusStatus */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 435; } /* = unique type id SOAP_TYPE_tt__ImagingStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingStatus() { tt__ImagingStatus::soap_default(NULL); }
	virtual ~tt__ImagingStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusStatus
#define SOAP_TYPE_tt__FocusStatus (436)
/* tt:FocusStatus */
class SOAP_CMAC tt__FocusStatus : public xsd__anyType
{
public:
	float Position;	/* required element of type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of type tt:MoveStatus */
	std::string Error;	/* required element of type xsd:string */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 436; } /* = unique type id SOAP_TYPE_tt__FocusStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusStatus() { tt__FocusStatus::soap_default(NULL); }
	virtual ~tt__FocusStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (437)
/* tt:FocusConfiguration */
class SOAP_CMAC tt__FocusConfiguration : public xsd__anyType
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of type tt:AutoFocusMode */
	float DefaultSpeed;	/* required element of type xsd:float */
	float NearLimit;	/* required element of type xsd:float */
	float FarLimit;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 437; } /* = unique type id SOAP_TYPE_tt__FocusConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusConfiguration() { tt__FocusConfiguration::soap_default(NULL); }
	virtual ~tt__FocusConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (438)
/* tt:ImagingSettings */
class SOAP_CMAC tt__ImagingSettings : public xsd__anyType
{
public:
	class tt__BacklightCompensation *BacklightCompensation;	/* optional element of type tt:BacklightCompensation */
	float *Brightness;	/* optional element of type xsd:float */
	float *ColorSaturation;	/* optional element of type xsd:float */
	float *Contrast;	/* optional element of type xsd:float */
	class tt__Exposure *Exposure;	/* optional element of type tt:Exposure */
	tt__FocusConfiguration *Focus;	/* optional element of type tt:FocusConfiguration */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of type xsd:float */
	class tt__WideDynamicRange *WideDynamicRange;	/* optional element of type tt:WideDynamicRange */
	class tt__WhiteBalance *WhiteBalance;	/* optional element of type tt:WhiteBalance */
	class tt__ImagingSettingsExtension *Extension;	/* optional element of type tt:ImagingSettingsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 438; } /* = unique type id SOAP_TYPE_tt__ImagingSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettings() { tt__ImagingSettings::soap_default(NULL); }
	virtual ~tt__ImagingSettings() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (439)
/* tt:ImagingSettingsExtension */
class SOAP_CMAC tt__ImagingSettingsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 439; } /* = unique type id SOAP_TYPE_tt__ImagingSettingsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension() { tt__ImagingSettingsExtension::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (440)
/* tt:Exposure */
class SOAP_CMAC tt__Exposure : public xsd__anyType
{
public:
	enum tt__ExposureMode Mode;	/* required element of type tt:ExposureMode */
	enum tt__ExposurePriority Priority;	/* required element of type tt:ExposurePriority */
	class tt__Rectangle *Window;	/* required element of type tt:Rectangle */
	float MinExposureTime;	/* required element of type xsd:float */
	float MaxExposureTime;	/* required element of type xsd:float */
	float MinGain;	/* required element of type xsd:float */
	float MaxGain;	/* required element of type xsd:float */
	float MinIris;	/* required element of type xsd:float */
	float MaxIris;	/* required element of type xsd:float */
	float ExposureTime;	/* required element of type xsd:float */
	float Gain;	/* required element of type xsd:float */
	float Iris;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 440; } /* = unique type id SOAP_TYPE_tt__Exposure */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Exposure() { tt__Exposure::soap_default(NULL); }
	virtual ~tt__Exposure() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (441)
/* tt:WideDynamicRange */
class SOAP_CMAC tt__WideDynamicRange : public xsd__anyType
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of type tt:WideDynamicMode */
	float Level;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 441; } /* = unique type id SOAP_TYPE_tt__WideDynamicRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRange() { tt__WideDynamicRange::soap_default(NULL); }
	virtual ~tt__WideDynamicRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (442)
/* tt:BacklightCompensation */
class SOAP_CMAC tt__BacklightCompensation : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of type tt:BacklightCompensationMode */
	float Level;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 442; } /* = unique type id SOAP_TYPE_tt__BacklightCompensation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensation() { tt__BacklightCompensation::soap_default(NULL); }
	virtual ~tt__BacklightCompensation() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions
#define SOAP_TYPE_tt__ImagingOptions (443)
/* tt:ImagingOptions */
class SOAP_CMAC tt__ImagingOptions : public xsd__anyType
{
public:
	class tt__BacklightCompensationOptions *BacklightCompensation;	/* required element of type tt:BacklightCompensationOptions */
	tt__FloatRange *Brightness;	/* required element of type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* required element of type tt:FloatRange */
	tt__FloatRange *Contrast;	/* required element of type tt:FloatRange */
	class tt__ExposureOptions *Exposure;	/* required element of type tt:ExposureOptions */
	class tt__FocusOptions *Focus;	/* required element of type tt:FocusOptions */
	std::vector<enum tt__IrCutFilterMode >IrCutFilterModes;	/* required element of type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* required element of type tt:FloatRange */
	class tt__WideDynamicRangeOptions *WideDynamicRange;	/* required element of type tt:WideDynamicRangeOptions */
	class tt__WhiteBalanceOptions *WhiteBalance;	/* required element of type tt:WhiteBalanceOptions */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 443; } /* = unique type id SOAP_TYPE_tt__ImagingOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions() { tt__ImagingOptions::soap_default(NULL); }
	virtual ~tt__ImagingOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions
#define SOAP_TYPE_tt__WideDynamicRangeOptions (444)
/* tt:WideDynamicRangeOptions */
class SOAP_CMAC tt__WideDynamicRangeOptions : public xsd__anyType
{
public:
	std::vector<enum tt__WideDynamicMode >Mode;	/* required element of type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 444; } /* = unique type id SOAP_TYPE_tt__WideDynamicRangeOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRangeOptions() { tt__WideDynamicRangeOptions::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationOptions
#define SOAP_TYPE_tt__BacklightCompensationOptions (445)
/* tt:BacklightCompensationOptions */
class SOAP_CMAC tt__BacklightCompensationOptions : public xsd__anyType
{
public:
	std::vector<enum tt__WideDynamicMode >Mode;	/* required element of type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 445; } /* = unique type id SOAP_TYPE_tt__BacklightCompensationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensationOptions() { tt__BacklightCompensationOptions::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusOptions
#define SOAP_TYPE_tt__FocusOptions (446)
/* tt:FocusOptions */
class SOAP_CMAC tt__FocusOptions : public xsd__anyType
{
public:
	std::vector<enum tt__AutoFocusMode >AutoFocusModes;	/* optional element of type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* required element of type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* required element of type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 446; } /* = unique type id SOAP_TYPE_tt__FocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusOptions() { tt__FocusOptions::soap_default(NULL); }
	virtual ~tt__FocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposureOptions
#define SOAP_TYPE_tt__ExposureOptions (447)
/* tt:ExposureOptions */
class SOAP_CMAC tt__ExposureOptions : public xsd__anyType
{
public:
	std::vector<enum tt__ExposureMode >Mode;	/* required element of type tt:ExposureMode */
	std::vector<enum tt__ExposurePriority >Priority;	/* required element of type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* required element of type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* required element of type tt:FloatRange */
	tt__FloatRange *MinGain;	/* required element of type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* required element of type tt:FloatRange */
	tt__FloatRange *MinIris;	/* required element of type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* required element of type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* required element of type tt:FloatRange */
	tt__FloatRange *Gain;	/* required element of type tt:FloatRange */
	tt__FloatRange *Iris;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 447; } /* = unique type id SOAP_TYPE_tt__ExposureOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposureOptions() { tt__ExposureOptions::soap_default(NULL); }
	virtual ~tt__ExposureOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions
#define SOAP_TYPE_tt__WhiteBalanceOptions (448)
/* tt:WhiteBalanceOptions */
class SOAP_CMAC tt__WhiteBalanceOptions : public xsd__anyType
{
public:
	std::vector<enum tt__WhiteBalanceMode >Mode;	/* required element of type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* required element of type tt:FloatRange */
	tt__FloatRange *YbGain;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 448; } /* = unique type id SOAP_TYPE_tt__WhiteBalanceOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceOptions() { tt__WhiteBalanceOptions::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (449)
/* tt:FocusMove */
class SOAP_CMAC tt__FocusMove : public xsd__anyType
{
public:
	class tt__AbsoluteFocus *Absolute;	/* optional element of type tt:AbsoluteFocus */
	class tt__RelativeFocus *Relative;	/* optional element of type tt:RelativeFocus */
	class tt__ContinuousFocus *Continuous;	/* optional element of type tt:ContinuousFocus */
public:
	virtual int soap_type() const { return 449; } /* = unique type id SOAP_TYPE_tt__FocusMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusMove() { tt__FocusMove::soap_default(NULL); }
	virtual ~tt__FocusMove() { }
};
#endif

#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (450)
/* tt:AbsoluteFocus */
class SOAP_CMAC tt__AbsoluteFocus : public xsd__anyType
{
public:
	float Position;	/* required element of type xsd:float */
	float *Speed;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 450; } /* = unique type id SOAP_TYPE_tt__AbsoluteFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AbsoluteFocus() { tt__AbsoluteFocus::soap_default(NULL); }
	virtual ~tt__AbsoluteFocus() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (451)
/* tt:RelativeFocus */
class SOAP_CMAC tt__RelativeFocus : public xsd__anyType
{
public:
	float Distance;	/* required element of type xsd:float */
	float *Speed;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 451; } /* = unique type id SOAP_TYPE_tt__RelativeFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelativeFocus() { tt__RelativeFocus::soap_default(NULL); }
	virtual ~tt__RelativeFocus() { }
};
#endif

#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (452)
/* tt:ContinuousFocus */
class SOAP_CMAC tt__ContinuousFocus : public xsd__anyType
{
public:
	float Speed;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 452; } /* = unique type id SOAP_TYPE_tt__ContinuousFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ContinuousFocus() { tt__ContinuousFocus::soap_default(NULL); }
	virtual ~tt__ContinuousFocus() { }
};
#endif

#ifndef SOAP_TYPE_tt__MoveOptions
#define SOAP_TYPE_tt__MoveOptions (453)
/* tt:MoveOptions */
class SOAP_CMAC tt__MoveOptions : public xsd__anyType
{
public:
	class tt__AbsoluteFocusOptions *Absolute;	/* optional element of type tt:AbsoluteFocusOptions */
	class tt__RelativeFocusOptions *Relative;	/* optional element of type tt:RelativeFocusOptions */
	class tt__ContinuousFocusOptions *Continuous;	/* optional element of type tt:ContinuousFocusOptions */
public:
	virtual int soap_type() const { return 453; } /* = unique type id SOAP_TYPE_tt__MoveOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MoveOptions() { tt__MoveOptions::soap_default(NULL); }
	virtual ~tt__MoveOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (454)
/* tt:AbsoluteFocusOptions */
class SOAP_CMAC tt__AbsoluteFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Position;	/* required element of type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 454; } /* = unique type id SOAP_TYPE_tt__AbsoluteFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AbsoluteFocusOptions() { tt__AbsoluteFocusOptions::soap_default(NULL); }
	virtual ~tt__AbsoluteFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelativeFocusOptions
#define SOAP_TYPE_tt__RelativeFocusOptions (455)
/* tt:RelativeFocusOptions */
class SOAP_CMAC tt__RelativeFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Distance;	/* required element of type tt:FloatRange */
	tt__FloatRange *Speed;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 455; } /* = unique type id SOAP_TYPE_tt__RelativeFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelativeFocusOptions() { tt__RelativeFocusOptions::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (456)
/* tt:ContinuousFocusOptions */
class SOAP_CMAC tt__ContinuousFocusOptions : public xsd__anyType
{
public:
	tt__FloatRange *Speed;	/* required element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 456; } /* = unique type id SOAP_TYPE_tt__ContinuousFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ContinuousFocusOptions() { tt__ContinuousFocusOptions::soap_default(NULL); }
	virtual ~tt__ContinuousFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (457)
/* tt:WhiteBalance */
class SOAP_CMAC tt__WhiteBalance : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of type tt:WhiteBalanceMode */
	float CrGain;	/* required element of type xsd:float */
	float CbGain;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 457; } /* = unique type id SOAP_TYPE_tt__WhiteBalance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalance() { tt__WhiteBalance::soap_default(NULL); }
	virtual ~tt__WhiteBalance() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (458)
/* tt:ImagingStatus20 */
class SOAP_CMAC tt__ImagingStatus20 : public xsd__anyType
{
public:
	class tt__FocusStatus20 *FocusStatus20;	/* optional element of type tt:FocusStatus20 */
	class tt__ImagingStatus20Extension *Extension;	/* optional element of type tt:ImagingStatus20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 458; } /* = unique type id SOAP_TYPE_tt__ImagingStatus20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingStatus20() { tt__ImagingStatus20::soap_default(NULL); }
	virtual ~tt__ImagingStatus20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (459)
/* tt:ImagingStatus20Extension */
class SOAP_CMAC tt__ImagingStatus20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 459; } /* = unique type id SOAP_TYPE_tt__ImagingStatus20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingStatus20Extension() { tt__ImagingStatus20Extension::soap_default(NULL); }
	virtual ~tt__ImagingStatus20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (460)
/* tt:FocusStatus20 */
class SOAP_CMAC tt__FocusStatus20 : public xsd__anyType
{
public:
	float Position;	/* required element of type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of type tt:MoveStatus */
	std::string *Error;	/* optional element of type xsd:string */
	class tt__FocusStatus20Extension *Extension;	/* optional element of type tt:FocusStatus20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 460; } /* = unique type id SOAP_TYPE_tt__FocusStatus20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusStatus20() { tt__FocusStatus20::soap_default(NULL); }
	virtual ~tt__FocusStatus20() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (461)
/* tt:FocusStatus20Extension */
class SOAP_CMAC tt__FocusStatus20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 461; } /* = unique type id SOAP_TYPE_tt__FocusStatus20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusStatus20Extension() { tt__FocusStatus20Extension::soap_default(NULL); }
	virtual ~tt__FocusStatus20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (462)
/* tt:ImagingSettings20 */
class SOAP_CMAC tt__ImagingSettings20 : public xsd__anyType
{
public:
	class tt__BacklightCompensation20 *BacklightCompensation;	/* optional element of type tt:BacklightCompensation20 */
	float *Brightness;	/* optional element of type xsd:float */
	float *ColorSaturation;	/* optional element of type xsd:float */
	float *Contrast;	/* optional element of type xsd:float */
	class tt__Exposure20 *Exposure;	/* optional element of type tt:Exposure20 */
	class tt__FocusConfiguration20 *Focus;	/* optional element of type tt:FocusConfiguration20 */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of type xsd:float */
	class tt__WideDynamicRange20 *WideDynamicRange;	/* optional element of type tt:WideDynamicRange20 */
	class tt__WhiteBalance20 *WhiteBalance;	/* optional element of type tt:WhiteBalance20 */
	class tt__ImagingSettingsExtension20 *Extension;	/* optional element of type tt:ImagingSettingsExtension20 */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 462; } /* = unique type id SOAP_TYPE_tt__ImagingSettings20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettings20() { tt__ImagingSettings20::soap_default(NULL); }
	virtual ~tt__ImagingSettings20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (463)
/* tt:ImagingSettingsExtension20 */
class SOAP_CMAC tt__ImagingSettingsExtension20 : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class tt__ImageStabilization *ImageStabilization;	/* optional element of type tt:ImageStabilization */
	class tt__ImagingSettingsExtension202 *Extension;	/* optional element of type tt:ImagingSettingsExtension202 */
public:
	virtual int soap_type() const { return 463; } /* = unique type id SOAP_TYPE_tt__ImagingSettingsExtension20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension20() { tt__ImagingSettingsExtension20::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (464)
/* tt:ImagingSettingsExtension202 */
class SOAP_CMAC tt__ImagingSettingsExtension202 : public xsd__anyType
{
public:
	std::vector<class tt__IrCutFilterAutoAdjustment * >IrCutFilterAutoAdjustment;	/* optional element of type tt:IrCutFilterAutoAdjustment */
	class tt__ImagingSettingsExtension203 *Extension;	/* optional element of type tt:ImagingSettingsExtension203 */
public:
	virtual int soap_type() const { return 464; } /* = unique type id SOAP_TYPE_tt__ImagingSettingsExtension202 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension202() { tt__ImagingSettingsExtension202::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension202() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (465)
/* tt:ImagingSettingsExtension203 */
class SOAP_CMAC tt__ImagingSettingsExtension203 : public xsd__anyType
{
public:
	class tt__ToneCompensation *ToneCompensation;	/* optional element of type tt:ToneCompensation */
	class tt__Defogging *Defogging;	/* optional element of type tt:Defogging */
	class tt__NoiseReduction *NoiseReduction;	/* optional element of type tt:NoiseReduction */
	class tt__ImagingSettingsExtension204 *Extension;	/* optional element of type tt:ImagingSettingsExtension204 */
public:
	virtual int soap_type() const { return 465; } /* = unique type id SOAP_TYPE_tt__ImagingSettingsExtension203 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension203() { tt__ImagingSettingsExtension203::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension203() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (466)
/* tt:ImagingSettingsExtension204 */
class SOAP_CMAC tt__ImagingSettingsExtension204 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 466; } /* = unique type id SOAP_TYPE_tt__ImagingSettingsExtension204 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension204() { tt__ImagingSettingsExtension204::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension204() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (467)
/* tt:ImageStabilization */
class SOAP_CMAC tt__ImageStabilization : public xsd__anyType
{
public:
	enum tt__ImageStabilizationMode Mode;	/* required element of type tt:ImageStabilizationMode */
	float *Level;	/* optional element of type xsd:float */
	class tt__ImageStabilizationExtension *Extension;	/* optional element of type tt:ImageStabilizationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 467; } /* = unique type id SOAP_TYPE_tt__ImageStabilization */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageStabilization() { tt__ImageStabilization::soap_default(NULL); }
	virtual ~tt__ImageStabilization() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (468)
/* tt:ImageStabilizationExtension */
class SOAP_CMAC tt__ImageStabilizationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 468; } /* = unique type id SOAP_TYPE_tt__ImageStabilizationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageStabilizationExtension() { tt__ImageStabilizationExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (469)
/* tt:IrCutFilterAutoAdjustment */
class SOAP_CMAC tt__IrCutFilterAutoAdjustment : public xsd__anyType
{
public:
	std::string BoundaryType;	/* required element of type xsd:string */
	float *BoundaryOffset;	/* optional element of type xsd:float */
	LONG64 *ResponseTime;	/* optional element of type xsd:duration */
	class tt__IrCutFilterAutoAdjustmentExtension *Extension;	/* optional element of type tt:IrCutFilterAutoAdjustmentExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 469; } /* = unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustment */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IrCutFilterAutoAdjustment() { tt__IrCutFilterAutoAdjustment::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustment() { }
};
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (470)
/* tt:IrCutFilterAutoAdjustmentExtension */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 470; } /* = unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IrCutFilterAutoAdjustmentExtension() { tt__IrCutFilterAutoAdjustmentExtension::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (471)
/* tt:WideDynamicRange20 */
class SOAP_CMAC tt__WideDynamicRange20 : public xsd__anyType
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of type tt:WideDynamicMode */
	float *Level;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 471; } /* = unique type id SOAP_TYPE_tt__WideDynamicRange20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRange20() { tt__WideDynamicRange20::soap_default(NULL); }
	virtual ~tt__WideDynamicRange20() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (472)
/* tt:BacklightCompensation20 */
class SOAP_CMAC tt__BacklightCompensation20 : public xsd__anyType
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of type tt:BacklightCompensationMode */
	float *Level;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 472; } /* = unique type id SOAP_TYPE_tt__BacklightCompensation20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensation20() { tt__BacklightCompensation20::soap_default(NULL); }
	virtual ~tt__BacklightCompensation20() { }
};
#endif

#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (473)
/* tt:Exposure20 */
class SOAP_CMAC tt__Exposure20 : public xsd__anyType
{
public:
	enum tt__ExposureMode Mode;	/* required element of type tt:ExposureMode */
	enum tt__ExposurePriority *Priority;	/* optional element of type tt:ExposurePriority */
	tt__Rectangle *Window;	/* optional element of type tt:Rectangle */
	float *MinExposureTime;	/* optional element of type xsd:float */
	float *MaxExposureTime;	/* optional element of type xsd:float */
	float *MinGain;	/* optional element of type xsd:float */
	float *MaxGain;	/* optional element of type xsd:float */
	float *MinIris;	/* optional element of type xsd:float */
	float *MaxIris;	/* optional element of type xsd:float */
	float *ExposureTime;	/* optional element of type xsd:float */
	float *Gain;	/* optional element of type xsd:float */
	float *Iris;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 473; } /* = unique type id SOAP_TYPE_tt__Exposure20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Exposure20() { tt__Exposure20::soap_default(NULL); }
	virtual ~tt__Exposure20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (474)
/* tt:ToneCompensation */
class SOAP_CMAC tt__ToneCompensation : public xsd__anyType
{
public:
	std::string Mode;	/* required element of type xsd:string */
	float *Level;	/* optional element of type xsd:float */
	class tt__ToneCompensationExtension *Extension;	/* optional element of type tt:ToneCompensationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 474; } /* = unique type id SOAP_TYPE_tt__ToneCompensation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ToneCompensation() { tt__ToneCompensation::soap_default(NULL); }
	virtual ~tt__ToneCompensation() { }
};
#endif

#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (475)
/* tt:ToneCompensationExtension */
class SOAP_CMAC tt__ToneCompensationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 475; } /* = unique type id SOAP_TYPE_tt__ToneCompensationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ToneCompensationExtension() { tt__ToneCompensationExtension::soap_default(NULL); }
	virtual ~tt__ToneCompensationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (476)
/* tt:Defogging */
class SOAP_CMAC tt__Defogging : public xsd__anyType
{
public:
	std::string Mode;	/* required element of type xsd:string */
	float *Level;	/* optional element of type xsd:float */
	class tt__DefoggingExtension *Extension;	/* optional element of type tt:DefoggingExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 476; } /* = unique type id SOAP_TYPE_tt__Defogging */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Defogging() { tt__Defogging::soap_default(NULL); }
	virtual ~tt__Defogging() { }
};
#endif

#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (477)
/* tt:DefoggingExtension */
class SOAP_CMAC tt__DefoggingExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 477; } /* = unique type id SOAP_TYPE_tt__DefoggingExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DefoggingExtension() { tt__DefoggingExtension::soap_default(NULL); }
	virtual ~tt__DefoggingExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (478)
/* tt:NoiseReduction */
class SOAP_CMAC tt__NoiseReduction : public xsd__anyType
{
public:
	float Level;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 478; } /* = unique type id SOAP_TYPE_tt__NoiseReduction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NoiseReduction() { tt__NoiseReduction::soap_default(NULL); }
	virtual ~tt__NoiseReduction() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (479)
/* tt:ImagingOptions20 */
class SOAP_CMAC tt__ImagingOptions20 : public xsd__anyType
{
public:
	class tt__BacklightCompensationOptions20 *BacklightCompensation;	/* optional element of type tt:BacklightCompensationOptions20 */
	tt__FloatRange *Brightness;	/* optional element of type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* optional element of type tt:FloatRange */
	tt__FloatRange *Contrast;	/* optional element of type tt:FloatRange */
	class tt__ExposureOptions20 *Exposure;	/* optional element of type tt:ExposureOptions20 */
	class tt__FocusOptions20 *Focus;	/* optional element of type tt:FocusOptions20 */
	std::vector<enum tt__IrCutFilterMode >IrCutFilterModes;	/* optional element of type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* optional element of type tt:FloatRange */
	class tt__WideDynamicRangeOptions20 *WideDynamicRange;	/* optional element of type tt:WideDynamicRangeOptions20 */
	class tt__WhiteBalanceOptions20 *WhiteBalance;	/* optional element of type tt:WhiteBalanceOptions20 */
	class tt__ImagingOptions20Extension *Extension;	/* optional element of type tt:ImagingOptions20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 479; } /* = unique type id SOAP_TYPE_tt__ImagingOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20() { tt__ImagingOptions20::soap_default(NULL); }
	virtual ~tt__ImagingOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (480)
/* tt:ImagingOptions20Extension */
class SOAP_CMAC tt__ImagingOptions20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class tt__ImageStabilizationOptions *ImageStabilization;	/* optional element of type tt:ImageStabilizationOptions */
	class tt__ImagingOptions20Extension2 *Extension;	/* optional element of type tt:ImagingOptions20Extension2 */
public:
	virtual int soap_type() const { return 480; } /* = unique type id SOAP_TYPE_tt__ImagingOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20Extension() { tt__ImagingOptions20Extension::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (481)
/* tt:ImagingOptions20Extension2 */
class SOAP_CMAC tt__ImagingOptions20Extension2 : public xsd__anyType
{
public:
	class tt__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment;	/* optional element of type tt:IrCutFilterAutoAdjustmentOptions */
	class tt__ImagingOptions20Extension3 *Extension;	/* optional element of type tt:ImagingOptions20Extension3 */
public:
	virtual int soap_type() const { return 481; } /* = unique type id SOAP_TYPE_tt__ImagingOptions20Extension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20Extension2() { tt__ImagingOptions20Extension2::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (482)
/* tt:ImagingOptions20Extension3 */
class SOAP_CMAC tt__ImagingOptions20Extension3 : public xsd__anyType
{
public:
	class tt__ToneCompensationOptions *ToneCompensationOptions;	/* optional element of type tt:ToneCompensationOptions */
	class tt__DefoggingOptions *DefoggingOptions;	/* optional element of type tt:DefoggingOptions */
	class tt__NoiseReductionOptions *NoiseReductionOptions;	/* optional element of type tt:NoiseReductionOptions */
	class tt__ImagingOptions20Extension4 *Extension;	/* optional element of type tt:ImagingOptions20Extension4 */
public:
	virtual int soap_type() const { return 482; } /* = unique type id SOAP_TYPE_tt__ImagingOptions20Extension3 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20Extension3() { tt__ImagingOptions20Extension3::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension3() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (483)
/* tt:ImagingOptions20Extension4 */
class SOAP_CMAC tt__ImagingOptions20Extension4 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 483; } /* = unique type id SOAP_TYPE_tt__ImagingOptions20Extension4 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20Extension4() { tt__ImagingOptions20Extension4::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension4() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (484)
/* tt:ImageStabilizationOptions */
class SOAP_CMAC tt__ImageStabilizationOptions : public xsd__anyType
{
public:
	std::vector<enum tt__ImageStabilizationMode >Mode;	/* required element of type tt:ImageStabilizationMode */
	tt__FloatRange *Level;	/* optional element of type tt:FloatRange */
	class tt__ImageStabilizationOptionsExtension *Extension;	/* optional element of type tt:ImageStabilizationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 484; } /* = unique type id SOAP_TYPE_tt__ImageStabilizationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageStabilizationOptions() { tt__ImageStabilizationOptions::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (485)
/* tt:ImageStabilizationOptionsExtension */
class SOAP_CMAC tt__ImageStabilizationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 485; } /* = unique type id SOAP_TYPE_tt__ImageStabilizationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageStabilizationOptionsExtension() { tt__ImageStabilizationOptionsExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (486)
/* tt:IrCutFilterAutoAdjustmentOptions */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptions : public xsd__anyType
{
public:
	std::vector<std::string >BoundaryType;	/* required element of type xsd:string */
	bool *BoundaryOffset;	/* optional element of type xsd:boolean */
	tt__DurationRange *ResponseTimeRange;	/* optional element of type tt:DurationRange */
	class tt__IrCutFilterAutoAdjustmentOptionsExtension *Extension;	/* optional element of type tt:IrCutFilterAutoAdjustmentOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 486; } /* = unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IrCutFilterAutoAdjustmentOptions() { tt__IrCutFilterAutoAdjustmentOptions::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (487)
/* tt:IrCutFilterAutoAdjustmentOptionsExtension */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 487; } /* = unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IrCutFilterAutoAdjustmentOptionsExtension() { tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_default(NULL); }
	virtual ~tt__IrCutFilterAutoAdjustmentOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (488)
/* tt:WideDynamicRangeOptions20 */
class SOAP_CMAC tt__WideDynamicRangeOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__WideDynamicMode >Mode;	/* required element of type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 488; } /* = unique type id SOAP_TYPE_tt__WideDynamicRangeOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRangeOptions20() { tt__WideDynamicRangeOptions20::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (489)
/* tt:BacklightCompensationOptions20 */
class SOAP_CMAC tt__BacklightCompensationOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__BacklightCompensationMode >Mode;	/* required element of type tt:BacklightCompensationMode */
	tt__FloatRange *Level;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 489; } /* = unique type id SOAP_TYPE_tt__BacklightCompensationOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensationOptions20() { tt__BacklightCompensationOptions20::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (490)
/* tt:ExposureOptions20 */
class SOAP_CMAC tt__ExposureOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__ExposureMode >Mode;	/* required element of type tt:ExposureMode */
	std::vector<enum tt__ExposurePriority >Priority;	/* optional element of type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MinGain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MinIris;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* optional element of type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* optional element of type tt:FloatRange */
	tt__FloatRange *Gain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *Iris;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 490; } /* = unique type id SOAP_TYPE_tt__ExposureOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposureOptions20() { tt__ExposureOptions20::soap_default(NULL); }
	virtual ~tt__ExposureOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (491)
/* tt:MoveOptions20 */
class SOAP_CMAC tt__MoveOptions20 : public xsd__anyType
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of type tt:AbsoluteFocusOptions */
	class tt__RelativeFocusOptions20 *Relative;	/* optional element of type tt:RelativeFocusOptions20 */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of type tt:ContinuousFocusOptions */
public:
	virtual int soap_type() const { return 491; } /* = unique type id SOAP_TYPE_tt__MoveOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MoveOptions20() { tt__MoveOptions20::soap_default(NULL); }
	virtual ~tt__MoveOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (492)
/* tt:RelativeFocusOptions20 */
class SOAP_CMAC tt__RelativeFocusOptions20 : public xsd__anyType
{
public:
	tt__FloatRange *Distance;	/* required element of type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of type tt:FloatRange */
public:
	virtual int soap_type() const { return 492; } /* = unique type id SOAP_TYPE_tt__RelativeFocusOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelativeFocusOptions20() { tt__RelativeFocusOptions20::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (493)
/* tt:WhiteBalance20 */
class SOAP_CMAC tt__WhiteBalance20 : public xsd__anyType
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of type tt:WhiteBalanceMode */
	float *CrGain;	/* optional element of type xsd:float */
	float *CbGain;	/* optional element of type xsd:float */
	class tt__WhiteBalance20Extension *Extension;	/* optional element of type tt:WhiteBalance20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 493; } /* = unique type id SOAP_TYPE_tt__WhiteBalance20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalance20() { tt__WhiteBalance20::soap_default(NULL); }
	virtual ~tt__WhiteBalance20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (494)
/* tt:WhiteBalance20Extension */
class SOAP_CMAC tt__WhiteBalance20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 494; } /* = unique type id SOAP_TYPE_tt__WhiteBalance20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalance20Extension() { tt__WhiteBalance20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalance20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (495)
/* tt:FocusConfiguration20 */
class SOAP_CMAC tt__FocusConfiguration20 : public xsd__anyType
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of type tt:AutoFocusMode */
	float *DefaultSpeed;	/* optional element of type xsd:float */
	float *NearLimit;	/* optional element of type xsd:float */
	float *FarLimit;	/* optional element of type xsd:float */
	class tt__FocusConfiguration20Extension *Extension;	/* optional element of type tt:FocusConfiguration20Extension */
	std::string *AFMode;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 495; } /* = unique type id SOAP_TYPE_tt__FocusConfiguration20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusConfiguration20() { tt__FocusConfiguration20::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (496)
/* tt:FocusConfiguration20Extension */
class SOAP_CMAC tt__FocusConfiguration20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 496; } /* = unique type id SOAP_TYPE_tt__FocusConfiguration20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusConfiguration20Extension() { tt__FocusConfiguration20Extension::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (497)
/* tt:WhiteBalanceOptions20 */
class SOAP_CMAC tt__WhiteBalanceOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__WhiteBalanceMode >Mode;	/* required element of type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *YbGain;	/* optional element of type tt:FloatRange */
	class tt__WhiteBalanceOptions20Extension *Extension;	/* optional element of type tt:WhiteBalanceOptions20Extension */
public:
	virtual int soap_type() const { return 497; } /* = unique type id SOAP_TYPE_tt__WhiteBalanceOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceOptions20() { tt__WhiteBalanceOptions20::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (498)
/* tt:WhiteBalanceOptions20Extension */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 498; } /* = unique type id SOAP_TYPE_tt__WhiteBalanceOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceOptions20Extension() { tt__WhiteBalanceOptions20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (499)
/* tt:FocusOptions20 */
class SOAP_CMAC tt__FocusOptions20 : public xsd__anyType
{
public:
	std::vector<enum tt__AutoFocusMode >AutoFocusModes;	/* optional element of type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* optional element of type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* optional element of type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* optional element of type tt:FloatRange */
	class tt__FocusOptions20Extension *Extension;	/* optional element of type tt:FocusOptions20Extension */
public:
	virtual int soap_type() const { return 499; } /* = unique type id SOAP_TYPE_tt__FocusOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusOptions20() { tt__FocusOptions20::soap_default(NULL); }
	virtual ~tt__FocusOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (500)
/* tt:FocusOptions20Extension */
class SOAP_CMAC tt__FocusOptions20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	std::string *AFModes;	/* optional element of type tt:StringAttrList */
public:
	virtual int soap_type() const { return 500; } /* = unique type id SOAP_TYPE_tt__FocusOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusOptions20Extension() { tt__FocusOptions20Extension::soap_default(NULL); }
	virtual ~tt__FocusOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (501)
/* tt:ToneCompensationOptions */
class SOAP_CMAC tt__ToneCompensationOptions : public xsd__anyType
{
public:
	std::vector<std::string >Mode;	/* required element of type xsd:string */
	bool Level;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 501; } /* = unique type id SOAP_TYPE_tt__ToneCompensationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ToneCompensationOptions() { tt__ToneCompensationOptions::soap_default(NULL); }
	virtual ~tt__ToneCompensationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (502)
/* tt:DefoggingOptions */
class SOAP_CMAC tt__DefoggingOptions : public xsd__anyType
{
public:
	std::vector<std::string >Mode;	/* required element of type xsd:string */
	bool Level;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 502; } /* = unique type id SOAP_TYPE_tt__DefoggingOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DefoggingOptions() { tt__DefoggingOptions::soap_default(NULL); }
	virtual ~tt__DefoggingOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (503)
/* tt:NoiseReductionOptions */
class SOAP_CMAC tt__NoiseReductionOptions : public xsd__anyType
{
public:
	bool Level;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 503; } /* = unique type id SOAP_TYPE_tt__NoiseReductionOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NoiseReductionOptions() { tt__NoiseReductionOptions::soap_default(NULL); }
	virtual ~tt__NoiseReductionOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (504)
/* tt:MessageExtension */
class SOAP_CMAC tt__MessageExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 504; } /* = unique type id SOAP_TYPE_tt__MessageExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MessageExtension() { tt__MessageExtension::soap_default(NULL); }
	virtual ~tt__MessageExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1285)
/* tt:ItemList-SimpleItem */
class SOAP_CMAC _tt__ItemList_SimpleItem
{
public:
	std::string Name;	/* required attribute */
	std::string Value;	/* required attribute */
public:
	virtual int soap_type() const { return 1285; } /* = unique type id SOAP_TYPE__tt__ItemList_SimpleItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemList_SimpleItem() { _tt__ItemList_SimpleItem::soap_default(NULL); }
	virtual ~_tt__ItemList_SimpleItem() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1288)
/* tt:ItemList-ElementItem */
class SOAP_CMAC _tt__ItemList_ElementItem
{
public:
	char *__any;
	std::string Name;	/* required attribute */
public:
	virtual int soap_type() const { return 1288; } /* = unique type id SOAP_TYPE__tt__ItemList_ElementItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemList_ElementItem() { _tt__ItemList_ElementItem::soap_default(NULL); }
	virtual ~_tt__ItemList_ElementItem() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (505)
/* tt:ItemList */
class SOAP_CMAC tt__ItemList : public xsd__anyType
{
public:
	std::vector<_tt__ItemList_SimpleItem >*SimpleItem;	/* optional element of type tt:ItemList-SimpleItem */
	std::vector<_tt__ItemList_ElementItem >*ElementItem;	/* optional element of type tt:ItemList-ElementItem */
	class tt__ItemListExtension *Extension;	/* optional element of type tt:ItemListExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 505; } /* = unique type id SOAP_TYPE_tt__ItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemList() { tt__ItemList::soap_default(NULL); }
	virtual ~tt__ItemList() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (506)
/* tt:ItemListExtension */
class SOAP_CMAC tt__ItemListExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 506; } /* = unique type id SOAP_TYPE_tt__ItemListExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemListExtension() { tt__ItemListExtension::soap_default(NULL); }
	virtual ~tt__ItemListExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MessageDescription
#define SOAP_TYPE_tt__MessageDescription (507)
/* tt:MessageDescription */
class SOAP_CMAC tt__MessageDescription : public xsd__anyType
{
public:
	class tt__ItemListDescription *Source;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of type tt:ItemListDescription */
	class tt__MessageDescriptionExtension *Extension;	/* optional element of type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 507; } /* = unique type id SOAP_TYPE_tt__MessageDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MessageDescription() { tt__MessageDescription::soap_default(NULL); }
	virtual ~tt__MessageDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__MessageDescriptionExtension
#define SOAP_TYPE_tt__MessageDescriptionExtension (508)
/* tt:MessageDescriptionExtension */
class SOAP_CMAC tt__MessageDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 508; } /* = unique type id SOAP_TYPE_tt__MessageDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MessageDescriptionExtension() { tt__MessageDescriptionExtension::soap_default(NULL); }
	virtual ~tt__MessageDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1294)
/* tt:ItemListDescription-SimpleItemDescription */
class SOAP_CMAC _tt__ItemListDescription_SimpleItemDescription
{
public:
	std::string Name;	/* required attribute */
	std::string Type;	/* required attribute */
public:
	virtual int soap_type() const { return 1294; } /* = unique type id SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemListDescription_SimpleItemDescription() { _tt__ItemListDescription_SimpleItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_SimpleItemDescription() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1297)
/* tt:ItemListDescription-ElementItemDescription */
class SOAP_CMAC _tt__ItemListDescription_ElementItemDescription
{
public:
	std::string Name;	/* required attribute */
	std::string Type;	/* required attribute */
public:
	virtual int soap_type() const { return 1297; } /* = unique type id SOAP_TYPE__tt__ItemListDescription_ElementItemDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemListDescription_ElementItemDescription() { _tt__ItemListDescription_ElementItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_ElementItemDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemListDescription
#define SOAP_TYPE_tt__ItemListDescription (509)
/* tt:ItemListDescription */
class SOAP_CMAC tt__ItemListDescription : public xsd__anyType
{
public:
	std::vector<_tt__ItemListDescription_SimpleItemDescription >*SimpleItemDescription;	/* optional element of type tt:ItemListDescription-SimpleItemDescription */
	std::vector<_tt__ItemListDescription_ElementItemDescription >*ElementItemDescription;	/* optional element of type tt:ItemListDescription-ElementItemDescription */
	class tt__ItemListDescriptionExtension *Extension;	/* optional element of type tt:ItemListDescriptionExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 509; } /* = unique type id SOAP_TYPE_tt__ItemListDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemListDescription() { tt__ItemListDescription::soap_default(NULL); }
	virtual ~tt__ItemListDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemListDescriptionExtension
#define SOAP_TYPE_tt__ItemListDescriptionExtension (510)
/* tt:ItemListDescriptionExtension */
class SOAP_CMAC tt__ItemListDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 510; } /* = unique type id SOAP_TYPE_tt__ItemListDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemListDescriptionExtension() { tt__ItemListDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ItemListDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (511)
/* tt:Polyline */
class SOAP_CMAC tt__Polyline : public xsd__anyType
{
public:
	std::vector<class tt__Vector * >Point;	/* required element of type tt:Vector */
public:
	virtual int soap_type() const { return 511; } /* = unique type id SOAP_TYPE_tt__Polyline */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Polyline() { tt__Polyline::soap_default(NULL); }
	virtual ~tt__Polyline() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (512)
/* tt:AnalyticsEngineConfiguration */
class SOAP_CMAC tt__AnalyticsEngineConfiguration : public xsd__anyType
{
public:
	std::vector<class tt__Config * >AnalyticsModule;	/* optional element of type tt:Config */
	class tt__AnalyticsEngineConfigurationExtension *Extension;	/* optional element of type tt:AnalyticsEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 512; } /* = unique type id SOAP_TYPE_tt__AnalyticsEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineConfiguration() { tt__AnalyticsEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (513)
/* tt:AnalyticsEngineConfigurationExtension */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 513; } /* = unique type id SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineConfigurationExtension() { tt__AnalyticsEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (514)
/* tt:RuleEngineConfiguration */
class SOAP_CMAC tt__RuleEngineConfiguration : public xsd__anyType
{
public:
	std::vector<tt__Config * >Rule;	/* optional element of type tt:Config */
	class tt__RuleEngineConfigurationExtension *Extension;	/* optional element of type tt:RuleEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 514; } /* = unique type id SOAP_TYPE_tt__RuleEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RuleEngineConfiguration() { tt__RuleEngineConfiguration::soap_default(NULL); }
	virtual ~tt__RuleEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (515)
/* tt:RuleEngineConfigurationExtension */
class SOAP_CMAC tt__RuleEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 515; } /* = unique type id SOAP_TYPE_tt__RuleEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RuleEngineConfigurationExtension() { tt__RuleEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RuleEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (516)
/* tt:Config */
class SOAP_CMAC tt__Config : public xsd__anyType
{
public:
	tt__ItemList *Parameters;	/* required element of type tt:ItemList */
	std::string Name;	/* required attribute */
	std::string Type;	/* required attribute */
public:
	virtual int soap_type() const { return 516; } /* = unique type id SOAP_TYPE_tt__Config */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Config() { tt__Config::soap_default(NULL); }
	virtual ~tt__Config() { }
};
#endif

#ifndef SOAP_TYPE__tt__ConfigDescription_Messages
#define SOAP_TYPE__tt__ConfigDescription_Messages (1308)
/* tt:ConfigDescription-Messages */
class SOAP_CMAC _tt__ConfigDescription_Messages
{
public:
	tt__ItemListDescription *Source;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	std::string ParentTopic;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 1308; } /* = unique type id SOAP_TYPE__tt__ConfigDescription_Messages */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ConfigDescription_Messages() { _tt__ConfigDescription_Messages::soap_default(NULL); }
	virtual ~_tt__ConfigDescription_Messages() { }
};
#endif

#ifndef SOAP_TYPE_tt__ConfigDescription
#define SOAP_TYPE_tt__ConfigDescription (517)
/* tt:ConfigDescription */
class SOAP_CMAC tt__ConfigDescription : public xsd__anyType
{
public:
	tt__ItemListDescription *Parameters;	/* required element of type tt:ItemListDescription */
	std::vector<_tt__ConfigDescription_Messages >*Messages;	/* optional element of type tt:ConfigDescription-Messages */
	class tt__ConfigDescriptionExtension *Extension;	/* optional element of type tt:ConfigDescriptionExtension */
	std::string Name;	/* required attribute */
	bool *fixed;	/* optional attribute */
	std::string *maxInstances;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 517; } /* = unique type id SOAP_TYPE_tt__ConfigDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ConfigDescription() { tt__ConfigDescription::soap_default(NULL); }
	virtual ~tt__ConfigDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__ConfigDescriptionExtension
#define SOAP_TYPE_tt__ConfigDescriptionExtension (518)
/* tt:ConfigDescriptionExtension */
class SOAP_CMAC tt__ConfigDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 518; } /* = unique type id SOAP_TYPE_tt__ConfigDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ConfigDescriptionExtension() { tt__ConfigDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ConfigDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedRules
#define SOAP_TYPE_tt__SupportedRules (519)
/* tt:SupportedRules */
class SOAP_CMAC tt__SupportedRules : public xsd__anyType
{
public:
	std::vector<std::string >RuleContentSchemaLocation;	/* optional element of type xsd:anyURI */
	std::vector<tt__ConfigDescription * >RuleDescription;	/* optional element of type tt:ConfigDescription */
	class tt__SupportedRulesExtension *Extension;	/* optional element of type tt:SupportedRulesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 519; } /* = unique type id SOAP_TYPE_tt__SupportedRules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedRules() { tt__SupportedRules::soap_default(NULL); }
	virtual ~tt__SupportedRules() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedRulesExtension
#define SOAP_TYPE_tt__SupportedRulesExtension (520)
/* tt:SupportedRulesExtension */
class SOAP_CMAC tt__SupportedRulesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 520; } /* = unique type id SOAP_TYPE_tt__SupportedRulesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedRulesExtension() { tt__SupportedRulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedRulesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedAnalyticsModules
#define SOAP_TYPE_tt__SupportedAnalyticsModules (521)
/* tt:SupportedAnalyticsModules */
class SOAP_CMAC tt__SupportedAnalyticsModules : public xsd__anyType
{
public:
	std::vector<std::string >AnalyticsModuleContentSchemaLocation;	/* optional element of type xsd:anyURI */
	std::vector<tt__ConfigDescription * >AnalyticsModuleDescription;	/* optional element of type tt:ConfigDescription */
	class tt__SupportedAnalyticsModulesExtension *Extension;	/* optional element of type tt:SupportedAnalyticsModulesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 521; } /* = unique type id SOAP_TYPE_tt__SupportedAnalyticsModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedAnalyticsModules() { tt__SupportedAnalyticsModules::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModules() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (522)
/* tt:SupportedAnalyticsModulesExtension */
class SOAP_CMAC tt__SupportedAnalyticsModulesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 522; } /* = unique type id SOAP_TYPE_tt__SupportedAnalyticsModulesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedAnalyticsModulesExtension() { tt__SupportedAnalyticsModulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModulesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PolygonConfiguration
#define SOAP_TYPE_tt__PolygonConfiguration (523)
/* tt:PolygonConfiguration */
class SOAP_CMAC tt__PolygonConfiguration : public xsd__anyType
{
public:
	class tt__Polygon *Polygon;	/* required element of type tt:Polygon */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 523; } /* = unique type id SOAP_TYPE_tt__PolygonConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PolygonConfiguration() { tt__PolygonConfiguration::soap_default(NULL); }
	virtual ~tt__PolygonConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__PolylineArray
#define SOAP_TYPE_tt__PolylineArray (524)
/* tt:PolylineArray */
class SOAP_CMAC tt__PolylineArray : public xsd__anyType
{
public:
	std::vector<tt__Polyline * >Segment;	/* required element of type tt:Polyline */
	class tt__PolylineArrayExtension *Extension;	/* optional element of type tt:PolylineArrayExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 524; } /* = unique type id SOAP_TYPE_tt__PolylineArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PolylineArray() { tt__PolylineArray::soap_default(NULL); }
	virtual ~tt__PolylineArray() { }
};
#endif

#ifndef SOAP_TYPE_tt__PolylineArrayExtension
#define SOAP_TYPE_tt__PolylineArrayExtension (525)
/* tt:PolylineArrayExtension */
class SOAP_CMAC tt__PolylineArrayExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 525; } /* = unique type id SOAP_TYPE_tt__PolylineArrayExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PolylineArrayExtension() { tt__PolylineArrayExtension::soap_default(NULL); }
	virtual ~tt__PolylineArrayExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PolylineArrayConfiguration
#define SOAP_TYPE_tt__PolylineArrayConfiguration (526)
/* tt:PolylineArrayConfiguration */
class SOAP_CMAC tt__PolylineArrayConfiguration : public xsd__anyType
{
public:
	tt__PolylineArray *PolylineArray;	/* required element of type tt:PolylineArray */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 526; } /* = unique type id SOAP_TYPE_tt__PolylineArrayConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PolylineArrayConfiguration() { tt__PolylineArrayConfiguration::soap_default(NULL); }
	virtual ~tt__PolylineArrayConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__MotionExpression
#define SOAP_TYPE_tt__MotionExpression (527)
/* tt:MotionExpression */
class SOAP_CMAC tt__MotionExpression : public xsd__anyType
{
public:
	std::string Expression;	/* required element of type xsd:string */
	std::vector<char * >__any;
	std::string *Type;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 527; } /* = unique type id SOAP_TYPE_tt__MotionExpression */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MotionExpression() { tt__MotionExpression::soap_default(NULL); }
	virtual ~tt__MotionExpression() { }
};
#endif

#ifndef SOAP_TYPE_tt__MotionExpressionConfiguration
#define SOAP_TYPE_tt__MotionExpressionConfiguration (528)
/* tt:MotionExpressionConfiguration */
class SOAP_CMAC tt__MotionExpressionConfiguration : public xsd__anyType
{
public:
	tt__MotionExpression *MotionExpression;	/* required element of type tt:MotionExpression */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 528; } /* = unique type id SOAP_TYPE_tt__MotionExpressionConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MotionExpressionConfiguration() { tt__MotionExpressionConfiguration::soap_default(NULL); }
	virtual ~tt__MotionExpressionConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__CellLayout
#define SOAP_TYPE_tt__CellLayout (529)
/* tt:CellLayout */
class SOAP_CMAC tt__CellLayout : public xsd__anyType
{
public:
	class tt__Transformation *Transformation;	/* required element of type tt:Transformation */
	std::vector<char * >__any;
	std::string Columns;	/* required attribute */
	std::string Rows;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 529; } /* = unique type id SOAP_TYPE_tt__CellLayout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CellLayout() { tt__CellLayout::soap_default(NULL); }
	virtual ~tt__CellLayout() { }
};
#endif

#ifndef SOAP_TYPE_tt__PaneConfiguration
#define SOAP_TYPE_tt__PaneConfiguration (530)
/* tt:PaneConfiguration */
class SOAP_CMAC tt__PaneConfiguration : public xsd__anyType
{
public:
	std::string *PaneName;	/* optional element of type xsd:string */
	std::string *AudioOutputToken;	/* optional element of type tt:ReferenceToken */
	std::string *AudioSourceToken;	/* optional element of type tt:ReferenceToken */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of type tt:AudioEncoderConfiguration */
	std::string *ReceiverToken;	/* optional element of type tt:ReferenceToken */
	std::string Token;	/* required element of type tt:ReferenceToken */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 530; } /* = unique type id SOAP_TYPE_tt__PaneConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PaneConfiguration() { tt__PaneConfiguration::soap_default(NULL); }
	virtual ~tt__PaneConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (531)
/* tt:PaneLayout */
class SOAP_CMAC tt__PaneLayout : public xsd__anyType
{
public:
	std::string Pane;	/* required element of type tt:ReferenceToken */
	tt__Rectangle *Area;	/* required element of type tt:Rectangle */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 531; } /* = unique type id SOAP_TYPE_tt__PaneLayout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PaneLayout() { tt__PaneLayout::soap_default(NULL); }
	virtual ~tt__PaneLayout() { }
};
#endif

#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (532)
/* tt:Layout */
class SOAP_CMAC tt__Layout : public xsd__anyType
{
public:
	std::vector<tt__PaneLayout * >PaneLayout;	/* required element of type tt:PaneLayout */
	class tt__LayoutExtension *Extension;	/* optional element of type tt:LayoutExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 532; } /* = unique type id SOAP_TYPE_tt__Layout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Layout() { tt__Layout::soap_default(NULL); }
	virtual ~tt__Layout() { }
};
#endif

#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (533)
/* tt:LayoutExtension */
class SOAP_CMAC tt__LayoutExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 533; } /* = unique type id SOAP_TYPE_tt__LayoutExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LayoutExtension() { tt__LayoutExtension::soap_default(NULL); }
	virtual ~tt__LayoutExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__CodingCapabilities
#define SOAP_TYPE_tt__CodingCapabilities (534)
/* tt:CodingCapabilities */
class SOAP_CMAC tt__CodingCapabilities : public xsd__anyType
{
public:
	tt__AudioEncoderConfigurationOptions *AudioEncodingCapabilities;	/* optional element of type tt:AudioEncoderConfigurationOptions */
	tt__AudioDecoderConfigurationOptions *AudioDecodingCapabilities;	/* optional element of type tt:AudioDecoderConfigurationOptions */
	tt__VideoDecoderConfigurationOptions *VideoDecodingCapabilities;	/* required element of type tt:VideoDecoderConfigurationOptions */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 534; } /* = unique type id SOAP_TYPE_tt__CodingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CodingCapabilities() { tt__CodingCapabilities::soap_default(NULL); }
	virtual ~tt__CodingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__LayoutOptions
#define SOAP_TYPE_tt__LayoutOptions (535)
/* tt:LayoutOptions */
class SOAP_CMAC tt__LayoutOptions : public xsd__anyType
{
public:
	std::vector<class tt__PaneLayoutOptions * >PaneLayoutOptions;	/* required element of type tt:PaneLayoutOptions */
	class tt__LayoutOptionsExtension *Extension;	/* optional element of type tt:LayoutOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 535; } /* = unique type id SOAP_TYPE_tt__LayoutOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LayoutOptions() { tt__LayoutOptions::soap_default(NULL); }
	virtual ~tt__LayoutOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__LayoutOptionsExtension
#define SOAP_TYPE_tt__LayoutOptionsExtension (536)
/* tt:LayoutOptionsExtension */
class SOAP_CMAC tt__LayoutOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 536; } /* = unique type id SOAP_TYPE_tt__LayoutOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LayoutOptionsExtension() { tt__LayoutOptionsExtension::soap_default(NULL); }
	virtual ~tt__LayoutOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PaneLayoutOptions
#define SOAP_TYPE_tt__PaneLayoutOptions (537)
/* tt:PaneLayoutOptions */
class SOAP_CMAC tt__PaneLayoutOptions : public xsd__anyType
{
public:
	std::vector<tt__Rectangle * >Area;	/* required element of type tt:Rectangle */
	class tt__PaneOptionExtension *Extension;	/* optional element of type tt:PaneOptionExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 537; } /* = unique type id SOAP_TYPE_tt__PaneLayoutOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PaneLayoutOptions() { tt__PaneLayoutOptions::soap_default(NULL); }
	virtual ~tt__PaneLayoutOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PaneOptionExtension
#define SOAP_TYPE_tt__PaneOptionExtension (538)
/* tt:PaneOptionExtension */
class SOAP_CMAC tt__PaneOptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 538; } /* = unique type id SOAP_TYPE_tt__PaneOptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PaneOptionExtension() { tt__PaneOptionExtension::soap_default(NULL); }
	virtual ~tt__PaneOptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Receiver
#define SOAP_TYPE_tt__Receiver (539)
/* tt:Receiver */
class SOAP_CMAC tt__Receiver : public xsd__anyType
{
public:
	std::string Token;	/* required element of type tt:ReferenceToken */
	class tt__ReceiverConfiguration *Configuration;	/* required element of type tt:ReceiverConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 539; } /* = unique type id SOAP_TYPE_tt__Receiver */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Receiver() { tt__Receiver::soap_default(NULL); }
	virtual ~tt__Receiver() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReceiverConfiguration
#define SOAP_TYPE_tt__ReceiverConfiguration (540)
/* tt:ReceiverConfiguration */
class SOAP_CMAC tt__ReceiverConfiguration : public xsd__anyType
{
public:
	enum tt__ReceiverMode Mode;	/* required element of type tt:ReceiverMode */
	std::string MediaUri;	/* required element of type xsd:anyURI */
	tt__StreamSetup *StreamSetup;	/* required element of type tt:StreamSetup */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 540; } /* = unique type id SOAP_TYPE_tt__ReceiverConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReceiverConfiguration() { tt__ReceiverConfiguration::soap_default(NULL); }
	virtual ~tt__ReceiverConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReceiverStateInformation
#define SOAP_TYPE_tt__ReceiverStateInformation (541)
/* tt:ReceiverStateInformation */
class SOAP_CMAC tt__ReceiverStateInformation : public xsd__anyType
{
public:
	enum tt__ReceiverState State;	/* required element of type tt:ReceiverState */
	bool AutoCreated;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 541; } /* = unique type id SOAP_TYPE_tt__ReceiverStateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReceiverStateInformation() { tt__ReceiverStateInformation::soap_default(NULL); }
	virtual ~tt__ReceiverStateInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__SourceReference
#define SOAP_TYPE_tt__SourceReference (542)
/* tt:SourceReference */
class SOAP_CMAC tt__SourceReference : public xsd__anyType
{
public:
	std::string Token;	/* required element of type tt:ReferenceToken */
	std::vector<char * >__any;
	std::string Type;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 542; } /* = unique type id SOAP_TYPE_tt__SourceReference */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SourceReference() { tt__SourceReference::soap_default(NULL); }
	virtual ~tt__SourceReference() { }
};
#endif

#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (543)
/* tt:DateTimeRange */
class SOAP_CMAC tt__DateTimeRange : public xsd__anyType
{
public:
	time_t From;	/* required element of type xsd:dateTime */
	time_t Until;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 543; } /* = unique type id SOAP_TYPE_tt__DateTimeRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DateTimeRange() { tt__DateTimeRange::soap_default(NULL); }
	virtual ~tt__DateTimeRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingSummary
#define SOAP_TYPE_tt__RecordingSummary (544)
/* tt:RecordingSummary */
class SOAP_CMAC tt__RecordingSummary : public xsd__anyType
{
public:
	time_t DataFrom;	/* required element of type xsd:dateTime */
	time_t DataUntil;	/* required element of type xsd:dateTime */
	int NumberRecordings;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 544; } /* = unique type id SOAP_TYPE_tt__RecordingSummary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingSummary() { tt__RecordingSummary::soap_default(NULL); }
	virtual ~tt__RecordingSummary() { }
};
#endif

#ifndef SOAP_TYPE_tt__SearchScope
#define SOAP_TYPE_tt__SearchScope (545)
/* tt:SearchScope */
class SOAP_CMAC tt__SearchScope : public xsd__anyType
{
public:
	std::vector<tt__SourceReference * >IncludedSources;	/* optional element of type tt:SourceReference */
	std::vector<std::string >IncludedRecordings;	/* optional element of type tt:RecordingReference */
	std::string *RecordingInformationFilter;	/* optional element of type tt:XPathExpression */
	class tt__SearchScopeExtension *Extension;	/* optional element of type tt:SearchScopeExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 545; } /* = unique type id SOAP_TYPE_tt__SearchScope */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SearchScope() { tt__SearchScope::soap_default(NULL); }
	virtual ~tt__SearchScope() { }
};
#endif

#ifndef SOAP_TYPE_tt__SearchScopeExtension
#define SOAP_TYPE_tt__SearchScopeExtension (546)
/* tt:SearchScopeExtension */
class SOAP_CMAC tt__SearchScopeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 546; } /* = unique type id SOAP_TYPE_tt__SearchScopeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SearchScopeExtension() { tt__SearchScopeExtension::soap_default(NULL); }
	virtual ~tt__SearchScopeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPositionFilter
#define SOAP_TYPE_tt__PTZPositionFilter (548)
/* tt:PTZPositionFilter */
class SOAP_CMAC tt__PTZPositionFilter : public xsd__anyType
{
public:
	tt__PTZVector *MinPosition;	/* required element of type tt:PTZVector */
	tt__PTZVector *MaxPosition;	/* required element of type tt:PTZVector */
	bool EnterOrExit;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 548; } /* = unique type id SOAP_TYPE_tt__PTZPositionFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPositionFilter() { tt__PTZPositionFilter::soap_default(NULL); }
	virtual ~tt__PTZPositionFilter() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataFilter
#define SOAP_TYPE_tt__MetadataFilter (549)
/* tt:MetadataFilter */
class SOAP_CMAC tt__MetadataFilter : public xsd__anyType
{
public:
	std::string MetadataStreamFilter;	/* required element of type tt:XPathExpression */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 549; } /* = unique type id SOAP_TYPE_tt__MetadataFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataFilter() { tt__MetadataFilter::soap_default(NULL); }
	virtual ~tt__MetadataFilter() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindRecordingResultList
#define SOAP_TYPE_tt__FindRecordingResultList (550)
/* tt:FindRecordingResultList */
class SOAP_CMAC tt__FindRecordingResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of type tt:SearchState */
	std::vector<class tt__RecordingInformation * >RecordingInformation;	/* optional element of type tt:RecordingInformation */
public:
	virtual int soap_type() const { return 550; } /* = unique type id SOAP_TYPE_tt__FindRecordingResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindRecordingResultList() { tt__FindRecordingResultList::soap_default(NULL); }
	virtual ~tt__FindRecordingResultList() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindEventResultList
#define SOAP_TYPE_tt__FindEventResultList (551)
/* tt:FindEventResultList */
class SOAP_CMAC tt__FindEventResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of type tt:SearchState */
	std::vector<class tt__FindEventResult * >Result;	/* optional element of type tt:FindEventResult */
public:
	virtual int soap_type() const { return 551; } /* = unique type id SOAP_TYPE_tt__FindEventResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindEventResultList() { tt__FindEventResultList::soap_default(NULL); }
	virtual ~tt__FindEventResultList() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindEventResult
#define SOAP_TYPE_tt__FindEventResult (552)
/* tt:FindEventResult */
class SOAP_CMAC tt__FindEventResult : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type tt:RecordingReference */
	std::string TrackToken;	/* required element of type tt:TrackReference */
	time_t Time;	/* required element of type xsd:dateTime */
	class wsnt__NotificationMessageHolderType *Event;	/* required element of type wsnt:NotificationMessageHolderType */
	bool StartStateEvent;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 552; } /* = unique type id SOAP_TYPE_tt__FindEventResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindEventResult() { tt__FindEventResult::soap_default(NULL); }
	virtual ~tt__FindEventResult() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindPTZPositionResultList
#define SOAP_TYPE_tt__FindPTZPositionResultList (553)
/* tt:FindPTZPositionResultList */
class SOAP_CMAC tt__FindPTZPositionResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of type tt:SearchState */
	std::vector<class tt__FindPTZPositionResult * >Result;	/* optional element of type tt:FindPTZPositionResult */
public:
	virtual int soap_type() const { return 553; } /* = unique type id SOAP_TYPE_tt__FindPTZPositionResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindPTZPositionResultList() { tt__FindPTZPositionResultList::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResultList() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindPTZPositionResult
#define SOAP_TYPE_tt__FindPTZPositionResult (554)
/* tt:FindPTZPositionResult */
class SOAP_CMAC tt__FindPTZPositionResult : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type tt:RecordingReference */
	std::string TrackToken;	/* required element of type tt:TrackReference */
	time_t Time;	/* required element of type xsd:dateTime */
	tt__PTZVector *Position;	/* required element of type tt:PTZVector */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 554; } /* = unique type id SOAP_TYPE_tt__FindPTZPositionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindPTZPositionResult() { tt__FindPTZPositionResult::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResult() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindMetadataResultList
#define SOAP_TYPE_tt__FindMetadataResultList (555)
/* tt:FindMetadataResultList */
class SOAP_CMAC tt__FindMetadataResultList : public xsd__anyType
{
public:
	enum tt__SearchState SearchState;	/* required element of type tt:SearchState */
	std::vector<class tt__FindMetadataResult * >Result;	/* optional element of type tt:FindMetadataResult */
public:
	virtual int soap_type() const { return 555; } /* = unique type id SOAP_TYPE_tt__FindMetadataResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindMetadataResultList() { tt__FindMetadataResultList::soap_default(NULL); }
	virtual ~tt__FindMetadataResultList() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindMetadataResult
#define SOAP_TYPE_tt__FindMetadataResult (556)
/* tt:FindMetadataResult */
class SOAP_CMAC tt__FindMetadataResult : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type tt:RecordingReference */
	std::string TrackToken;	/* required element of type tt:TrackReference */
	time_t Time;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 556; } /* = unique type id SOAP_TYPE_tt__FindMetadataResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindMetadataResult() { tt__FindMetadataResult::soap_default(NULL); }
	virtual ~tt__FindMetadataResult() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingInformation
#define SOAP_TYPE_tt__RecordingInformation (557)
/* tt:RecordingInformation */
class SOAP_CMAC tt__RecordingInformation : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type tt:RecordingReference */
	class tt__RecordingSourceInformation *Source;	/* required element of type tt:RecordingSourceInformation */
	time_t *EarliestRecording;	/* optional element of type xsd:dateTime */
	time_t *LatestRecording;	/* optional element of type xsd:dateTime */
	std::string Content;	/* required element of type tt:Description */
	std::vector<class tt__TrackInformation * >Track;	/* optional element of type tt:TrackInformation */
	enum tt__RecordingStatus RecordingStatus;	/* required element of type tt:RecordingStatus */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 557; } /* = unique type id SOAP_TYPE_tt__RecordingInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingInformation() { tt__RecordingInformation::soap_default(NULL); }
	virtual ~tt__RecordingInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingSourceInformation
#define SOAP_TYPE_tt__RecordingSourceInformation (558)
/* tt:RecordingSourceInformation */
class SOAP_CMAC tt__RecordingSourceInformation : public xsd__anyType
{
public:
	std::string SourceId;	/* required element of type xsd:anyURI */
	std::string Name;	/* required element of type tt:Name */
	std::string Location;	/* required element of type tt:Description */
	std::string Description;	/* required element of type tt:Description */
	std::string Address;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 558; } /* = unique type id SOAP_TYPE_tt__RecordingSourceInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingSourceInformation() { tt__RecordingSourceInformation::soap_default(NULL); }
	virtual ~tt__RecordingSourceInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackInformation
#define SOAP_TYPE_tt__TrackInformation (559)
/* tt:TrackInformation */
class SOAP_CMAC tt__TrackInformation : public xsd__anyType
{
public:
	std::string TrackToken;	/* required element of type tt:TrackReference */
	enum tt__TrackType TrackType;	/* required element of type tt:TrackType */
	std::string Description;	/* required element of type tt:Description */
	time_t DataFrom;	/* required element of type xsd:dateTime */
	time_t DataTo;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 559; } /* = unique type id SOAP_TYPE_tt__TrackInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackInformation() { tt__TrackInformation::soap_default(NULL); }
	virtual ~tt__TrackInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaAttributes
#define SOAP_TYPE_tt__MediaAttributes (560)
/* tt:MediaAttributes */
class SOAP_CMAC tt__MediaAttributes : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type tt:RecordingReference */
	std::vector<class tt__TrackAttributes * >TrackAttributes;	/* optional element of type tt:TrackAttributes */
	time_t From;	/* required element of type xsd:dateTime */
	time_t Until;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 560; } /* = unique type id SOAP_TYPE_tt__MediaAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaAttributes() { tt__MediaAttributes::soap_default(NULL); }
	virtual ~tt__MediaAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackAttributes
#define SOAP_TYPE_tt__TrackAttributes (561)
/* tt:TrackAttributes */
class SOAP_CMAC tt__TrackAttributes : public xsd__anyType
{
public:
	tt__TrackInformation *TrackInformation;	/* required element of type tt:TrackInformation */
	class tt__VideoAttributes *VideoAttributes;	/* optional element of type tt:VideoAttributes */
	class tt__AudioAttributes *AudioAttributes;	/* optional element of type tt:AudioAttributes */
	class tt__MetadataAttributes *MetadataAttributes;	/* optional element of type tt:MetadataAttributes */
	class tt__TrackAttributesExtension *Extension;	/* optional element of type tt:TrackAttributesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 561; } /* = unique type id SOAP_TYPE_tt__TrackAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackAttributes() { tt__TrackAttributes::soap_default(NULL); }
	virtual ~tt__TrackAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackAttributesExtension
#define SOAP_TYPE_tt__TrackAttributesExtension (562)
/* tt:TrackAttributesExtension */
class SOAP_CMAC tt__TrackAttributesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 562; } /* = unique type id SOAP_TYPE_tt__TrackAttributesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackAttributesExtension() { tt__TrackAttributesExtension::soap_default(NULL); }
	virtual ~tt__TrackAttributesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoAttributes
#define SOAP_TYPE_tt__VideoAttributes (563)
/* tt:VideoAttributes */
class SOAP_CMAC tt__VideoAttributes : public xsd__anyType
{
public:
	int *Bitrate;	/* optional element of type xsd:int */
	int Width;	/* required element of type xsd:int */
	int Height;	/* required element of type xsd:int */
	std::string Encoding;	/* required element of type xsd:string */
	float Framerate;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 563; } /* = unique type id SOAP_TYPE_tt__VideoAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoAttributes() { tt__VideoAttributes::soap_default(NULL); }
	virtual ~tt__VideoAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioAttributes
#define SOAP_TYPE_tt__AudioAttributes (564)
/* tt:AudioAttributes */
class SOAP_CMAC tt__AudioAttributes : public xsd__anyType
{
public:
	int *Bitrate;	/* optional element of type xsd:int */
	std::string Encoding;	/* required element of type xsd:string */
	int Samplerate;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 564; } /* = unique type id SOAP_TYPE_tt__AudioAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioAttributes() { tt__AudioAttributes::soap_default(NULL); }
	virtual ~tt__AudioAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataAttributes
#define SOAP_TYPE_tt__MetadataAttributes (565)
/* tt:MetadataAttributes */
class SOAP_CMAC tt__MetadataAttributes : public xsd__anyType
{
public:
	bool CanContainPTZ;	/* required element of type xsd:boolean */
	bool CanContainAnalytics;	/* required element of type xsd:boolean */
	bool CanContainNotifications;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	std::string *PtzSpaces;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 565; } /* = unique type id SOAP_TYPE_tt__MetadataAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataAttributes() { tt__MetadataAttributes::soap_default(NULL); }
	virtual ~tt__MetadataAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingConfiguration
#define SOAP_TYPE_tt__RecordingConfiguration (566)
/* tt:RecordingConfiguration */
class SOAP_CMAC tt__RecordingConfiguration : public xsd__anyType
{
public:
	tt__RecordingSourceInformation *Source;	/* required element of type tt:RecordingSourceInformation */
	std::string Content;	/* required element of type tt:Description */
	LONG64 MaximumRetentionTime;	/* external */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 566; } /* = unique type id SOAP_TYPE_tt__RecordingConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingConfiguration() { tt__RecordingConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackConfiguration
#define SOAP_TYPE_tt__TrackConfiguration (567)
/* tt:TrackConfiguration */
class SOAP_CMAC tt__TrackConfiguration : public xsd__anyType
{
public:
	enum tt__TrackType TrackType;	/* required element of type tt:TrackType */
	std::string Description;	/* required element of type tt:Description */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 567; } /* = unique type id SOAP_TYPE_tt__TrackConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackConfiguration() { tt__TrackConfiguration::soap_default(NULL); }
	virtual ~tt__TrackConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__GetRecordingsResponseItem
#define SOAP_TYPE_tt__GetRecordingsResponseItem (568)
/* tt:GetRecordingsResponseItem */
class SOAP_CMAC tt__GetRecordingsResponseItem : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type tt:RecordingReference */
	tt__RecordingConfiguration *Configuration;	/* required element of type tt:RecordingConfiguration */
	class tt__GetTracksResponseList *Tracks;	/* required element of type tt:GetTracksResponseList */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 568; } /* = unique type id SOAP_TYPE_tt__GetRecordingsResponseItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GetRecordingsResponseItem() { tt__GetRecordingsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingsResponseItem() { }
};
#endif

#ifndef SOAP_TYPE_tt__GetTracksResponseList
#define SOAP_TYPE_tt__GetTracksResponseList (569)
/* tt:GetTracksResponseList */
class SOAP_CMAC tt__GetTracksResponseList : public xsd__anyType
{
public:
	std::vector<class tt__GetTracksResponseItem * >Track;	/* optional element of type tt:GetTracksResponseItem */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 569; } /* = unique type id SOAP_TYPE_tt__GetTracksResponseList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GetTracksResponseList() { tt__GetTracksResponseList::soap_default(NULL); }
	virtual ~tt__GetTracksResponseList() { }
};
#endif

#ifndef SOAP_TYPE_tt__GetTracksResponseItem
#define SOAP_TYPE_tt__GetTracksResponseItem (570)
/* tt:GetTracksResponseItem */
class SOAP_CMAC tt__GetTracksResponseItem : public xsd__anyType
{
public:
	std::string TrackToken;	/* required element of type tt:TrackReference */
	tt__TrackConfiguration *Configuration;	/* required element of type tt:TrackConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 570; } /* = unique type id SOAP_TYPE_tt__GetTracksResponseItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GetTracksResponseItem() { tt__GetTracksResponseItem::soap_default(NULL); }
	virtual ~tt__GetTracksResponseItem() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobConfiguration
#define SOAP_TYPE_tt__RecordingJobConfiguration (571)
/* tt:RecordingJobConfiguration */
class SOAP_CMAC tt__RecordingJobConfiguration : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type tt:RecordingReference */
	std::string Mode;	/* required element of type tt:RecordingJobMode */
	int Priority;	/* required element of type xsd:int */
	std::vector<class tt__RecordingJobSource * >Source;	/* optional element of type tt:RecordingJobSource */
	class tt__RecordingJobConfigurationExtension *Extension;	/* optional element of type tt:RecordingJobConfigurationExtension */
	std::string ScheduleToken;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 571; } /* = unique type id SOAP_TYPE_tt__RecordingJobConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobConfiguration() { tt__RecordingJobConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingJobConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobConfigurationExtension
#define SOAP_TYPE_tt__RecordingJobConfigurationExtension (572)
/* tt:RecordingJobConfigurationExtension */
class SOAP_CMAC tt__RecordingJobConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 572; } /* = unique type id SOAP_TYPE_tt__RecordingJobConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobConfigurationExtension() { tt__RecordingJobConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobSource
#define SOAP_TYPE_tt__RecordingJobSource (573)
/* tt:RecordingJobSource */
class SOAP_CMAC tt__RecordingJobSource : public xsd__anyType
{
public:
	tt__SourceReference *SourceToken;	/* optional element of type tt:SourceReference */
	bool *AutoCreateReceiver;	/* optional element of type xsd:boolean */
	std::vector<class tt__RecordingJobTrack * >Tracks;	/* optional element of type tt:RecordingJobTrack */
	class tt__RecordingJobSourceExtension *Extension;	/* optional element of type tt:RecordingJobSourceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 573; } /* = unique type id SOAP_TYPE_tt__RecordingJobSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobSource() { tt__RecordingJobSource::soap_default(NULL); }
	virtual ~tt__RecordingJobSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobSourceExtension
#define SOAP_TYPE_tt__RecordingJobSourceExtension (574)
/* tt:RecordingJobSourceExtension */
class SOAP_CMAC tt__RecordingJobSourceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 574; } /* = unique type id SOAP_TYPE_tt__RecordingJobSourceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobSourceExtension() { tt__RecordingJobSourceExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobSourceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobTrack
#define SOAP_TYPE_tt__RecordingJobTrack (575)
/* tt:RecordingJobTrack */
class SOAP_CMAC tt__RecordingJobTrack : public xsd__anyType
{
public:
	std::string SourceTag;	/* required element of type xsd:string */
	std::string Destination;	/* required element of type tt:TrackReference */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 575; } /* = unique type id SOAP_TYPE_tt__RecordingJobTrack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobTrack() { tt__RecordingJobTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobTrack() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateInformation
#define SOAP_TYPE_tt__RecordingJobStateInformation (576)
/* tt:RecordingJobStateInformation */
class SOAP_CMAC tt__RecordingJobStateInformation : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type tt:RecordingReference */
	std::string State;	/* required element of type tt:RecordingJobState */
	std::vector<class tt__RecordingJobStateSource * >Sources;	/* optional element of type tt:RecordingJobStateSource */
	class tt__RecordingJobStateInformationExtension *Extension;	/* optional element of type tt:RecordingJobStateInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 576; } /* = unique type id SOAP_TYPE_tt__RecordingJobStateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateInformation() { tt__RecordingJobStateInformation::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateInformationExtension
#define SOAP_TYPE_tt__RecordingJobStateInformationExtension (577)
/* tt:RecordingJobStateInformationExtension */
class SOAP_CMAC tt__RecordingJobStateInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 577; } /* = unique type id SOAP_TYPE_tt__RecordingJobStateInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateInformationExtension() { tt__RecordingJobStateInformationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateSource
#define SOAP_TYPE_tt__RecordingJobStateSource (578)
/* tt:RecordingJobStateSource */
class SOAP_CMAC tt__RecordingJobStateSource : public xsd__anyType
{
public:
	tt__SourceReference *SourceToken;	/* required element of type tt:SourceReference */
	std::string State;	/* required element of type tt:RecordingJobState */
	class tt__RecordingJobStateTracks *Tracks;	/* required element of type tt:RecordingJobStateTracks */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 578; } /* = unique type id SOAP_TYPE_tt__RecordingJobStateSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateSource() { tt__RecordingJobStateSource::soap_default(NULL); }
	virtual ~tt__RecordingJobStateSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateTracks
#define SOAP_TYPE_tt__RecordingJobStateTracks (579)
/* tt:RecordingJobStateTracks */
class SOAP_CMAC tt__RecordingJobStateTracks : public xsd__anyType
{
public:
	std::vector<class tt__RecordingJobStateTrack * >Track;	/* optional element of type tt:RecordingJobStateTrack */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 579; } /* = unique type id SOAP_TYPE_tt__RecordingJobStateTracks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateTracks() { tt__RecordingJobStateTracks::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTracks() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateTrack
#define SOAP_TYPE_tt__RecordingJobStateTrack (580)
/* tt:RecordingJobStateTrack */
class SOAP_CMAC tt__RecordingJobStateTrack : public xsd__anyType
{
public:
	std::string SourceTag;	/* required element of type xsd:string */
	std::string Destination;	/* required element of type tt:TrackReference */
	std::string *Error;	/* optional element of type xsd:string */
	std::string State;	/* required element of type tt:RecordingJobState */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 580; } /* = unique type id SOAP_TYPE_tt__RecordingJobStateTrack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateTrack() { tt__RecordingJobStateTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTrack() { }
};
#endif

#ifndef SOAP_TYPE_tt__GetRecordingJobsResponseItem
#define SOAP_TYPE_tt__GetRecordingJobsResponseItem (581)
/* tt:GetRecordingJobsResponseItem */
class SOAP_CMAC tt__GetRecordingJobsResponseItem : public xsd__anyType
{
public:
	std::string JobToken;	/* required element of type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of type tt:RecordingJobConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 581; } /* = unique type id SOAP_TYPE_tt__GetRecordingJobsResponseItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GetRecordingJobsResponseItem() { tt__GetRecordingJobsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingJobsResponseItem() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReplayConfiguration
#define SOAP_TYPE_tt__ReplayConfiguration (582)
/* tt:ReplayConfiguration */
class SOAP_CMAC tt__ReplayConfiguration : public xsd__anyType
{
public:
	LONG64 SessionTimeout;	/* external */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 582; } /* = unique type id SOAP_TYPE_tt__ReplayConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReplayConfiguration() { tt__ReplayConfiguration::soap_default(NULL); }
	virtual ~tt__ReplayConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (584)
/* tt:AnalyticsDeviceEngineConfiguration */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfiguration : public xsd__anyType
{
public:
	std::vector<class tt__EngineConfiguration * >EngineConfiguration;	/* required element of type tt:EngineConfiguration */
	class tt__AnalyticsDeviceEngineConfigurationExtension *Extension;	/* optional element of type tt:AnalyticsDeviceEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 584; } /* = unique type id SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsDeviceEngineConfiguration() { tt__AnalyticsDeviceEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (585)
/* tt:AnalyticsDeviceEngineConfigurationExtension */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 585; } /* = unique type id SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsDeviceEngineConfigurationExtension() { tt__AnalyticsDeviceEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EngineConfiguration
#define SOAP_TYPE_tt__EngineConfiguration (586)
/* tt:EngineConfiguration */
class SOAP_CMAC tt__EngineConfiguration : public xsd__anyType
{
public:
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* required element of type tt:VideoAnalyticsConfiguration */
	class tt__AnalyticsEngineInputInfo *AnalyticsEngineInputInfo;	/* required element of type tt:AnalyticsEngineInputInfo */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 586; } /* = unique type id SOAP_TYPE_tt__EngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EngineConfiguration() { tt__EngineConfiguration::soap_default(NULL); }
	virtual ~tt__EngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfo
#define SOAP_TYPE_tt__AnalyticsEngineInputInfo (587)
/* tt:AnalyticsEngineInputInfo */
class SOAP_CMAC tt__AnalyticsEngineInputInfo : public xsd__anyType
{
public:
	tt__Config *InputInfo;	/* optional element of type tt:Config */
	class tt__AnalyticsEngineInputInfoExtension *Extension;	/* optional element of type tt:AnalyticsEngineInputInfoExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 587; } /* = unique type id SOAP_TYPE_tt__AnalyticsEngineInputInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineInputInfo() { tt__AnalyticsEngineInputInfo::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfo() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (588)
/* tt:AnalyticsEngineInputInfoExtension */
class SOAP_CMAC tt__AnalyticsEngineInputInfoExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 588; } /* = unique type id SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineInputInfoExtension() { tt__AnalyticsEngineInputInfoExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfoExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SourceIdentification
#define SOAP_TYPE_tt__SourceIdentification (590)
/* tt:SourceIdentification */
class SOAP_CMAC tt__SourceIdentification : public xsd__anyType
{
public:
	std::string Name;	/* required element of type xsd:string */
	std::vector<std::string >Token;	/* required element of type tt:ReferenceToken */
	class tt__SourceIdentificationExtension *Extension;	/* optional element of type tt:SourceIdentificationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 590; } /* = unique type id SOAP_TYPE_tt__SourceIdentification */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SourceIdentification() { tt__SourceIdentification::soap_default(NULL); }
	virtual ~tt__SourceIdentification() { }
};
#endif

#ifndef SOAP_TYPE_tt__SourceIdentificationExtension
#define SOAP_TYPE_tt__SourceIdentificationExtension (591)
/* tt:SourceIdentificationExtension */
class SOAP_CMAC tt__SourceIdentificationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 591; } /* = unique type id SOAP_TYPE_tt__SourceIdentificationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SourceIdentificationExtension() { tt__SourceIdentificationExtension::soap_default(NULL); }
	virtual ~tt__SourceIdentificationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataInput
#define SOAP_TYPE_tt__MetadataInput (592)
/* tt:MetadataInput */
class SOAP_CMAC tt__MetadataInput : public xsd__anyType
{
public:
	std::vector<tt__Config * >MetadataConfig;	/* optional element of type tt:Config */
	class tt__MetadataInputExtension *Extension;	/* optional element of type tt:MetadataInputExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 592; } /* = unique type id SOAP_TYPE_tt__MetadataInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataInput() { tt__MetadataInput::soap_default(NULL); }
	virtual ~tt__MetadataInput() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataInputExtension
#define SOAP_TYPE_tt__MetadataInputExtension (593)
/* tt:MetadataInputExtension */
class SOAP_CMAC tt__MetadataInputExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 593; } /* = unique type id SOAP_TYPE_tt__MetadataInputExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataInputExtension() { tt__MetadataInputExtension::soap_default(NULL); }
	virtual ~tt__MetadataInputExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsStateInformation
#define SOAP_TYPE_tt__AnalyticsStateInformation (595)
/* tt:AnalyticsStateInformation */
class SOAP_CMAC tt__AnalyticsStateInformation : public xsd__anyType
{
public:
	std::string AnalyticsEngineControlToken;	/* required element of type tt:ReferenceToken */
	class tt__AnalyticsState *State;	/* required element of type tt:AnalyticsState */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 595; } /* = unique type id SOAP_TYPE_tt__AnalyticsStateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsStateInformation() { tt__AnalyticsStateInformation::soap_default(NULL); }
	virtual ~tt__AnalyticsStateInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsState
#define SOAP_TYPE_tt__AnalyticsState (596)
/* tt:AnalyticsState */
class SOAP_CMAC tt__AnalyticsState : public xsd__anyType
{
public:
	std::string *Error;	/* optional element of type xsd:string */
	std::string State;	/* required element of type xsd:string */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 596; } /* = unique type id SOAP_TYPE_tt__AnalyticsState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsState() { tt__AnalyticsState::soap_default(NULL); }
	virtual ~tt__AnalyticsState() { }
};
#endif

#ifndef SOAP_TYPE_tt__ActionEngineEventPayload
#define SOAP_TYPE_tt__ActionEngineEventPayload (597)
/* tt:ActionEngineEventPayload */
class SOAP_CMAC tt__ActionEngineEventPayload : public xsd__anyType
{
public:
	struct SOAP_ENV__Envelope *RequestInfo;	/* optional element of type SOAP-ENV:Envelope */
	struct SOAP_ENV__Envelope *ResponseInfo;	/* optional element of type SOAP-ENV:Envelope */
	struct SOAP_ENV__Fault *Fault;	/* optional element of type SOAP-ENV:Fault */
	class tt__ActionEngineEventPayloadExtension *Extension;	/* optional element of type tt:ActionEngineEventPayloadExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 597; } /* = unique type id SOAP_TYPE_tt__ActionEngineEventPayload */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ActionEngineEventPayload() { tt__ActionEngineEventPayload::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayload() { }
};
#endif

#ifndef SOAP_TYPE_tt__ActionEngineEventPayloadExtension
#define SOAP_TYPE_tt__ActionEngineEventPayloadExtension (598)
/* tt:ActionEngineEventPayloadExtension */
class SOAP_CMAC tt__ActionEngineEventPayloadExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 598; } /* = unique type id SOAP_TYPE_tt__ActionEngineEventPayloadExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ActionEngineEventPayloadExtension() { tt__ActionEngineEventPayloadExtension::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayloadExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioClassCandidate
#define SOAP_TYPE_tt__AudioClassCandidate (599)
/* tt:AudioClassCandidate */
class SOAP_CMAC tt__AudioClassCandidate : public xsd__anyType
{
public:
	std::string Type;	/* required element of type tt:AudioClassType */
	float Likelihood;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 599; } /* = unique type id SOAP_TYPE_tt__AudioClassCandidate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioClassCandidate() { tt__AudioClassCandidate::soap_default(NULL); }
	virtual ~tt__AudioClassCandidate() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioClassDescriptor
#define SOAP_TYPE_tt__AudioClassDescriptor (600)
/* tt:AudioClassDescriptor */
class SOAP_CMAC tt__AudioClassDescriptor : public xsd__anyType
{
public:
	std::vector<tt__AudioClassCandidate * >ClassCandidate;	/* optional element of type tt:AudioClassCandidate */
	class tt__AudioClassDescriptorExtension *Extension;	/* optional element of type tt:AudioClassDescriptorExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 600; } /* = unique type id SOAP_TYPE_tt__AudioClassDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioClassDescriptor() { tt__AudioClassDescriptor::soap_default(NULL); }
	virtual ~tt__AudioClassDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioClassDescriptorExtension
#define SOAP_TYPE_tt__AudioClassDescriptorExtension (601)
/* tt:AudioClassDescriptorExtension */
class SOAP_CMAC tt__AudioClassDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 601; } /* = unique type id SOAP_TYPE_tt__AudioClassDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioClassDescriptorExtension() { tt__AudioClassDescriptorExtension::soap_default(NULL); }
	virtual ~tt__AudioClassDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ActiveConnection
#define SOAP_TYPE_tt__ActiveConnection (602)
/* tt:ActiveConnection */
class SOAP_CMAC tt__ActiveConnection : public xsd__anyType
{
public:
	float CurrentBitrate;	/* required element of type xsd:float */
	float CurrentFps;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 602; } /* = unique type id SOAP_TYPE_tt__ActiveConnection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ActiveConnection() { tt__ActiveConnection::soap_default(NULL); }
	virtual ~tt__ActiveConnection() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileStatus
#define SOAP_TYPE_tt__ProfileStatus (603)
/* tt:ProfileStatus */
class SOAP_CMAC tt__ProfileStatus : public xsd__anyType
{
public:
	std::vector<tt__ActiveConnection * >ActiveConnections;	/* optional element of type tt:ActiveConnection */
	class tt__ProfileStatusExtension *Extension;	/* optional element of type tt:ProfileStatusExtension */
public:
	virtual int soap_type() const { return 603; } /* = unique type id SOAP_TYPE_tt__ProfileStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileStatus() { tt__ProfileStatus::soap_default(NULL); }
	virtual ~tt__ProfileStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileStatusExtension
#define SOAP_TYPE_tt__ProfileStatusExtension (604)
/* tt:ProfileStatusExtension */
class SOAP_CMAC tt__ProfileStatusExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 604; } /* = unique type id SOAP_TYPE_tt__ProfileStatusExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileStatusExtension() { tt__ProfileStatusExtension::soap_default(NULL); }
	virtual ~tt__ProfileStatusExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDPosConfiguration
#define SOAP_TYPE_tt__OSDPosConfiguration (606)
/* tt:OSDPosConfiguration */
class SOAP_CMAC tt__OSDPosConfiguration : public xsd__anyType
{
public:
	std::string Type;	/* required element of type xsd:string */
	tt__Vector *Pos;	/* optional element of type tt:Vector */
	class tt__OSDPosConfigurationExtension *Extension;	/* optional element of type tt:OSDPosConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 606; } /* = unique type id SOAP_TYPE_tt__OSDPosConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDPosConfiguration() { tt__OSDPosConfiguration::soap_default(NULL); }
	virtual ~tt__OSDPosConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDPosConfigurationExtension
#define SOAP_TYPE_tt__OSDPosConfigurationExtension (607)
/* tt:OSDPosConfigurationExtension */
class SOAP_CMAC tt__OSDPosConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 607; } /* = unique type id SOAP_TYPE_tt__OSDPosConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDPosConfigurationExtension() { tt__OSDPosConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDPosConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDColor
#define SOAP_TYPE_tt__OSDColor (608)
/* tt:OSDColor */
class SOAP_CMAC tt__OSDColor : public xsd__anyType
{
public:
	class tt__Color *Color;	/* required element of type tt:Color */
	int *Transparent;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 608; } /* = unique type id SOAP_TYPE_tt__OSDColor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDColor() { tt__OSDColor::soap_default(NULL); }
	virtual ~tt__OSDColor() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDTextConfiguration
#define SOAP_TYPE_tt__OSDTextConfiguration (609)
/* tt:OSDTextConfiguration */
class SOAP_CMAC tt__OSDTextConfiguration : public xsd__anyType
{
public:
	std::string Type;	/* required element of type xsd:string */
	std::string *DateFormat;	/* optional element of type xsd:string */
	std::string *TimeFormat;	/* optional element of type xsd:string */
	int *FontSize;	/* optional element of type xsd:int */
	tt__OSDColor *FontColor;	/* optional element of type tt:OSDColor */
	tt__OSDColor *BackgroundColor;	/* optional element of type tt:OSDColor */
	std::string *PlainText;	/* optional element of type xsd:string */
	class tt__OSDTextConfigurationExtension *Extension;	/* optional element of type tt:OSDTextConfigurationExtension */
	bool *IsPersistentText;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 609; } /* = unique type id SOAP_TYPE_tt__OSDTextConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDTextConfiguration() { tt__OSDTextConfiguration::soap_default(NULL); }
	virtual ~tt__OSDTextConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDTextConfigurationExtension
#define SOAP_TYPE_tt__OSDTextConfigurationExtension (610)
/* tt:OSDTextConfigurationExtension */
class SOAP_CMAC tt__OSDTextConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 610; } /* = unique type id SOAP_TYPE_tt__OSDTextConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDTextConfigurationExtension() { tt__OSDTextConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDTextConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDImgConfiguration
#define SOAP_TYPE_tt__OSDImgConfiguration (611)
/* tt:OSDImgConfiguration */
class SOAP_CMAC tt__OSDImgConfiguration : public xsd__anyType
{
public:
	std::string ImgPath;	/* required element of type xsd:anyURI */
	class tt__OSDImgConfigurationExtension *Extension;	/* optional element of type tt:OSDImgConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 611; } /* = unique type id SOAP_TYPE_tt__OSDImgConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDImgConfiguration() { tt__OSDImgConfiguration::soap_default(NULL); }
	virtual ~tt__OSDImgConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDImgConfigurationExtension
#define SOAP_TYPE_tt__OSDImgConfigurationExtension (612)
/* tt:OSDImgConfigurationExtension */
class SOAP_CMAC tt__OSDImgConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 612; } /* = unique type id SOAP_TYPE_tt__OSDImgConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDImgConfigurationExtension() { tt__OSDImgConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDImgConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ColorspaceRange
#define SOAP_TYPE_tt__ColorspaceRange (613)
/* tt:ColorspaceRange */
class SOAP_CMAC tt__ColorspaceRange : public xsd__anyType
{
public:
	tt__FloatRange *X;	/* required element of type tt:FloatRange */
	tt__FloatRange *Y;	/* required element of type tt:FloatRange */
	tt__FloatRange *Z;	/* required element of type tt:FloatRange */
	std::string Colorspace;	/* required element of type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 613; } /* = unique type id SOAP_TYPE_tt__ColorspaceRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorspaceRange() { tt__ColorspaceRange::soap_default(NULL); }
	virtual ~tt__ColorspaceRange() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_ColorOptions
#define SOAP_TYPE__tt__union_ColorOptions (1406)
/* xsd:choice */
union _tt__union_ColorOptions
{
#define SOAP_UNION__tt__union_ColorOptions_ColorList	(1)
	std::vector<tt__Color * >*ColorList;
#define SOAP_UNION__tt__union_ColorOptions_ColorspaceRange	(2)
	std::vector<tt__ColorspaceRange * >*ColorspaceRange;
};
#endif

#ifndef SOAP_TYPE_tt__ColorOptions
#define SOAP_TYPE_tt__ColorOptions (614)
/* tt:ColorOptions */
class SOAP_CMAC tt__ColorOptions : public xsd__anyType
{
public:
	int __union_ColorOptions;	/* union discriminant (of union defined below) */
	union _tt__union_ColorOptions union_ColorOptions;	/* required element of type xsd:choice */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 614; } /* = unique type id SOAP_TYPE_tt__ColorOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorOptions() { tt__ColorOptions::soap_default(NULL); }
	virtual ~tt__ColorOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDColorOptions
#define SOAP_TYPE_tt__OSDColorOptions (615)
/* tt:OSDColorOptions */
class SOAP_CMAC tt__OSDColorOptions : public xsd__anyType
{
public:
	tt__ColorOptions *Color;	/* optional element of type tt:ColorOptions */
	tt__IntRange *Transparent;	/* optional element of type tt:IntRange */
	class tt__OSDColorOptionsExtension *Extension;	/* optional element of type tt:OSDColorOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 615; } /* = unique type id SOAP_TYPE_tt__OSDColorOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDColorOptions() { tt__OSDColorOptions::soap_default(NULL); }
	virtual ~tt__OSDColorOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDColorOptionsExtension
#define SOAP_TYPE_tt__OSDColorOptionsExtension (616)
/* tt:OSDColorOptionsExtension */
class SOAP_CMAC tt__OSDColorOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 616; } /* = unique type id SOAP_TYPE_tt__OSDColorOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDColorOptionsExtension() { tt__OSDColorOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDColorOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDTextOptions
#define SOAP_TYPE_tt__OSDTextOptions (617)
/* tt:OSDTextOptions */
class SOAP_CMAC tt__OSDTextOptions : public xsd__anyType
{
public:
	std::vector<std::string >Type;	/* required element of type xsd:string */
	tt__IntRange *FontSizeRange;	/* optional element of type tt:IntRange */
	std::vector<std::string >DateFormat;	/* optional element of type xsd:string */
	std::vector<std::string >TimeFormat;	/* optional element of type xsd:string */
	tt__OSDColorOptions *FontColor;	/* optional element of type tt:OSDColorOptions */
	tt__OSDColorOptions *BackgroundColor;	/* optional element of type tt:OSDColorOptions */
	class tt__OSDTextOptionsExtension *Extension;	/* optional element of type tt:OSDTextOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 617; } /* = unique type id SOAP_TYPE_tt__OSDTextOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDTextOptions() { tt__OSDTextOptions::soap_default(NULL); }
	virtual ~tt__OSDTextOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDTextOptionsExtension
#define SOAP_TYPE_tt__OSDTextOptionsExtension (618)
/* tt:OSDTextOptionsExtension */
class SOAP_CMAC tt__OSDTextOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 618; } /* = unique type id SOAP_TYPE_tt__OSDTextOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDTextOptionsExtension() { tt__OSDTextOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDTextOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDImgOptions
#define SOAP_TYPE_tt__OSDImgOptions (619)
/* tt:OSDImgOptions */
class SOAP_CMAC tt__OSDImgOptions : public xsd__anyType
{
public:
	std::vector<std::string >ImagePath;	/* required element of type xsd:anyURI */
	class tt__OSDImgOptionsExtension *Extension;	/* optional element of type tt:OSDImgOptionsExtension */
	std::string *FormatsSupported;	/* optional attribute */
	int *MaxSize;	/* optional attribute */
	int *MaxWidth;	/* optional attribute */
	int *MaxHeight;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 619; } /* = unique type id SOAP_TYPE_tt__OSDImgOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDImgOptions() { tt__OSDImgOptions::soap_default(NULL); }
	virtual ~tt__OSDImgOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDImgOptionsExtension
#define SOAP_TYPE_tt__OSDImgOptionsExtension (620)
/* tt:OSDImgOptionsExtension */
class SOAP_CMAC tt__OSDImgOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 620; } /* = unique type id SOAP_TYPE_tt__OSDImgOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDImgOptionsExtension() { tt__OSDImgOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDImgOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDConfigurationExtension
#define SOAP_TYPE_tt__OSDConfigurationExtension (622)
/* tt:OSDConfigurationExtension */
class SOAP_CMAC tt__OSDConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 622; } /* = unique type id SOAP_TYPE_tt__OSDConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDConfigurationExtension() { tt__OSDConfigurationExtension::soap_default(NULL); }
	virtual ~tt__OSDConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MaximumNumberOfOSDs
#define SOAP_TYPE_tt__MaximumNumberOfOSDs (623)
/* Primitive tt:MaximumNumberOfOSDs schema type: */
class SOAP_CMAC tt__MaximumNumberOfOSDs : public xsd__anyType
{
public:
	int Total;	/* required attribute */
	int *Image;	/* optional attribute */
	int *PlainText;	/* optional attribute */
	int *Date;	/* optional attribute */
	int *Time;	/* optional attribute */
	int *DateAndTime;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 623; } /* = unique type id SOAP_TYPE_tt__MaximumNumberOfOSDs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MaximumNumberOfOSDs() { tt__MaximumNumberOfOSDs::soap_default(NULL); }
	virtual ~tt__MaximumNumberOfOSDs() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDConfigurationOptions
#define SOAP_TYPE_tt__OSDConfigurationOptions (624)
/* tt:OSDConfigurationOptions */
class SOAP_CMAC tt__OSDConfigurationOptions : public xsd__anyType
{
public:
	tt__MaximumNumberOfOSDs *MaximumNumberOfOSDs;	/* required element of type tt:MaximumNumberOfOSDs */
	std::vector<enum tt__OSDType >Type;	/* required element of type tt:OSDType */
	std::vector<std::string >PositionOption;	/* required element of type xsd:string */
	tt__OSDTextOptions *TextOption;	/* optional element of type tt:OSDTextOptions */
	tt__OSDImgOptions *ImageOption;	/* optional element of type tt:OSDImgOptions */
	class tt__OSDConfigurationOptionsExtension *Extension;	/* optional element of type tt:OSDConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 624; } /* = unique type id SOAP_TYPE_tt__OSDConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDConfigurationOptions() { tt__OSDConfigurationOptions::soap_default(NULL); }
	virtual ~tt__OSDConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDConfigurationOptionsExtension
#define SOAP_TYPE_tt__OSDConfigurationOptionsExtension (625)
/* tt:OSDConfigurationOptionsExtension */
class SOAP_CMAC tt__OSDConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 625; } /* = unique type id SOAP_TYPE_tt__OSDConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDConfigurationOptionsExtension() { tt__OSDConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__OSDConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FileProgress
#define SOAP_TYPE_tt__FileProgress (626)
/* tt:FileProgress */
class SOAP_CMAC tt__FileProgress : public xsd__anyType
{
public:
	std::string FileName;	/* required element of type xsd:string */
	float Progress;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 626; } /* = unique type id SOAP_TYPE_tt__FileProgress */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FileProgress() { tt__FileProgress::soap_default(NULL); }
	virtual ~tt__FileProgress() { }
};
#endif

#ifndef SOAP_TYPE_tt__ArrayOfFileProgress
#define SOAP_TYPE_tt__ArrayOfFileProgress (627)
/* tt:ArrayOfFileProgress */
class SOAP_CMAC tt__ArrayOfFileProgress : public xsd__anyType
{
public:
	std::vector<tt__FileProgress * >FileProgress;	/* optional element of type tt:FileProgress */
	class tt__ArrayOfFileProgressExtension *Extension;	/* optional element of type tt:ArrayOfFileProgressExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 627; } /* = unique type id SOAP_TYPE_tt__ArrayOfFileProgress */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ArrayOfFileProgress() { tt__ArrayOfFileProgress::soap_default(NULL); }
	virtual ~tt__ArrayOfFileProgress() { }
};
#endif

#ifndef SOAP_TYPE_tt__ArrayOfFileProgressExtension
#define SOAP_TYPE_tt__ArrayOfFileProgressExtension (628)
/* tt:ArrayOfFileProgressExtension */
class SOAP_CMAC tt__ArrayOfFileProgressExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 628; } /* = unique type id SOAP_TYPE_tt__ArrayOfFileProgressExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ArrayOfFileProgressExtension() { tt__ArrayOfFileProgressExtension::soap_default(NULL); }
	virtual ~tt__ArrayOfFileProgressExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__StorageReferencePath
#define SOAP_TYPE_tt__StorageReferencePath (629)
/* tt:StorageReferencePath */
class SOAP_CMAC tt__StorageReferencePath : public xsd__anyType
{
public:
	std::string StorageToken;	/* required element of type tt:ReferenceToken */
	std::string *RelativePath;	/* optional element of type xsd:string */
	class tt__StorageReferencePathExtension *Extension;	/* optional element of type tt:StorageReferencePathExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 629; } /* = unique type id SOAP_TYPE_tt__StorageReferencePath */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__StorageReferencePath() { tt__StorageReferencePath::soap_default(NULL); }
	virtual ~tt__StorageReferencePath() { }
};
#endif

#ifndef SOAP_TYPE_tt__StorageReferencePathExtension
#define SOAP_TYPE_tt__StorageReferencePathExtension (630)
/* tt:StorageReferencePathExtension */
class SOAP_CMAC tt__StorageReferencePathExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 630; } /* = unique type id SOAP_TYPE_tt__StorageReferencePathExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__StorageReferencePathExtension() { tt__StorageReferencePathExtension::soap_default(NULL); }
	virtual ~tt__StorageReferencePathExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (631)
/* tt:IntRange */
class SOAP_CMAC tt__IntRange : public xsd__anyType
{
public:
	int Min;	/* required element of type xsd:int */
	int Max;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 631; } /* = unique type id SOAP_TYPE_tt__IntRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntRange() { tt__IntRange::soap_default(NULL); }
	virtual ~tt__IntRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (632)
/* Primitive tt:Vector2D schema type: */
class SOAP_CMAC tt__Vector2D : public xsd__anyType
{
public:
	float x;	/* required attribute */
	float y;	/* required attribute */
	std::string *space;	/* optional attribute */
public:
	virtual int soap_type() const { return 632; } /* = unique type id SOAP_TYPE_tt__Vector2D */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Vector2D() { tt__Vector2D::soap_default(NULL); }
	virtual ~tt__Vector2D() { }
};
#endif

#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (633)
/* Primitive tt:Vector1D schema type: */
class SOAP_CMAC tt__Vector1D : public xsd__anyType
{
public:
	float x;	/* required attribute */
	std::string *space;	/* optional attribute */
public:
	virtual int soap_type() const { return 633; } /* = unique type id SOAP_TYPE_tt__Vector1D */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Vector1D() { tt__Vector1D::soap_default(NULL); }
	virtual ~tt__Vector1D() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (634)
/* tt:PTZVector */
class SOAP_CMAC tt__PTZVector : public xsd__anyType
{
public:
	tt__Vector2D *PanTilt;	/* optional element of type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of type tt:Vector1D */
public:
	virtual int soap_type() const { return 634; } /* = unique type id SOAP_TYPE_tt__PTZVector */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZVector() { tt__PTZVector::soap_default(NULL); }
	virtual ~tt__PTZVector() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (635)
/* tt:PTZStatus */
class SOAP_CMAC tt__PTZStatus : public xsd__anyType
{
public:
	tt__PTZVector *Position;	/* optional element of type tt:PTZVector */
	class tt__PTZMoveStatus *MoveStatus;	/* optional element of type tt:PTZMoveStatus */
	std::string *Error;	/* optional element of type xsd:string */
	time_t UtcTime;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 635; } /* = unique type id SOAP_TYPE_tt__PTZStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStatus() { tt__PTZStatus::soap_default(NULL); }
	virtual ~tt__PTZStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (636)
/* tt:PTZMoveStatus */
class SOAP_CMAC tt__PTZMoveStatus : public xsd__anyType
{
public:
	enum tt__MoveStatus *PanTilt;	/* optional element of type tt:MoveStatus */
	enum tt__MoveStatus *Zoom;	/* optional element of type tt:MoveStatus */
public:
	virtual int soap_type() const { return 636; } /* = unique type id SOAP_TYPE_tt__PTZMoveStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZMoveStatus() { tt__PTZMoveStatus::soap_default(NULL); }
	virtual ~tt__PTZMoveStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (637)
/* Primitive tt:Vector schema type: */
class SOAP_CMAC tt__Vector : public xsd__anyType
{
public:
	float *x;	/* optional attribute */
	float *y;	/* optional attribute */
public:
	virtual int soap_type() const { return 637; } /* = unique type id SOAP_TYPE_tt__Vector */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Vector() { tt__Vector::soap_default(NULL); }
	virtual ~tt__Vector() { }
};
#endif

#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (638)
/* Primitive tt:Rectangle schema type: */
class SOAP_CMAC tt__Rectangle : public xsd__anyType
{
public:
	float *bottom;	/* optional attribute */
	float *top;	/* optional attribute */
	float *right;	/* optional attribute */
	float *left;	/* optional attribute */
public:
	virtual int soap_type() const { return 638; } /* = unique type id SOAP_TYPE_tt__Rectangle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Rectangle() { tt__Rectangle::soap_default(NULL); }
	virtual ~tt__Rectangle() { }
};
#endif

#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (639)
/* tt:Polygon */
class SOAP_CMAC tt__Polygon : public xsd__anyType
{
public:
	std::vector<tt__Vector * >Point;	/* required element of type tt:Vector */
public:
	virtual int soap_type() const { return 639; } /* = unique type id SOAP_TYPE_tt__Polygon */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Polygon() { tt__Polygon::soap_default(NULL); }
	virtual ~tt__Polygon() { }
};
#endif

#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (640)
/* Primitive tt:Color schema type: */
class SOAP_CMAC tt__Color : public xsd__anyType
{
public:
	float X;	/* required attribute */
	float Y;	/* required attribute */
	float Z;	/* required attribute */
	std::string *Colorspace;	/* optional attribute */
public:
	virtual int soap_type() const { return 640; } /* = unique type id SOAP_TYPE_tt__Color */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Color() { tt__Color::soap_default(NULL); }
	virtual ~tt__Color() { }
};
#endif

#ifndef SOAP_TYPE_tt__ColorCovariance
#define SOAP_TYPE_tt__ColorCovariance (641)
/* Primitive tt:ColorCovariance schema type: */
class SOAP_CMAC tt__ColorCovariance : public xsd__anyType
{
public:
	float XX;	/* required attribute */
	float YY;	/* required attribute */
	float ZZ;	/* required attribute */
	float *XY;	/* optional attribute */
	float *XZ;	/* optional attribute */
	float *YZ;	/* optional attribute */
	std::string *Colorspace;	/* optional attribute */
public:
	virtual int soap_type() const { return 641; } /* = unique type id SOAP_TYPE_tt__ColorCovariance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorCovariance() { tt__ColorCovariance::soap_default(NULL); }
	virtual ~tt__ColorCovariance() { }
};
#endif

#ifndef SOAP_TYPE__tt__ColorDescriptor_ColorCluster
#define SOAP_TYPE__tt__ColorDescriptor_ColorCluster (1424)
/* tt:ColorDescriptor-ColorCluster */
class SOAP_CMAC _tt__ColorDescriptor_ColorCluster
{
public:
	tt__Color *Color;	/* required element of type tt:Color */
	float *Weight;	/* optional element of type xsd:float */
	tt__ColorCovariance *Covariance;	/* optional element of type tt:ColorCovariance */
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1424; } /* = unique type id SOAP_TYPE__tt__ColorDescriptor_ColorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ColorDescriptor_ColorCluster() { _tt__ColorDescriptor_ColorCluster::soap_default(NULL); }
	virtual ~_tt__ColorDescriptor_ColorCluster() { }
};
#endif

#ifndef SOAP_TYPE_tt__ColorDescriptor
#define SOAP_TYPE_tt__ColorDescriptor (642)
/* tt:ColorDescriptor */
class SOAP_CMAC tt__ColorDescriptor : public xsd__anyType
{
public:
	std::vector<_tt__ColorDescriptor_ColorCluster >*ColorCluster;	/* optional element of type tt:ColorDescriptor-ColorCluster */
	xsd__anyType *Extension;	/* optional element of type xsd:anyType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 642; } /* = unique type id SOAP_TYPE_tt__ColorDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorDescriptor() { tt__ColorDescriptor::soap_default(NULL); }
	virtual ~tt__ColorDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_tt__Transformation
#define SOAP_TYPE_tt__Transformation (643)
/* tt:Transformation */
class SOAP_CMAC tt__Transformation : public xsd__anyType
{
public:
	tt__Vector *Translate;	/* optional element of type tt:Vector */
	tt__Vector *Scale;	/* optional element of type tt:Vector */
	class tt__TransformationExtension *Extension;	/* optional element of type tt:TransformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 643; } /* = unique type id SOAP_TYPE_tt__Transformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Transformation() { tt__Transformation::soap_default(NULL); }
	virtual ~tt__Transformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__TransformationExtension
#define SOAP_TYPE_tt__TransformationExtension (644)
/* tt:TransformationExtension */
class SOAP_CMAC tt__TransformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 644; } /* = unique type id SOAP_TYPE_tt__TransformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TransformationExtension() { tt__TransformationExtension::soap_default(NULL); }
	virtual ~tt__TransformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__GeoLocation
#define SOAP_TYPE_tt__GeoLocation (645)
/* tt:GeoLocation */
class SOAP_CMAC tt__GeoLocation : public xsd__anyType
{
public:
	std::vector<char * >__any;
	double *lon;	/* optional attribute */
	double *lat;	/* optional attribute */
	float *elevation;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 645; } /* = unique type id SOAP_TYPE_tt__GeoLocation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GeoLocation() { tt__GeoLocation::soap_default(NULL); }
	virtual ~tt__GeoLocation() { }
};
#endif

#ifndef SOAP_TYPE_tt__GeoOrientation
#define SOAP_TYPE_tt__GeoOrientation (646)
/* tt:GeoOrientation */
class SOAP_CMAC tt__GeoOrientation : public xsd__anyType
{
public:
	std::vector<char * >__any;
	float *roll;	/* optional attribute */
	float *pitch;	/* optional attribute */
	float *yaw;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 646; } /* = unique type id SOAP_TYPE_tt__GeoOrientation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GeoOrientation() { tt__GeoOrientation::soap_default(NULL); }
	virtual ~tt__GeoOrientation() { }
};
#endif

#ifndef SOAP_TYPE_tt__LocalLocation
#define SOAP_TYPE_tt__LocalLocation (647)
/* tt:LocalLocation */
class SOAP_CMAC tt__LocalLocation : public xsd__anyType
{
public:
	std::vector<char * >__any;
	float *x;	/* optional attribute */
	float *y;	/* optional attribute */
	float *z;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 647; } /* = unique type id SOAP_TYPE_tt__LocalLocation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LocalLocation() { tt__LocalLocation::soap_default(NULL); }
	virtual ~tt__LocalLocation() { }
};
#endif

#ifndef SOAP_TYPE_tt__LocalOrientation
#define SOAP_TYPE_tt__LocalOrientation (648)
/* tt:LocalOrientation */
class SOAP_CMAC tt__LocalOrientation : public xsd__anyType
{
public:
	std::vector<char * >__any;
	float *pan;	/* optional attribute */
	float *tilt;	/* optional attribute */
	float *roll;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 648; } /* = unique type id SOAP_TYPE_tt__LocalOrientation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LocalOrientation() { tt__LocalOrientation::soap_default(NULL); }
	virtual ~tt__LocalOrientation() { }
};
#endif

#ifndef SOAP_TYPE_tt__LocationEntity
#define SOAP_TYPE_tt__LocationEntity (649)
/* tt:LocationEntity */
class SOAP_CMAC tt__LocationEntity : public xsd__anyType
{
public:
	tt__GeoLocation *GeoLocation;	/* optional element of type tt:GeoLocation */
	tt__GeoOrientation *GeoOrientation;	/* optional element of type tt:GeoOrientation */
	tt__LocalLocation *LocalLocation;	/* optional element of type tt:LocalLocation */
	tt__LocalOrientation *LocalOrientation;	/* optional element of type tt:LocalOrientation */
	std::string *Entity;	/* optional attribute */
	std::string *Token;	/* optional attribute */
	bool *Fixed;	/* optional attribute */
	std::string *GeoSource;	/* optional attribute */
	bool *AutoGeo;	/* optional attribute */
public:
	virtual int soap_type() const { return 649; } /* = unique type id SOAP_TYPE_tt__LocationEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LocationEntity() { tt__LocationEntity::soap_default(NULL); }
	virtual ~tt__LocationEntity() { }
};
#endif

#ifndef SOAP_TYPE__tt__StringItems
#define SOAP_TYPE__tt__StringItems (650)
/* tt:StringItems */
class SOAP_CMAC _tt__StringItems
{
public:
	std::vector<std::string >Item;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 650; } /* = unique type id SOAP_TYPE__tt__StringItems */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__StringItems() { _tt__StringItems::soap_default(NULL); }
	virtual ~_tt__StringItems() { }
};
#endif

#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (651)
/* tt:Message */
class SOAP_CMAC _tt__Message
{
public:
	tt__ItemList *Source;	/* optional element of type tt:ItemList */
	tt__ItemList *Key;	/* optional element of type tt:ItemList */
	tt__ItemList *Data;	/* optional element of type tt:ItemList */
	tt__MessageExtension *Extension;	/* optional element of type tt:MessageExtension */
	time_t UtcTime;	/* required attribute */
	enum tt__PropertyOperation *PropertyOperation;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 651; } /* = unique type id SOAP_TYPE__tt__Message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__Message() { _tt__Message::soap_default(NULL); }
	virtual ~_tt__Message() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (652)
/* wsnt:QueryExpressionType */
class SOAP_CMAC wsnt__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 652; } /* = unique type id SOAP_TYPE_wsnt__QueryExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__QueryExpressionType() { wsnt__QueryExpressionType::soap_default(NULL); }
	virtual ~wsnt__QueryExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (653)
/* wsnt:TopicExpressionType */
class SOAP_CMAC wsnt__TopicExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 653; } /* = unique type id SOAP_TYPE_wsnt__TopicExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__TopicExpressionType() { wsnt__TopicExpressionType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (654)
/* wsnt:FilterType */
class SOAP_CMAC wsnt__FilterType : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 654; } /* = unique type id SOAP_TYPE_wsnt__FilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__FilterType() { wsnt__FilterType::soap_default(NULL); }
	virtual ~wsnt__FilterType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (655)
/* wsnt:SubscriptionPolicyType */
class SOAP_CMAC wsnt__SubscriptionPolicyType : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 655; } /* = unique type id SOAP_TYPE_wsnt__SubscriptionPolicyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__SubscriptionPolicyType() { wsnt__SubscriptionPolicyType::soap_default(NULL); }
	virtual ~wsnt__SubscriptionPolicyType() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1439)
/* wsnt:NotificationMessageHolderType-Message */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1439; } /* = unique type id SOAP_TYPE__wsnt__NotificationMessageHolderType_Message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__NotificationMessageHolderType_Message() { _wsnt__NotificationMessageHolderType_Message::soap_default(NULL); }
	virtual ~_wsnt__NotificationMessageHolderType_Message() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (656)
/* wsnt:NotificationMessageHolderType */
class SOAP_CMAC wsnt__NotificationMessageHolderType : public xsd__anyType
{
public:
	struct wsa5__EndpointReferenceType *SubscriptionReference;	/* optional element of type wsa5:EndpointReferenceType */
	wsnt__TopicExpressionType *Topic;	/* optional element of type wsnt:TopicExpressionType */
	struct wsa5__EndpointReferenceType *ProducerReference;	/* optional element of type wsa5:EndpointReferenceType */
	_wsnt__NotificationMessageHolderType_Message Message;	/* required element of type wsnt:NotificationMessageHolderType-Message */
public:
	virtual int soap_type() const { return 656; } /* = unique type id SOAP_TYPE_wsnt__NotificationMessageHolderType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__NotificationMessageHolderType() { wsnt__NotificationMessageHolderType::soap_default(NULL); }
	virtual ~wsnt__NotificationMessageHolderType() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (677)
/* wsnt:NotificationProducerRP */
class SOAP_CMAC _wsnt__NotificationProducerRP
{
public:
	std::vector<wsnt__TopicExpressionType * >TopicExpression;	/* optional element of type wsnt:TopicExpressionType */
	bool *FixedTopicSet;	/* optional element of type xsd:boolean */
	std::vector<std::string >TopicExpressionDialect;	/* optional element of type xsd:anyURI */
	class wstop__TopicSetType *wstop__TopicSet;	/* optional element of type wstop:TopicSetType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 677; } /* = unique type id SOAP_TYPE__wsnt__NotificationProducerRP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__NotificationProducerRP() { _wsnt__NotificationProducerRP::soap_default(NULL); }
	virtual ~_wsnt__NotificationProducerRP() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (678)
/* wsnt:SubscriptionManagerRP */
class SOAP_CMAC _wsnt__SubscriptionManagerRP
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of type wsnt:FilterType */
	wsnt__SubscriptionPolicyType *SubscriptionPolicy;	/* optional element of type wsnt:SubscriptionPolicyType */
	time_t *CreationTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 678; } /* = unique type id SOAP_TYPE__wsnt__SubscriptionManagerRP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__SubscriptionManagerRP() { _wsnt__SubscriptionManagerRP::soap_default(NULL); }
	virtual ~_wsnt__SubscriptionManagerRP() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (679)
/* wsnt:Notify */
class SOAP_CMAC _wsnt__Notify
{
public:
	std::vector<wsnt__NotificationMessageHolderType * >NotificationMessage;	/* required element of type wsnt:NotificationMessageHolderType */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 679; } /* = unique type id SOAP_TYPE__wsnt__Notify */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Notify() { _wsnt__Notify::soap_default(NULL); }
	virtual ~_wsnt__Notify() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (680)
/* wsnt:UseRaw */
class SOAP_CMAC _wsnt__UseRaw
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 680; } /* = unique type id SOAP_TYPE__wsnt__UseRaw */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__UseRaw() { _wsnt__UseRaw::soap_default(NULL); }
	virtual ~_wsnt__UseRaw() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1445)
/* wsnt:Subscribe-SubscriptionPolicy */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1445; } /* = unique type id SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Subscribe_SubscriptionPolicy() { _wsnt__Subscribe_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (681)
/* wsnt:Subscribe */
class SOAP_CMAC _wsnt__Subscribe
{
public:
	struct wsa5__EndpointReferenceType ConsumerReference;	/* required element of type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of type wsnt:FilterType */
	std::string *InitialTerminationTime;	/* optional element of type wsnt:AbsoluteOrRelativeTimeType */
	_wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of type wsnt:Subscribe-SubscriptionPolicy */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 681; } /* = unique type id SOAP_TYPE__wsnt__Subscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Subscribe() { _wsnt__Subscribe::soap_default(NULL); }
	virtual ~_wsnt__Subscribe() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (682)
/* wsnt:SubscribeResponse */
class SOAP_CMAC _wsnt__SubscribeResponse
{
public:
	struct wsa5__EndpointReferenceType SubscriptionReference;	/* required element of type wsa5:EndpointReferenceType */
	time_t *CurrentTime;	/* optional element of type xsd:dateTime */
	time_t *TerminationTime;	/* optional element of type xsd:dateTime */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 682; } /* = unique type id SOAP_TYPE__wsnt__SubscribeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__SubscribeResponse() { _wsnt__SubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__SubscribeResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (683)
/* wsnt:GetCurrentMessage */
class SOAP_CMAC _wsnt__GetCurrentMessage
{
public:
	wsnt__TopicExpressionType *Topic;	/* required element of type wsnt:TopicExpressionType */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 683; } /* = unique type id SOAP_TYPE__wsnt__GetCurrentMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__GetCurrentMessage() { _wsnt__GetCurrentMessage::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessage() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (684)
/* wsnt:GetCurrentMessageResponse */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 684; } /* = unique type id SOAP_TYPE__wsnt__GetCurrentMessageResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__GetCurrentMessageResponse() { _wsnt__GetCurrentMessageResponse::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessageResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (685)
/* wsnt:GetMessages */
class SOAP_CMAC _wsnt__GetMessages
{
public:
	std::string *MaximumNumber;	/* optional element of type xsd:nonNegativeInteger */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 685; } /* = unique type id SOAP_TYPE__wsnt__GetMessages */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__GetMessages() { _wsnt__GetMessages::soap_default(NULL); }
	virtual ~_wsnt__GetMessages() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (686)
/* wsnt:GetMessagesResponse */
class SOAP_CMAC _wsnt__GetMessagesResponse
{
public:
	std::vector<wsnt__NotificationMessageHolderType * >NotificationMessage;	/* optional element of type wsnt:NotificationMessageHolderType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 686; } /* = unique type id SOAP_TYPE__wsnt__GetMessagesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__GetMessagesResponse() { _wsnt__GetMessagesResponse::soap_default(NULL); }
	virtual ~_wsnt__GetMessagesResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (687)
/* wsnt:DestroyPullPoint */
class SOAP_CMAC _wsnt__DestroyPullPoint
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 687; } /* = unique type id SOAP_TYPE__wsnt__DestroyPullPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__DestroyPullPoint() { _wsnt__DestroyPullPoint::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPoint() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (688)
/* wsnt:DestroyPullPointResponse */
class SOAP_CMAC _wsnt__DestroyPullPointResponse
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 688; } /* = unique type id SOAP_TYPE__wsnt__DestroyPullPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__DestroyPullPointResponse() { _wsnt__DestroyPullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (689)
/* wsnt:CreatePullPoint */
class SOAP_CMAC _wsnt__CreatePullPoint
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 689; } /* = unique type id SOAP_TYPE__wsnt__CreatePullPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__CreatePullPoint() { _wsnt__CreatePullPoint::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPoint() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (690)
/* wsnt:CreatePullPointResponse */
class SOAP_CMAC _wsnt__CreatePullPointResponse
{
public:
	struct wsa5__EndpointReferenceType PullPoint;	/* required element of type wsa5:EndpointReferenceType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 690; } /* = unique type id SOAP_TYPE__wsnt__CreatePullPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__CreatePullPointResponse() { _wsnt__CreatePullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (691)
/* wsnt:Renew */
class SOAP_CMAC _wsnt__Renew
{
public:
	std::string *TerminationTime;	/* required element of type wsnt:AbsoluteOrRelativeTimeType */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 691; } /* = unique type id SOAP_TYPE__wsnt__Renew */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Renew() { _wsnt__Renew::soap_default(NULL); }
	virtual ~_wsnt__Renew() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (692)
/* wsnt:RenewResponse */
class SOAP_CMAC _wsnt__RenewResponse
{
public:
	time_t TerminationTime;	/* required element of type xsd:dateTime */
	time_t *CurrentTime;	/* optional element of type xsd:dateTime */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 692; } /* = unique type id SOAP_TYPE__wsnt__RenewResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__RenewResponse() { _wsnt__RenewResponse::soap_default(NULL); }
	virtual ~_wsnt__RenewResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (693)
/* wsnt:Unsubscribe */
class SOAP_CMAC _wsnt__Unsubscribe
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 693; } /* = unique type id SOAP_TYPE__wsnt__Unsubscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Unsubscribe() { _wsnt__Unsubscribe::soap_default(NULL); }
	virtual ~_wsnt__Unsubscribe() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (694)
/* wsnt:UnsubscribeResponse */
class SOAP_CMAC _wsnt__UnsubscribeResponse
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 694; } /* = unique type id SOAP_TYPE__wsnt__UnsubscribeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__UnsubscribeResponse() { _wsnt__UnsubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__UnsubscribeResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (695)
/* wsnt:PauseSubscription */
class SOAP_CMAC _wsnt__PauseSubscription
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 695; } /* = unique type id SOAP_TYPE__wsnt__PauseSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__PauseSubscription() { _wsnt__PauseSubscription::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscription() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (696)
/* wsnt:PauseSubscriptionResponse */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 696; } /* = unique type id SOAP_TYPE__wsnt__PauseSubscriptionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__PauseSubscriptionResponse() { _wsnt__PauseSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscriptionResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (697)
/* wsnt:ResumeSubscription */
class SOAP_CMAC _wsnt__ResumeSubscription
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 697; } /* = unique type id SOAP_TYPE__wsnt__ResumeSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__ResumeSubscription() { _wsnt__ResumeSubscription::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscription() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (698)
/* wsnt:ResumeSubscriptionResponse */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 698; } /* = unique type id SOAP_TYPE__wsnt__ResumeSubscriptionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__ResumeSubscriptionResponse() { _wsnt__ResumeSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscriptionResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (1448)
/* wsrfbf:BaseFaultType-ErrorCode */
class SOAP_CMAC _wsrfbf__BaseFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1448; } /* = unique type id SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsrfbf__BaseFaultType_ErrorCode() { _wsrfbf__BaseFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (1450)
/* Primitive wsrfbf:BaseFaultType-Description schema type: */
class SOAP_CMAC _wsrfbf__BaseFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1450; } /* = unique type id SOAP_TYPE__wsrfbf__BaseFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsrfbf__BaseFaultType_Description() { _wsrfbf__BaseFaultType_Description::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (1454)
/* wsrfbf:BaseFaultType-FaultCause */
class SOAP_CMAC _wsrfbf__BaseFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1454; } /* = unique type id SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsrfbf__BaseFaultType_FaultCause() { _wsrfbf__BaseFaultType_FaultCause::soap_default(NULL); }
	virtual ~_wsrfbf__BaseFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (699)
/* wsrfbf:BaseFaultType */
class SOAP_CMAC wsrfbf__BaseFaultType : public xsd__anyType
{
public:
	std::vector<char * >__any;
	time_t Timestamp;	/* required element of type xsd:dateTime */
	struct wsa5__EndpointReferenceType *Originator;	/* optional element of type wsa5:EndpointReferenceType */
	_wsrfbf__BaseFaultType_ErrorCode *ErrorCode;	/* optional element of type wsrfbf:BaseFaultType-ErrorCode */
	std::vector<_wsrfbf__BaseFaultType_Description >*Description;	/* optional element of type wsrfbf:BaseFaultType-Description */
	_wsrfbf__BaseFaultType_FaultCause *FaultCause;	/* optional element of type wsrfbf:BaseFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 699; } /* = unique type id SOAP_TYPE_wsrfbf__BaseFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsrfbf__BaseFaultType() { wsrfbf__BaseFaultType::soap_default(NULL); }
	virtual ~wsrfbf__BaseFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (700)
/* wstop:Documentation */
class SOAP_CMAC wstop__Documentation : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__mixed;
public:
	virtual int soap_type() const { return 700; } /* = unique type id SOAP_TYPE_wstop__Documentation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__Documentation() { wstop__Documentation::soap_default(NULL); }
	virtual ~wstop__Documentation() { }
};
#endif

#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (701)
/* wstop:ExtensibleDocumented */
class SOAP_CMAC wstop__ExtensibleDocumented : public xsd__anyType
{
public:
	wstop__Documentation *documentation;	/* optional element of type wstop:Documentation */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 701; } /* = unique type id SOAP_TYPE_wstop__ExtensibleDocumented */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__ExtensibleDocumented() { wstop__ExtensibleDocumented::soap_default(NULL); }
	virtual ~wstop__ExtensibleDocumented() { }
};
#endif

#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (702)
/* wstop:QueryExpressionType */
class SOAP_CMAC wstop__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 702; } /* = unique type id SOAP_TYPE_wstop__QueryExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__QueryExpressionType() { wstop__QueryExpressionType::soap_default(NULL); }
	virtual ~wstop__QueryExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Capabilities2
#define SOAP_TYPE_ns1__Capabilities2 (706)
/* ns1:Capabilities2 */
class SOAP_CMAC ns1__Capabilities2 : public xsd__anyType
{
public:
	class ns1__ProfileCapabilities *ProfileCapabilities;	/* required element of type ns1:ProfileCapabilities */
	class ns1__StreamingCapabilities *StreamingCapabilities;	/* required element of type ns1:StreamingCapabilities */
	std::vector<char * >__any;
	bool *SnapshotUri;	/* optional attribute */
	bool *Rotation;	/* optional attribute */
	bool *VideoSourceMode;	/* optional attribute */
	bool *OSD;	/* optional attribute */
	bool *TemporaryOSDText;	/* optional attribute */
	bool *Mask;	/* optional attribute */
	bool *SourceMask;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 706; } /* = unique type id SOAP_TYPE_ns1__Capabilities2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Capabilities2() { ns1__Capabilities2::soap_default(NULL); }
	virtual ~ns1__Capabilities2() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ProfileCapabilities
#define SOAP_TYPE_ns1__ProfileCapabilities (707)
/* ns1:ProfileCapabilities */
class SOAP_CMAC ns1__ProfileCapabilities : public xsd__anyType
{
public:
	std::vector<char * >__any;
	int *MaximumNumberOfProfiles;	/* optional attribute */
	std::string *ConfigurationsSupported;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 707; } /* = unique type id SOAP_TYPE_ns1__ProfileCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ProfileCapabilities() { ns1__ProfileCapabilities::soap_default(NULL); }
	virtual ~ns1__ProfileCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns1__StreamingCapabilities
#define SOAP_TYPE_ns1__StreamingCapabilities (708)
/* ns1:StreamingCapabilities */
class SOAP_CMAC ns1__StreamingCapabilities : public xsd__anyType
{
public:
	std::vector<char * >__any;
	bool *RTSPStreaming;	/* optional attribute */
	bool *RTPMulticast;	/* optional attribute */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional attribute */
	bool *NonAggregateControl;	/* optional attribute */
	std::string *RTSPWebSocketUri;	/* optional attribute */
	bool *AutoStartMulticast;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 708; } /* = unique type id SOAP_TYPE_ns1__StreamingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__StreamingCapabilities() { ns1__StreamingCapabilities::soap_default(NULL); }
	virtual ~ns1__StreamingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ConfigurationRef
#define SOAP_TYPE_ns1__ConfigurationRef (709)
/* ns1:ConfigurationRef */
class SOAP_CMAC ns1__ConfigurationRef : public xsd__anyType
{
public:
	std::string Type;	/* required element of type xsd:string */
	std::string *Token;	/* optional element of type tt:ReferenceToken */
public:
	virtual int soap_type() const { return 709; } /* = unique type id SOAP_TYPE_ns1__ConfigurationRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ConfigurationRef() { ns1__ConfigurationRef::soap_default(NULL); }
	virtual ~ns1__ConfigurationRef() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ConfigurationSet
#define SOAP_TYPE_ns1__ConfigurationSet (710)
/* ns1:ConfigurationSet */
class SOAP_CMAC ns1__ConfigurationSet : public xsd__anyType
{
public:
	tt__VideoSourceConfiguration *VideoSource;	/* optional element of type tt:VideoSourceConfiguration */
	tt__AudioSourceConfiguration *AudioSource;	/* optional element of type tt:AudioSourceConfiguration */
	class tt__VideoEncoder2Configuration *VideoEncoder;	/* optional element of type tt:VideoEncoder2Configuration */
	class tt__AudioEncoder2Configuration *AudioEncoder;	/* optional element of type tt:AudioEncoder2Configuration */
	tt__VideoAnalyticsConfiguration *Analytics;	/* optional element of type tt:VideoAnalyticsConfiguration */
	tt__PTZConfiguration *PTZ;	/* optional element of type tt:PTZConfiguration */
	tt__MetadataConfiguration *Metadata;	/* optional element of type tt:MetadataConfiguration */
	tt__AudioOutputConfiguration *AudioOutput;	/* optional element of type tt:AudioOutputConfiguration */
	tt__AudioDecoderConfiguration *AudioDecoder;	/* optional element of type tt:AudioDecoderConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 710; } /* = unique type id SOAP_TYPE_ns1__ConfigurationSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ConfigurationSet() { ns1__ConfigurationSet::soap_default(NULL); }
	virtual ~ns1__ConfigurationSet() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MediaProfile
#define SOAP_TYPE_ns1__MediaProfile (711)
/* ns1:MediaProfile */
class SOAP_CMAC ns1__MediaProfile : public xsd__anyType
{
public:
	std::string Name;	/* required element of type tt:Name */
	ns1__ConfigurationSet *Configurations;	/* optional element of type ns1:ConfigurationSet */
	std::string token;	/* required attribute */
	bool *fixed;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 711; } /* = unique type id SOAP_TYPE_ns1__MediaProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MediaProfile() { ns1__MediaProfile::soap_default(NULL); }
	virtual ~ns1__MediaProfile() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetConfiguration
#define SOAP_TYPE_ns1__GetConfiguration (712)
/* ns1:GetConfiguration */
class SOAP_CMAC ns1__GetConfiguration : public xsd__anyType
{
public:
	std::string *ConfigurationToken;	/* optional element of type tt:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type tt:ReferenceToken */
public:
	virtual int soap_type() const { return 712; } /* = unique type id SOAP_TYPE_ns1__GetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetConfiguration() { ns1__GetConfiguration::soap_default(NULL); }
	virtual ~ns1__GetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SetConfigurationResponse
#define SOAP_TYPE_ns1__SetConfigurationResponse (713)
/* Primitive ns1:SetConfigurationResponse schema type: */
class SOAP_CMAC ns1__SetConfigurationResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 713; } /* = unique type id SOAP_TYPE_ns1__SetConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SetConfigurationResponse() { ns1__SetConfigurationResponse::soap_default(NULL); }
	virtual ~ns1__SetConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EncoderInstance
#define SOAP_TYPE_ns1__EncoderInstance (714)
/* ns1:EncoderInstance */
class SOAP_CMAC ns1__EncoderInstance : public xsd__anyType
{
public:
	std::string Encoding;	/* required element of type xsd:string */
	int Number;	/* required element of type xsd:int */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 714; } /* = unique type id SOAP_TYPE_ns1__EncoderInstance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EncoderInstance() { ns1__EncoderInstance::soap_default(NULL); }
	virtual ~ns1__EncoderInstance() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EncoderInstanceInfo
#define SOAP_TYPE_ns1__EncoderInstanceInfo (715)
/* ns1:EncoderInstanceInfo */
class SOAP_CMAC ns1__EncoderInstanceInfo : public xsd__anyType
{
public:
	std::vector<ns1__EncoderInstance * >Codec;	/* optional element of type ns1:EncoderInstance */
	int Total;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 715; } /* = unique type id SOAP_TYPE_ns1__EncoderInstanceInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EncoderInstanceInfo() { ns1__EncoderInstanceInfo::soap_default(NULL); }
	virtual ~ns1__EncoderInstanceInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__StartStopMulticastStreaming
#define SOAP_TYPE_ns1__StartStopMulticastStreaming (716)
/* ns1:StartStopMulticastStreaming */
class SOAP_CMAC ns1__StartStopMulticastStreaming : public xsd__anyType
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
public:
	virtual int soap_type() const { return 716; } /* = unique type id SOAP_TYPE_ns1__StartStopMulticastStreaming */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__StartStopMulticastStreaming() { ns1__StartStopMulticastStreaming::soap_default(NULL); }
	virtual ~ns1__StartStopMulticastStreaming() { }
};
#endif

#ifndef SOAP_TYPE_ns1__VideoSourceMode
#define SOAP_TYPE_ns1__VideoSourceMode (717)
/* ns1:VideoSourceMode */
class SOAP_CMAC ns1__VideoSourceMode : public xsd__anyType
{
public:
	float MaxFramerate;	/* required element of type xsd:float */
	tt__VideoResolution *MaxResolution;	/* required element of type tt:VideoResolution */
	std::string Encodings;	/* required element of type ns1:EncodingTypes */
	bool Reboot;	/* required element of type xsd:boolean */
	std::string *Description;	/* optional element of type tt:Description */
	std::vector<char * >__any;
	std::string token;	/* required attribute */
	bool *Enabled;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 717; } /* = unique type id SOAP_TYPE_ns1__VideoSourceMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__VideoSourceMode() { ns1__VideoSourceMode::soap_default(NULL); }
	virtual ~ns1__VideoSourceMode() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Mask
#define SOAP_TYPE_ns1__Mask (718)
/* ns1:Mask */
class SOAP_CMAC ns1__Mask : public xsd__anyType
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	tt__Polygon *Polygon;	/* required element of type tt:Polygon */
	std::string Type;	/* required element of type xsd:string */
	tt__Color *Color;	/* optional element of type tt:Color */
	bool Enabled;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	std::string *token;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 718; } /* = unique type id SOAP_TYPE_ns1__Mask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Mask() { ns1__Mask::soap_default(NULL); }
	virtual ~ns1__Mask() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MaskOptions
#define SOAP_TYPE_ns1__MaskOptions (719)
/* ns1:MaskOptions */
class SOAP_CMAC ns1__MaskOptions : public xsd__anyType
{
public:
	int MaxMasks;	/* required element of type xsd:int */
	int MaxPoints;	/* required element of type xsd:int */
	std::vector<std::string >Types;	/* required element of type xsd:string */
	tt__ColorOptions *Color;	/* required element of type tt:ColorOptions */
	std::vector<char * >__any;
	bool *RectangleOnly;	/* optional attribute */
	bool *SingleColorOnly;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 719; } /* = unique type id SOAP_TYPE_ns1__MaskOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MaskOptions() { ns1__MaskOptions::soap_default(NULL); }
	virtual ~ns1__MaskOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetServiceCapabilities
#define SOAP_TYPE__ns1__GetServiceCapabilities (720)
/* ns1:GetServiceCapabilities */
class SOAP_CMAC _ns1__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 720; } /* = unique type id SOAP_TYPE__ns1__GetServiceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetServiceCapabilities() { _ns1__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_ns1__GetServiceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns1__GetServiceCapabilitiesResponse (721)
/* ns1:GetServiceCapabilitiesResponse */
class SOAP_CMAC _ns1__GetServiceCapabilitiesResponse
{
public:
	ns1__Capabilities2 *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:Capabilities2 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 721; } /* = unique type id SOAP_TYPE__ns1__GetServiceCapabilitiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetServiceCapabilitiesResponse() { _ns1__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_ns1__GetServiceCapabilitiesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateProfile
#define SOAP_TYPE__ns1__CreateProfile (722)
/* ns1:CreateProfile */
class SOAP_CMAC _ns1__CreateProfile
{
public:
	std::string Name;	/* required element of type tt:Name */
	std::vector<ns1__ConfigurationRef * >Configuration;	/* optional element of type ns1:ConfigurationRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 722; } /* = unique type id SOAP_TYPE__ns1__CreateProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateProfile() { _ns1__CreateProfile::soap_default(NULL); }
	virtual ~_ns1__CreateProfile() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateProfileResponse
#define SOAP_TYPE__ns1__CreateProfileResponse (723)
/* ns1:CreateProfileResponse */
class SOAP_CMAC _ns1__CreateProfileResponse
{
public:
	std::string Token;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 723; } /* = unique type id SOAP_TYPE__ns1__CreateProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateProfileResponse() { _ns1__CreateProfileResponse::soap_default(NULL); }
	virtual ~_ns1__CreateProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetProfiles
#define SOAP_TYPE__ns1__GetProfiles (724)
/* ns1:GetProfiles */
class SOAP_CMAC _ns1__GetProfiles
{
public:
	std::string *Token;	/* optional element of type tt:ReferenceToken */
	std::vector<std::string >Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 724; } /* = unique type id SOAP_TYPE__ns1__GetProfiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetProfiles() { _ns1__GetProfiles::soap_default(NULL); }
	virtual ~_ns1__GetProfiles() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetProfilesResponse
#define SOAP_TYPE__ns1__GetProfilesResponse (725)
/* ns1:GetProfilesResponse */
class SOAP_CMAC _ns1__GetProfilesResponse
{
public:
	std::vector<ns1__MediaProfile * >Profiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:MediaProfile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 725; } /* = unique type id SOAP_TYPE__ns1__GetProfilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetProfilesResponse() { _ns1__GetProfilesResponse::soap_default(NULL); }
	virtual ~_ns1__GetProfilesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddConfiguration
#define SOAP_TYPE__ns1__AddConfiguration (726)
/* ns1:AddConfiguration */
class SOAP_CMAC _ns1__AddConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::string *Name;	/* optional element of type tt:Name */
	std::vector<ns1__ConfigurationRef * >Configuration;	/* optional element of type ns1:ConfigurationRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 726; } /* = unique type id SOAP_TYPE__ns1__AddConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddConfiguration() { _ns1__AddConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddConfigurationResponse
#define SOAP_TYPE__ns1__AddConfigurationResponse (727)
/* ns1:AddConfigurationResponse */
class SOAP_CMAC _ns1__AddConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 727; } /* = unique type id SOAP_TYPE__ns1__AddConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddConfigurationResponse() { _ns1__AddConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveConfiguration
#define SOAP_TYPE__ns1__RemoveConfiguration (728)
/* ns1:RemoveConfiguration */
class SOAP_CMAC _ns1__RemoveConfiguration
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	std::vector<ns1__ConfigurationRef * >Configuration;	/* required element of type ns1:ConfigurationRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 728; } /* = unique type id SOAP_TYPE__ns1__RemoveConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveConfiguration() { _ns1__RemoveConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemoveConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveConfigurationResponse
#define SOAP_TYPE__ns1__RemoveConfigurationResponse (729)
/* ns1:RemoveConfigurationResponse */
class SOAP_CMAC _ns1__RemoveConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 729; } /* = unique type id SOAP_TYPE__ns1__RemoveConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveConfigurationResponse() { _ns1__RemoveConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemoveConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteProfile
#define SOAP_TYPE__ns1__DeleteProfile (730)
/* ns1:DeleteProfile */
class SOAP_CMAC _ns1__DeleteProfile
{
public:
	std::string Token;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 730; } /* = unique type id SOAP_TYPE__ns1__DeleteProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteProfile() { _ns1__DeleteProfile::soap_default(NULL); }
	virtual ~_ns1__DeleteProfile() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteProfileResponse
#define SOAP_TYPE__ns1__DeleteProfileResponse (731)
/* ns1:DeleteProfileResponse */
class SOAP_CMAC _ns1__DeleteProfileResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 731; } /* = unique type id SOAP_TYPE__ns1__DeleteProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteProfileResponse() { _ns1__DeleteProfileResponse::soap_default(NULL); }
	virtual ~_ns1__DeleteProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__ns1__GetVideoEncoderConfigurationsResponse (732)
/* ns1:GetVideoEncoderConfigurationsResponse */
class SOAP_CMAC _ns1__GetVideoEncoderConfigurationsResponse
{
public:
	std::vector<tt__VideoEncoder2Configuration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoEncoder2Configuration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 732; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderConfigurationsResponse() { _ns1__GetVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__ns1__GetVideoSourceConfigurationsResponse (733)
/* ns1:GetVideoSourceConfigurationsResponse */
class SOAP_CMAC _ns1__GetVideoSourceConfigurationsResponse
{
public:
	std::vector<tt__VideoSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 733; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceConfigurationsResponse() { _ns1__GetVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__ns1__GetAudioEncoderConfigurationsResponse (734)
/* ns1:GetAudioEncoderConfigurationsResponse */
class SOAP_CMAC _ns1__GetAudioEncoderConfigurationsResponse
{
public:
	std::vector<tt__AudioEncoder2Configuration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:AudioEncoder2Configuration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 734; } /* = unique type id SOAP_TYPE__ns1__GetAudioEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioEncoderConfigurationsResponse() { _ns1__GetAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__ns1__GetAudioSourceConfigurationsResponse (735)
/* ns1:GetAudioSourceConfigurationsResponse */
class SOAP_CMAC _ns1__GetAudioSourceConfigurationsResponse
{
public:
	std::vector<tt__AudioSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 735; } /* = unique type id SOAP_TYPE__ns1__GetAudioSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSourceConfigurationsResponse() { _ns1__GetAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAnalyticsConfigurationsResponse
#define SOAP_TYPE__ns1__GetAnalyticsConfigurationsResponse (736)
/* ns1:GetAnalyticsConfigurationsResponse */
class SOAP_CMAC _ns1__GetAnalyticsConfigurationsResponse
{
public:
	std::vector<tt__VideoAnalyticsConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 736; } /* = unique type id SOAP_TYPE__ns1__GetAnalyticsConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAnalyticsConfigurationsResponse() { _ns1__GetAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAnalyticsConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMetadataConfigurationsResponse
#define SOAP_TYPE__ns1__GetMetadataConfigurationsResponse (737)
/* ns1:GetMetadataConfigurationsResponse */
class SOAP_CMAC _ns1__GetMetadataConfigurationsResponse
{
public:
	std::vector<tt__MetadataConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:MetadataConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 737; } /* = unique type id SOAP_TYPE__ns1__GetMetadataConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMetadataConfigurationsResponse() { _ns1__GetMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetMetadataConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__ns1__GetAudioOutputConfigurationsResponse (738)
/* ns1:GetAudioOutputConfigurationsResponse */
class SOAP_CMAC _ns1__GetAudioOutputConfigurationsResponse
{
public:
	std::vector<tt__AudioOutputConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:AudioOutputConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 738; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputConfigurationsResponse() { _ns1__GetAudioOutputConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__ns1__GetAudioDecoderConfigurationsResponse (739)
/* ns1:GetAudioDecoderConfigurationsResponse */
class SOAP_CMAC _ns1__GetAudioDecoderConfigurationsResponse
{
public:
	std::vector<tt__AudioDecoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:AudioDecoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 739; } /* = unique type id SOAP_TYPE__ns1__GetAudioDecoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioDecoderConfigurationsResponse() { _ns1__GetAudioDecoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioDecoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoEncoderConfiguration
#define SOAP_TYPE__ns1__SetVideoEncoderConfiguration (740)
/* ns1:SetVideoEncoderConfiguration */
class SOAP_CMAC _ns1__SetVideoEncoderConfiguration
{
public:
	tt__VideoEncoder2Configuration *Configuration;	/* required element of type tt:VideoEncoder2Configuration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 740; } /* = unique type id SOAP_TYPE__ns1__SetVideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoEncoderConfiguration() { _ns1__SetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetVideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoSourceConfiguration
#define SOAP_TYPE__ns1__SetVideoSourceConfiguration (741)
/* ns1:SetVideoSourceConfiguration */
class SOAP_CMAC _ns1__SetVideoSourceConfiguration
{
public:
	tt__VideoSourceConfiguration *Configuration;	/* required element of type tt:VideoSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 741; } /* = unique type id SOAP_TYPE__ns1__SetVideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoSourceConfiguration() { _ns1__SetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetVideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioEncoderConfiguration
#define SOAP_TYPE__ns1__SetAudioEncoderConfiguration (742)
/* ns1:SetAudioEncoderConfiguration */
class SOAP_CMAC _ns1__SetAudioEncoderConfiguration
{
public:
	tt__AudioEncoder2Configuration *Configuration;	/* required element of type tt:AudioEncoder2Configuration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 742; } /* = unique type id SOAP_TYPE__ns1__SetAudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioEncoderConfiguration() { _ns1__SetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetAudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioSourceConfiguration
#define SOAP_TYPE__ns1__SetAudioSourceConfiguration (743)
/* ns1:SetAudioSourceConfiguration */
class SOAP_CMAC _ns1__SetAudioSourceConfiguration
{
public:
	tt__AudioSourceConfiguration *Configuration;	/* required element of type tt:AudioSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 743; } /* = unique type id SOAP_TYPE__ns1__SetAudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioSourceConfiguration() { _ns1__SetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetAudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetMetadataConfiguration
#define SOAP_TYPE__ns1__SetMetadataConfiguration (744)
/* ns1:SetMetadataConfiguration */
class SOAP_CMAC _ns1__SetMetadataConfiguration
{
public:
	tt__MetadataConfiguration *Configuration;	/* required element of type tt:MetadataConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 744; } /* = unique type id SOAP_TYPE__ns1__SetMetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetMetadataConfiguration() { _ns1__SetMetadataConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetMetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioOutputConfiguration
#define SOAP_TYPE__ns1__SetAudioOutputConfiguration (745)
/* ns1:SetAudioOutputConfiguration */
class SOAP_CMAC _ns1__SetAudioOutputConfiguration
{
public:
	tt__AudioOutputConfiguration *Configuration;	/* required element of type tt:AudioOutputConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 745; } /* = unique type id SOAP_TYPE__ns1__SetAudioOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioOutputConfiguration() { _ns1__SetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetAudioOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioDecoderConfiguration
#define SOAP_TYPE__ns1__SetAudioDecoderConfiguration (746)
/* ns1:SetAudioDecoderConfiguration */
class SOAP_CMAC _ns1__SetAudioDecoderConfiguration
{
public:
	tt__AudioDecoderConfiguration *Configuration;	/* required element of type tt:AudioDecoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 746; } /* = unique type id SOAP_TYPE__ns1__SetAudioDecoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioDecoderConfiguration() { _ns1__SetAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetAudioDecoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetVideoSourceConfigurationOptionsResponse (747)
/* ns1:GetVideoSourceConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetVideoSourceConfigurationOptionsResponse
{
public:
	tt__VideoSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:VideoSourceConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 747; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceConfigurationOptionsResponse() { _ns1__GetVideoSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse (748)
/* ns1:GetVideoEncoderConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetVideoEncoderConfigurationOptionsResponse
{
public:
	std::vector<tt__VideoEncoder2ConfigurationOptions * >Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:VideoEncoder2ConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 748; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderConfigurationOptionsResponse() { _ns1__GetVideoEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetAudioSourceConfigurationOptionsResponse (749)
/* ns1:GetAudioSourceConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetAudioSourceConfigurationOptionsResponse
{
public:
	tt__AudioSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AudioSourceConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 749; } /* = unique type id SOAP_TYPE__ns1__GetAudioSourceConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSourceConfigurationOptionsResponse() { _ns1__GetAudioSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioSourceConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetAudioEncoderConfigurationOptionsResponse (750)
/* ns1:GetAudioEncoderConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetAudioEncoderConfigurationOptionsResponse
{
public:
	std::vector<tt__AudioEncoder2ConfigurationOptions * >Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AudioEncoder2ConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 750; } /* = unique type id SOAP_TYPE__ns1__GetAudioEncoderConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioEncoderConfigurationOptionsResponse() { _ns1__GetAudioEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioEncoderConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetMetadataConfigurationOptionsResponse (751)
/* ns1:GetMetadataConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetMetadataConfigurationOptionsResponse
{
public:
	tt__MetadataConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:MetadataConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 751; } /* = unique type id SOAP_TYPE__ns1__GetMetadataConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMetadataConfigurationOptionsResponse() { _ns1__GetMetadataConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetMetadataConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetAudioOutputConfigurationOptionsResponse (752)
/* ns1:GetAudioOutputConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetAudioOutputConfigurationOptionsResponse
{
public:
	tt__AudioOutputConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AudioOutputConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 752; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputConfigurationOptionsResponse() { _ns1__GetAudioOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetAudioDecoderConfigurationOptionsResponse (753)
/* ns1:GetAudioDecoderConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetAudioDecoderConfigurationOptionsResponse
{
public:
	std::vector<tt__AudioEncoder2ConfigurationOptions * >Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AudioEncoder2ConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 753; } /* = unique type id SOAP_TYPE__ns1__GetAudioDecoderConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioDecoderConfigurationOptionsResponse() { _ns1__GetAudioDecoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioDecoderConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderInstances
#define SOAP_TYPE__ns1__GetVideoEncoderInstances (754)
/* ns1:GetVideoEncoderInstances */
class SOAP_CMAC _ns1__GetVideoEncoderInstances
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 754; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderInstances */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderInstances() { _ns1__GetVideoEncoderInstances::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderInstances() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderInstancesResponse
#define SOAP_TYPE__ns1__GetVideoEncoderInstancesResponse (755)
/* ns1:GetVideoEncoderInstancesResponse */
class SOAP_CMAC _ns1__GetVideoEncoderInstancesResponse
{
public:
	ns1__EncoderInstanceInfo *Info;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:EncoderInstanceInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 755; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderInstancesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderInstancesResponse() { _ns1__GetVideoEncoderInstancesResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderInstancesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetStreamUri
#define SOAP_TYPE__ns1__GetStreamUri (756)
/* ns1:GetStreamUri */
class SOAP_CMAC _ns1__GetStreamUri
{
public:
	std::string Protocol;	/* required element of type xsd:string */
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 756; } /* = unique type id SOAP_TYPE__ns1__GetStreamUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetStreamUri() { _ns1__GetStreamUri::soap_default(NULL); }
	virtual ~_ns1__GetStreamUri() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetStreamUriResponse
#define SOAP_TYPE__ns1__GetStreamUriResponse (757)
/* ns1:GetStreamUriResponse */
class SOAP_CMAC _ns1__GetStreamUriResponse
{
public:
	std::string Uri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 757; } /* = unique type id SOAP_TYPE__ns1__GetStreamUriResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetStreamUriResponse() { _ns1__GetStreamUriResponse::soap_default(NULL); }
	virtual ~_ns1__GetStreamUriResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetSynchronizationPoint
#define SOAP_TYPE__ns1__SetSynchronizationPoint (758)
/* ns1:SetSynchronizationPoint */
class SOAP_CMAC _ns1__SetSynchronizationPoint
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 758; } /* = unique type id SOAP_TYPE__ns1__SetSynchronizationPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetSynchronizationPoint() { _ns1__SetSynchronizationPoint::soap_default(NULL); }
	virtual ~_ns1__SetSynchronizationPoint() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetSynchronizationPointResponse
#define SOAP_TYPE__ns1__SetSynchronizationPointResponse (759)
/* ns1:SetSynchronizationPointResponse */
class SOAP_CMAC _ns1__SetSynchronizationPointResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 759; } /* = unique type id SOAP_TYPE__ns1__SetSynchronizationPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetSynchronizationPointResponse() { _ns1__SetSynchronizationPointResponse::soap_default(NULL); }
	virtual ~_ns1__SetSynchronizationPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetSnapshotUri
#define SOAP_TYPE__ns1__GetSnapshotUri (760)
/* ns1:GetSnapshotUri */
class SOAP_CMAC _ns1__GetSnapshotUri
{
public:
	std::string ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 760; } /* = unique type id SOAP_TYPE__ns1__GetSnapshotUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetSnapshotUri() { _ns1__GetSnapshotUri::soap_default(NULL); }
	virtual ~_ns1__GetSnapshotUri() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetSnapshotUriResponse
#define SOAP_TYPE__ns1__GetSnapshotUriResponse (761)
/* ns1:GetSnapshotUriResponse */
class SOAP_CMAC _ns1__GetSnapshotUriResponse
{
public:
	std::string Uri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 761; } /* = unique type id SOAP_TYPE__ns1__GetSnapshotUriResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetSnapshotUriResponse() { _ns1__GetSnapshotUriResponse::soap_default(NULL); }
	virtual ~_ns1__GetSnapshotUriResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceModes
#define SOAP_TYPE__ns1__GetVideoSourceModes (762)
/* ns1:GetVideoSourceModes */
class SOAP_CMAC _ns1__GetVideoSourceModes
{
public:
	std::string VideoSourceToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 762; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceModes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceModes() { _ns1__GetVideoSourceModes::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceModes() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceModesResponse
#define SOAP_TYPE__ns1__GetVideoSourceModesResponse (763)
/* ns1:GetVideoSourceModesResponse */
class SOAP_CMAC _ns1__GetVideoSourceModesResponse
{
public:
	std::vector<ns1__VideoSourceMode * >VideoSourceModes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:VideoSourceMode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 763; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceModesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceModesResponse() { _ns1__GetVideoSourceModesResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceModesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoSourceMode
#define SOAP_TYPE__ns1__SetVideoSourceMode (764)
/* ns1:SetVideoSourceMode */
class SOAP_CMAC _ns1__SetVideoSourceMode
{
public:
	std::string VideoSourceToken;	/* required element of type tt:ReferenceToken */
	std::string VideoSourceModeToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 764; } /* = unique type id SOAP_TYPE__ns1__SetVideoSourceMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoSourceMode() { _ns1__SetVideoSourceMode::soap_default(NULL); }
	virtual ~_ns1__SetVideoSourceMode() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoSourceModeResponse
#define SOAP_TYPE__ns1__SetVideoSourceModeResponse (765)
/* ns1:SetVideoSourceModeResponse */
class SOAP_CMAC _ns1__SetVideoSourceModeResponse
{
public:
	bool Reboot;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 765; } /* = unique type id SOAP_TYPE__ns1__SetVideoSourceModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoSourceModeResponse() { _ns1__SetVideoSourceModeResponse::soap_default(NULL); }
	virtual ~_ns1__SetVideoSourceModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSDs
#define SOAP_TYPE__ns1__GetOSDs (766)
/* ns1:GetOSDs */
class SOAP_CMAC _ns1__GetOSDs
{
public:
	std::string *OSDToken;	/* optional element of type tt:ReferenceToken */
	std::string *ConfigurationToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 766; } /* = unique type id SOAP_TYPE__ns1__GetOSDs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSDs() { _ns1__GetOSDs::soap_default(NULL); }
	virtual ~_ns1__GetOSDs() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSDsResponse
#define SOAP_TYPE__ns1__GetOSDsResponse (767)
/* ns1:GetOSDsResponse */
class SOAP_CMAC _ns1__GetOSDsResponse
{
public:
	std::vector<class tt__OSDConfiguration * >OSDs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tt:OSDConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 767; } /* = unique type id SOAP_TYPE__ns1__GetOSDsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSDsResponse() { _ns1__GetOSDsResponse::soap_default(NULL); }
	virtual ~_ns1__GetOSDsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetOSD
#define SOAP_TYPE__ns1__SetOSD (768)
/* ns1:SetOSD */
class SOAP_CMAC _ns1__SetOSD
{
public:
	tt__OSDConfiguration *OSD;	/* required element of type tt:OSDConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 768; } /* = unique type id SOAP_TYPE__ns1__SetOSD */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetOSD() { _ns1__SetOSD::soap_default(NULL); }
	virtual ~_ns1__SetOSD() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSDOptions
#define SOAP_TYPE__ns1__GetOSDOptions (769)
/* ns1:GetOSDOptions */
class SOAP_CMAC _ns1__GetOSDOptions
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 769; } /* = unique type id SOAP_TYPE__ns1__GetOSDOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSDOptions() { _ns1__GetOSDOptions::soap_default(NULL); }
	virtual ~_ns1__GetOSDOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSDOptionsResponse
#define SOAP_TYPE__ns1__GetOSDOptionsResponse (770)
/* ns1:GetOSDOptionsResponse */
class SOAP_CMAC _ns1__GetOSDOptionsResponse
{
public:
	tt__OSDConfigurationOptions *OSDOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:OSDConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 770; } /* = unique type id SOAP_TYPE__ns1__GetOSDOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSDOptionsResponse() { _ns1__GetOSDOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetOSDOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateOSD
#define SOAP_TYPE__ns1__CreateOSD (771)
/* ns1:CreateOSD */
class SOAP_CMAC _ns1__CreateOSD
{
public:
	tt__OSDConfiguration *OSD;	/* required element of type tt:OSDConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 771; } /* = unique type id SOAP_TYPE__ns1__CreateOSD */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateOSD() { _ns1__CreateOSD::soap_default(NULL); }
	virtual ~_ns1__CreateOSD() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateOSDResponse
#define SOAP_TYPE__ns1__CreateOSDResponse (772)
/* ns1:CreateOSDResponse */
class SOAP_CMAC _ns1__CreateOSDResponse
{
public:
	std::string OSDToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 772; } /* = unique type id SOAP_TYPE__ns1__CreateOSDResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateOSDResponse() { _ns1__CreateOSDResponse::soap_default(NULL); }
	virtual ~_ns1__CreateOSDResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteOSD
#define SOAP_TYPE__ns1__DeleteOSD (773)
/* ns1:DeleteOSD */
class SOAP_CMAC _ns1__DeleteOSD
{
public:
	std::string OSDToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 773; } /* = unique type id SOAP_TYPE__ns1__DeleteOSD */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteOSD() { _ns1__DeleteOSD::soap_default(NULL); }
	virtual ~_ns1__DeleteOSD() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMasks
#define SOAP_TYPE__ns1__GetMasks (774)
/* ns1:GetMasks */
class SOAP_CMAC _ns1__GetMasks
{
public:
	std::string *Token;	/* optional element of type tt:ReferenceToken */
	std::string *ConfigurationToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 774; } /* = unique type id SOAP_TYPE__ns1__GetMasks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMasks() { _ns1__GetMasks::soap_default(NULL); }
	virtual ~_ns1__GetMasks() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMasksResponse
#define SOAP_TYPE__ns1__GetMasksResponse (775)
/* ns1:GetMasksResponse */
class SOAP_CMAC _ns1__GetMasksResponse
{
public:
	std::vector<ns1__Mask * >Masks;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:Mask */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 775; } /* = unique type id SOAP_TYPE__ns1__GetMasksResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMasksResponse() { _ns1__GetMasksResponse::soap_default(NULL); }
	virtual ~_ns1__GetMasksResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetMask
#define SOAP_TYPE__ns1__SetMask (776)
/* ns1:SetMask */
class SOAP_CMAC _ns1__SetMask
{
public:
	ns1__Mask *Mask;	/* required element of type ns1:Mask */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 776; } /* = unique type id SOAP_TYPE__ns1__SetMask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetMask() { _ns1__SetMask::soap_default(NULL); }
	virtual ~_ns1__SetMask() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMaskOptions
#define SOAP_TYPE__ns1__GetMaskOptions (777)
/* ns1:GetMaskOptions */
class SOAP_CMAC _ns1__GetMaskOptions
{
public:
	std::string ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 777; } /* = unique type id SOAP_TYPE__ns1__GetMaskOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMaskOptions() { _ns1__GetMaskOptions::soap_default(NULL); }
	virtual ~_ns1__GetMaskOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMaskOptionsResponse
#define SOAP_TYPE__ns1__GetMaskOptionsResponse (778)
/* ns1:GetMaskOptionsResponse */
class SOAP_CMAC _ns1__GetMaskOptionsResponse
{
public:
	ns1__MaskOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:MaskOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 778; } /* = unique type id SOAP_TYPE__ns1__GetMaskOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMaskOptionsResponse() { _ns1__GetMaskOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetMaskOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateMask
#define SOAP_TYPE__ns1__CreateMask (779)
/* ns1:CreateMask */
class SOAP_CMAC _ns1__CreateMask
{
public:
	ns1__Mask *Mask;	/* required element of type ns1:Mask */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 779; } /* = unique type id SOAP_TYPE__ns1__CreateMask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateMask() { _ns1__CreateMask::soap_default(NULL); }
	virtual ~_ns1__CreateMask() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateMaskResponse
#define SOAP_TYPE__ns1__CreateMaskResponse (780)
/* ns1:CreateMaskResponse */
class SOAP_CMAC _ns1__CreateMaskResponse
{
public:
	std::string Token;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 780; } /* = unique type id SOAP_TYPE__ns1__CreateMaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateMaskResponse() { _ns1__CreateMaskResponse::soap_default(NULL); }
	virtual ~_ns1__CreateMaskResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteMask
#define SOAP_TYPE__ns1__DeleteMask (781)
/* ns1:DeleteMask */
class SOAP_CMAC _ns1__DeleteMask
{
public:
	std::string Token;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 781; } /* = unique type id SOAP_TYPE__ns1__DeleteMask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteMask() { _ns1__DeleteMask::soap_default(NULL); }
	virtual ~_ns1__DeleteMask() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (195)
/* tt:VideoSource */
class SOAP_CMAC tt__VideoSource : public tt__DeviceEntity
{
public:
	float Framerate;	/* required element of type xsd:float */
	tt__VideoResolution *Resolution;	/* required element of type tt:VideoResolution */
	tt__ImagingSettings *Imaging;	/* optional element of type tt:ImagingSettings */
	tt__VideoSourceExtension *Extension;	/* optional element of type tt:VideoSourceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 195; } /* = unique type id SOAP_TYPE_tt__VideoSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSource() { tt__VideoSource::soap_default(NULL); }
	virtual ~tt__VideoSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (198)
/* tt:AudioSource */
class SOAP_CMAC tt__AudioSource : public tt__DeviceEntity
{
public:
	int Channels;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 198; } /* = unique type id SOAP_TYPE_tt__AudioSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSource() { tt__AudioSource::soap_default(NULL); }
	virtual ~tt__AudioSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (203)
/* tt:VideoSourceConfiguration */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity
{
public:
	std::string SourceToken;	/* required element of type tt:ReferenceToken */
	tt__IntRectangle *Bounds;	/* required element of type tt:IntRectangle */
	std::vector<char * >__any;
	tt__VideoSourceConfigurationExtension *Extension;	/* optional element of type tt:VideoSourceConfigurationExtension */
	std::string *ViewMode;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 203; } /* = unique type id SOAP_TYPE_tt__VideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfiguration() { tt__VideoSourceConfiguration::soap_default(NULL); }
	virtual ~tt__VideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (217)
/* tt:VideoEncoderConfiguration */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__VideoEncoding Encoding;	/* required element of type tt:VideoEncoding */
	tt__VideoResolution *Resolution;	/* required element of type tt:VideoResolution */
	float Quality;	/* required element of type xsd:float */
	tt__VideoRateControl *RateControl;	/* optional element of type tt:VideoRateControl */
	tt__Mpeg4Configuration *MPEG4;	/* optional element of type tt:Mpeg4Configuration */
	tt__H264Configuration *H264;	/* optional element of type tt:H264Configuration */
	tt__MulticastConfiguration *Multicast;	/* required element of type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external */
	std::vector<char * >__any;
	bool *GuaranteedFrameRate;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 217; } /* = unique type id SOAP_TYPE_tt__VideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderConfiguration() { tt__VideoEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (226)
/* tt:JpegOptions2 */
class SOAP_CMAC tt__JpegOptions2 : public tt__JpegOptions
{
public:
	tt__IntRange *BitrateRange;	/* required element of type tt:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 226; } /* = unique type id SOAP_TYPE_tt__JpegOptions2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__JpegOptions2() { tt__JpegOptions2::soap_default(NULL); }
	virtual ~tt__JpegOptions2() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (228)
/* tt:Mpeg4Options2 */
class SOAP_CMAC tt__Mpeg4Options2 : public tt__Mpeg4Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of type tt:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 228; } /* = unique type id SOAP_TYPE_tt__Mpeg4Options2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Options2() { tt__Mpeg4Options2::soap_default(NULL); }
	virtual ~tt__Mpeg4Options2() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (230)
/* tt:H264Options2 */
class SOAP_CMAC tt__H264Options2 : public tt__H264Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of type tt:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 230; } /* = unique type id SOAP_TYPE_tt__H264Options2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Options2() { tt__H264Options2::soap_default(NULL); }
	virtual ~tt__H264Options2() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoder2Configuration
#define SOAP_TYPE_tt__VideoEncoder2Configuration (231)
/* tt:VideoEncoder2Configuration */
class SOAP_CMAC tt__VideoEncoder2Configuration : public tt__ConfigurationEntity
{
public:
	std::string Encoding;	/* required element of type xsd:string */
	tt__VideoResolution2 *Resolution;	/* required element of type tt:VideoResolution2 */
	tt__VideoRateControl2 *RateControl;	/* optional element of type tt:VideoRateControl2 */
	tt__MulticastConfiguration *Multicast;	/* optional element of type tt:MulticastConfiguration */
	float Quality;	/* required element of type xsd:float */
	std::vector<char * >__any;
	int *GovLength;	/* optional attribute */
	std::string *Profile;	/* optional attribute */
	bool *GuaranteedFrameRate;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 231; } /* = unique type id SOAP_TYPE_tt__VideoEncoder2Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoder2Configuration() { tt__VideoEncoder2Configuration::soap_default(NULL); }
	virtual ~tt__VideoEncoder2Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (235)
/* tt:AudioSourceConfiguration */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity
{
public:
	std::string SourceToken;	/* required element of type tt:ReferenceToken */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 235; } /* = unique type id SOAP_TYPE_tt__AudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSourceConfiguration() { tt__AudioSourceConfiguration::soap_default(NULL); }
	virtual ~tt__AudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (238)
/* tt:AudioEncoderConfiguration */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of type tt:AudioEncoding */
	int Bitrate;	/* required element of type xsd:int */
	int SampleRate;	/* required element of type xsd:int */
	tt__MulticastConfiguration *Multicast;	/* required element of type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 238; } /* = unique type id SOAP_TYPE_tt__AudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoderConfiguration() { tt__AudioEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoder2Configuration
#define SOAP_TYPE_tt__AudioEncoder2Configuration (241)
/* tt:AudioEncoder2Configuration */
class SOAP_CMAC tt__AudioEncoder2Configuration : public tt__ConfigurationEntity
{
public:
	std::string Encoding;	/* required element of type xsd:string */
	tt__MulticastConfiguration *Multicast;	/* optional element of type tt:MulticastConfiguration */
	int Bitrate;	/* required element of type xsd:int */
	int SampleRate;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 241; } /* = unique type id SOAP_TYPE_tt__AudioEncoder2Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoder2Configuration() { tt__AudioEncoder2Configuration::soap_default(NULL); }
	virtual ~tt__AudioEncoder2Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (243)
/* tt:VideoAnalyticsConfiguration */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of type tt:AnalyticsEngineConfiguration */
	tt__RuleEngineConfiguration *RuleEngineConfiguration;	/* required element of type tt:RuleEngineConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 243; } /* = unique type id SOAP_TYPE_tt__VideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoAnalyticsConfiguration() { tt__VideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (244)
/* tt:MetadataConfiguration */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity
{
public:
	tt__PTZFilter *PTZStatus;	/* optional element of type tt:PTZFilter */
	tt__EventSubscription *Events;	/* optional element of type tt:EventSubscription */
	bool *Analytics;	/* optional element of type xsd:boolean */
	tt__MulticastConfiguration *Multicast;	/* required element of type tt:MulticastConfiguration */
	LONG64 SessionTimeout;	/* external */
	std::vector<char * >__any;
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* optional element of type tt:AnalyticsEngineConfiguration */
	tt__MetadataConfigurationExtension *Extension;	/* optional element of type tt:MetadataConfigurationExtension */
	std::string *CompressionType;	/* optional attribute */
	bool *GeoLocation;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 244; } /* = unique type id SOAP_TYPE_tt__MetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfiguration() { tt__MetadataConfiguration::soap_default(NULL); }
	virtual ~tt__MetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (253)
/* tt:VideoOutput */
class SOAP_CMAC tt__VideoOutput : public tt__DeviceEntity
{
public:
	tt__Layout *Layout;	/* required element of type tt:Layout */
	tt__VideoResolution *Resolution;	/* optional element of type tt:VideoResolution */
	float *RefreshRate;	/* optional element of type xsd:float */
	float *AspectRatio;	/* optional element of type xsd:float */
	tt__VideoOutputExtension *Extension;	/* optional element of type tt:VideoOutputExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 253; } /* = unique type id SOAP_TYPE_tt__VideoOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoOutput() { tt__VideoOutput::soap_default(NULL); }
	virtual ~tt__VideoOutput() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (255)
/* tt:VideoOutputConfiguration */
class SOAP_CMAC tt__VideoOutputConfiguration : public tt__ConfigurationEntity
{
public:
	std::string OutputToken;	/* required element of type tt:ReferenceToken */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 255; } /* = unique type id SOAP_TYPE_tt__VideoOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoOutputConfiguration() { tt__VideoOutputConfiguration::soap_default(NULL); }
	virtual ~tt__VideoOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (262)
/* tt:AudioOutput */
class SOAP_CMAC tt__AudioOutput : public tt__DeviceEntity
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 262; } /* = unique type id SOAP_TYPE_tt__AudioOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioOutput() { tt__AudioOutput::soap_default(NULL); }
	virtual ~tt__AudioOutput() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (263)
/* tt:AudioOutputConfiguration */
class SOAP_CMAC tt__AudioOutputConfiguration : public tt__ConfigurationEntity
{
public:
	std::string OutputToken;	/* required element of type tt:ReferenceToken */
	std::string *SendPrimacy;	/* optional element of type xsd:anyURI */
	int OutputLevel;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 263; } /* = unique type id SOAP_TYPE_tt__AudioOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioOutputConfiguration() { tt__AudioOutputConfiguration::soap_default(NULL); }
	virtual ~tt__AudioOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (265)
/* tt:AudioDecoderConfiguration */
class SOAP_CMAC tt__AudioDecoderConfiguration : public tt__ConfigurationEntity
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 265; } /* = unique type id SOAP_TYPE_tt__AudioDecoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioDecoderConfiguration() { tt__AudioDecoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (276)
/* tt:NetworkInterface */
class SOAP_CMAC tt__NetworkInterface : public tt__DeviceEntity
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	tt__NetworkInterfaceInfo *Info;	/* optional element of type tt:NetworkInterfaceInfo */
	tt__NetworkInterfaceLink *Link;	/* optional element of type tt:NetworkInterfaceLink */
	tt__IPv4NetworkInterface *IPv4;	/* optional element of type tt:IPv4NetworkInterface */
	tt__IPv6NetworkInterface *IPv6;	/* optional element of type tt:IPv6NetworkInterface */
	tt__NetworkInterfaceExtension *Extension;	/* optional element of type tt:NetworkInterfaceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 276; } /* = unique type id SOAP_TYPE_tt__NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterface() { tt__NetworkInterface::soap_default(NULL); }
	virtual ~tt__NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (380)
/* Primitive tt:CertificateUsage schema type: */
class SOAP_CMAC tt__CertificateUsage : public xsd__anyType
{
public:
	std::string __item;
	bool Critical;	/* required attribute */
public:
	virtual int soap_type() const { return 380; } /* = unique type id SOAP_TYPE_tt__CertificateUsage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateUsage() { tt__CertificateUsage::soap_default(NULL); }
	virtual ~tt__CertificateUsage() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (389)
/* tt:RelayOutput */
class SOAP_CMAC tt__RelayOutput : public tt__DeviceEntity
{
public:
	tt__RelayOutputSettings *Properties;	/* required element of type tt:RelayOutputSettings */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 389; } /* = unique type id SOAP_TYPE_tt__RelayOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayOutput() { tt__RelayOutput::soap_default(NULL); }
	virtual ~tt__RelayOutput() { }
};
#endif

#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (390)
/* tt:DigitalInput */
class SOAP_CMAC tt__DigitalInput : public tt__DeviceEntity
{
public:
	std::vector<char * >__any;
	enum tt__DigitalIdleState *IdleState;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 390; } /* = unique type id SOAP_TYPE_tt__DigitalInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DigitalInput() { tt__DigitalInput::soap_default(NULL); }
	virtual ~tt__DigitalInput() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (391)
/* tt:PTZNode */
class SOAP_CMAC tt__PTZNode : public tt__DeviceEntity
{
public:
	std::string *Name;	/* optional element of type tt:Name */
	tt__PTZSpaces *SupportedPTZSpaces;	/* required element of type tt:PTZSpaces */
	int MaximumNumberOfPresets;	/* required element of type xsd:int */
	bool HomeSupported;	/* required element of type xsd:boolean */
	std::vector<std::string >AuxiliaryCommands;	/* optional element of type tt:AuxiliaryData */
	tt__PTZNodeExtension *Extension;	/* optional element of type tt:PTZNodeExtension */
	bool *FixedHomePosition;	/* optional attribute */
	bool *GeoMove;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 391; } /* = unique type id SOAP_TYPE_tt__PTZNode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZNode() { tt__PTZNode::soap_default(NULL); }
	virtual ~tt__PTZNode() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (396)
/* tt:PTZConfiguration */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity
{
public:
	std::string NodeToken;	/* required element of type tt:ReferenceToken */
	std::string *DefaultAbsolutePantTiltPositionSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultAbsoluteZoomPositionSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultRelativePanTiltTranslationSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultRelativeZoomTranslationSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultContinuousPanTiltVelocitySpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultContinuousZoomVelocitySpace;	/* optional element of type xsd:anyURI */
	tt__PTZSpeed *DefaultPTZSpeed;	/* optional element of type tt:PTZSpeed */
	LONG64 *DefaultPTZTimeout;	/* optional element of type xsd:duration */
	tt__PanTiltLimits *PanTiltLimits;	/* optional element of type tt:PanTiltLimits */
	tt__ZoomLimits *ZoomLimits;	/* optional element of type tt:ZoomLimits */
	tt__PTZConfigurationExtension *Extension;	/* optional element of type tt:PTZConfigurationExtension */
	int *MoveRamp;	/* optional attribute */
	int *PresetRamp;	/* optional attribute */
	int *PresetTourRamp;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 396; } /* = unique type id SOAP_TYPE_tt__PTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfiguration() { tt__PTZConfiguration::soap_default(NULL); }
	virtual ~tt__PTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventFilter
#define SOAP_TYPE_tt__EventFilter (547)
/* tt:EventFilter */
class SOAP_CMAC tt__EventFilter : public wsnt__FilterType
{
public:
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 547; } /* = unique type id SOAP_TYPE_tt__EventFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventFilter() { tt__EventFilter::soap_default(NULL); }
	virtual ~tt__EventFilter() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngine
#define SOAP_TYPE_tt__AnalyticsEngine (583)
/* tt:AnalyticsEngine */
class SOAP_CMAC tt__AnalyticsEngine : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsDeviceEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of type tt:AnalyticsDeviceEngineConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 583; } /* = unique type id SOAP_TYPE_tt__AnalyticsEngine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngine() { tt__AnalyticsEngine::soap_default(NULL); }
	virtual ~tt__AnalyticsEngine() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineInput
#define SOAP_TYPE_tt__AnalyticsEngineInput (589)
/* tt:AnalyticsEngineInput */
class SOAP_CMAC tt__AnalyticsEngineInput : public tt__ConfigurationEntity
{
public:
	tt__SourceIdentification *SourceIdentification;	/* required element of type tt:SourceIdentification */
	tt__VideoEncoderConfiguration *VideoInput;	/* required element of type tt:VideoEncoderConfiguration */
	tt__MetadataInput *MetadataInput;	/* required element of type tt:MetadataInput */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 589; } /* = unique type id SOAP_TYPE_tt__AnalyticsEngineInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineInput() { tt__AnalyticsEngineInput::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInput() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineControl
#define SOAP_TYPE_tt__AnalyticsEngineControl (594)
/* tt:AnalyticsEngineControl */
class SOAP_CMAC tt__AnalyticsEngineControl : public tt__ConfigurationEntity
{
public:
	std::string EngineToken;	/* required element of type tt:ReferenceToken */
	std::string EngineConfigToken;	/* required element of type tt:ReferenceToken */
	std::vector<std::string >InputToken;	/* required element of type tt:ReferenceToken */
	std::vector<std::string >ReceiverToken;	/* required element of type tt:ReferenceToken */
	tt__MulticastConfiguration *Multicast;	/* optional element of type tt:MulticastConfiguration */
	tt__Config *Subscription;	/* required element of type tt:Config */
	enum tt__ModeOfOperation Mode;	/* required element of type tt:ModeOfOperation */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 594; } /* = unique type id SOAP_TYPE_tt__AnalyticsEngineControl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineControl() { tt__AnalyticsEngineControl::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineControl() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDConfiguration
#define SOAP_TYPE_tt__OSDConfiguration (621)
/* tt:OSDConfiguration */
class SOAP_CMAC tt__OSDConfiguration : public tt__DeviceEntity
{
public:
	class tt__OSDReference *VideoSourceConfigurationToken;	/* required element of type tt:OSDReference */
	enum tt__OSDType Type;	/* required element of type tt:OSDType */
	tt__OSDPosConfiguration *Position;	/* required element of type tt:OSDPosConfiguration */
	tt__OSDTextConfiguration *TextString;	/* optional element of type tt:OSDTextConfiguration */
	tt__OSDImgConfiguration *Image;	/* optional element of type tt:OSDImgConfiguration */
	tt__OSDConfigurationExtension *Extension;	/* optional element of type tt:OSDConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 621; } /* = unique type id SOAP_TYPE_tt__OSDConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDConfiguration() { tt__OSDConfiguration::soap_default(NULL); }
	virtual ~tt__OSDConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (657)
/* wsnt:SubscribeCreationFailedFaultType */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 657; } /* = unique type id SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__SubscribeCreationFailedFaultType() { wsnt__SubscribeCreationFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__SubscribeCreationFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (658)
/* wsnt:InvalidFilterFaultType */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsrfbf__BaseFaultType
{
public:
	std::vector<std::string >UnknownFilter;	/* required element of type xsd:QName */
public:
	virtual int soap_type() const { return 658; } /* = unique type id SOAP_TYPE_wsnt__InvalidFilterFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__InvalidFilterFaultType() { wsnt__InvalidFilterFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidFilterFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (659)
/* wsnt:TopicExpressionDialectUnknownFaultType */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 659; } /* = unique type id SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__TopicExpressionDialectUnknownFaultType() { wsnt__TopicExpressionDialectUnknownFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (660)
/* wsnt:InvalidTopicExpressionFaultType */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 660; } /* = unique type id SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__InvalidTopicExpressionFaultType() { wsnt__InvalidTopicExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidTopicExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (661)
/* wsnt:TopicNotSupportedFaultType */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 661; } /* = unique type id SOAP_TYPE_wsnt__TopicNotSupportedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__TopicNotSupportedFaultType() { wsnt__TopicNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicNotSupportedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (662)
/* wsnt:MultipleTopicsSpecifiedFaultType */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 662; } /* = unique type id SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__MultipleTopicsSpecifiedFaultType() { wsnt__MultipleTopicsSpecifiedFaultType::soap_default(NULL); }
	virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (663)
/* wsnt:InvalidProducerPropertiesExpressionFaultType */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 663; } /* = unique type id SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__InvalidProducerPropertiesExpressionFaultType() { wsnt__InvalidProducerPropertiesExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (664)
/* wsnt:InvalidMessageContentExpressionFaultType */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 664; } /* = unique type id SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__InvalidMessageContentExpressionFaultType() { wsnt__InvalidMessageContentExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (665)
/* wsnt:UnrecognizedPolicyRequestFaultType */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	std::vector<std::string >UnrecognizedPolicy;	/* optional element of type xsd:QName */
public:
	virtual int soap_type() const { return 665; } /* = unique type id SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnrecognizedPolicyRequestFaultType() { wsnt__UnrecognizedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (666)
/* wsnt:UnsupportedPolicyRequestFaultType */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsrfbf__BaseFaultType
{
public:
	std::vector<std::string >UnsupportedPolicy;	/* optional element of type xsd:QName */
public:
	virtual int soap_type() const { return 666; } /* = unique type id SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnsupportedPolicyRequestFaultType() { wsnt__UnsupportedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (667)
/* wsnt:NotifyMessageNotSupportedFaultType */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 667; } /* = unique type id SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__NotifyMessageNotSupportedFaultType() { wsnt__NotifyMessageNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (668)
/* wsnt:UnacceptableInitialTerminationTimeFaultType */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 668; } /* = unique type id SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnacceptableInitialTerminationTimeFaultType() { wsnt__UnacceptableInitialTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (669)
/* wsnt:NoCurrentMessageOnTopicFaultType */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 669; } /* = unique type id SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__NoCurrentMessageOnTopicFaultType() { wsnt__NoCurrentMessageOnTopicFaultType::soap_default(NULL); }
	virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (670)
/* wsnt:UnableToGetMessagesFaultType */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 670; } /* = unique type id SOAP_TYPE_wsnt__UnableToGetMessagesFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnableToGetMessagesFaultType() { wsnt__UnableToGetMessagesFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToGetMessagesFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (671)
/* wsnt:UnableToDestroyPullPointFaultType */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 671; } /* = unique type id SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnableToDestroyPullPointFaultType() { wsnt__UnableToDestroyPullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (672)
/* wsnt:UnableToCreatePullPointFaultType */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 672; } /* = unique type id SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnableToCreatePullPointFaultType() { wsnt__UnableToCreatePullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToCreatePullPointFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (673)
/* wsnt:UnacceptableTerminationTimeFaultType */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsrfbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 673; } /* = unique type id SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnacceptableTerminationTimeFaultType() { wsnt__UnacceptableTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (674)
/* wsnt:UnableToDestroySubscriptionFaultType */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 674; } /* = unique type id SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnableToDestroySubscriptionFaultType() { wsnt__UnableToDestroySubscriptionFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (675)
/* wsnt:PauseFailedFaultType */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 675; } /* = unique type id SOAP_TYPE_wsnt__PauseFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__PauseFailedFaultType() { wsnt__PauseFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__PauseFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (676)
/* wsnt:ResumeFailedFaultType */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsrfbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 676; } /* = unique type id SOAP_TYPE_wsnt__ResumeFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__ResumeFailedFaultType() { wsnt__ResumeFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__ResumeFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (1531)
/* wstop:TopicNamespaceType-Topic */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic
{
public:
	wstop__Documentation *documentation;	/* optional element of type wstop:Documentation */
	char *__anyAttribute;	/* optional attribute */
	wstop__QueryExpressionType *MessagePattern;	/* optional element of type wstop:QueryExpressionType */
	std::vector<class wstop__TopicType * >Topic;	/* optional element of type wstop:TopicType */
	std::vector<char * >__any;
	std::string name;	/* required attribute */
	std::string *messageTypes;	/* optional attribute */
	bool final_;	/* optional attribute */
	std::string *parent;	/* optional attribute */
public:
	virtual int soap_type() const { return 1531; } /* = unique type id SOAP_TYPE__wstop__TopicNamespaceType_Topic */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wstop__TopicNamespaceType_Topic() { _wstop__TopicNamespaceType_Topic::soap_default(NULL); }
	virtual ~_wstop__TopicNamespaceType_Topic() { }
};
#endif

#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (703)
/* wstop:TopicNamespaceType */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented
{
public:
	std::vector<_wstop__TopicNamespaceType_Topic >*Topic;	/* optional element of type wstop:TopicNamespaceType-Topic */
	std::vector<char * >__any;
	std::string *name;	/* optional attribute */
	std::string targetNamespace;	/* required attribute */
	bool final_;	/* optional attribute */
public:
	virtual int soap_type() const { return 703; } /* = unique type id SOAP_TYPE_wstop__TopicNamespaceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__TopicNamespaceType() { wstop__TopicNamespaceType::soap_default(NULL); }
	virtual ~wstop__TopicNamespaceType() { }
};
#endif

#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (704)
/* wstop:TopicType */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented
{
public:
	wstop__QueryExpressionType *MessagePattern;	/* optional element of type wstop:QueryExpressionType */
	std::vector<wstop__TopicType * >Topic;	/* optional element of type wstop:TopicType */
	std::vector<char * >__any;
	std::string name;	/* required attribute */
	std::string *messageTypes;	/* optional attribute */
	bool final_;	/* optional attribute */
public:
	virtual int soap_type() const { return 704; } /* = unique type id SOAP_TYPE_wstop__TopicType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__TopicType() { wstop__TopicType::soap_default(NULL); }
	virtual ~wstop__TopicType() { }
};
#endif

#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (705)
/* wstop:TopicSetType */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 705; } /* = unique type id SOAP_TYPE_wstop__TopicSetType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__TopicSetType() { wstop__TopicSetType::soap_default(NULL); }
	virtual ~wstop__TopicSetType() { }
};
#endif

#ifndef SOAP_TYPE_tt__OSDReference
#define SOAP_TYPE_tt__OSDReference (605)
/* Primitive tt:OSDReference schema type: */
class SOAP_CMAC tt__OSDReference : public xsd__anyType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 605; } /* = unique type id SOAP_TYPE_tt__OSDReference */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OSDReference() { tt__OSDReference::soap_default(NULL); }
	virtual ~tt__OSDReference() { }
};
#endif

#ifndef SOAP_TYPE___ns1__GetServiceCapabilities
#define SOAP_TYPE___ns1__GetServiceCapabilities (1543)
/* Operation wrapper: */
struct __ns1__GetServiceCapabilities
{
public:
	_ns1__GetServiceCapabilities *ns1__GetServiceCapabilities;	/* optional element of type ns1:GetServiceCapabilities */
public:
	int soap_type() const { return 1543; } /* = unique type id SOAP_TYPE___ns1__GetServiceCapabilities */
};
#endif

#ifndef SOAP_TYPE___ns1__CreateProfile
#define SOAP_TYPE___ns1__CreateProfile (1547)
/* Operation wrapper: */
struct __ns1__CreateProfile
{
public:
	_ns1__CreateProfile *ns1__CreateProfile;	/* optional element of type ns1:CreateProfile */
public:
	int soap_type() const { return 1547; } /* = unique type id SOAP_TYPE___ns1__CreateProfile */
};
#endif

#ifndef SOAP_TYPE___ns1__GetProfiles
#define SOAP_TYPE___ns1__GetProfiles (1551)
/* Operation wrapper: */
struct __ns1__GetProfiles
{
public:
	_ns1__GetProfiles *ns1__GetProfiles;	/* optional element of type ns1:GetProfiles */
public:
	int soap_type() const { return 1551; } /* = unique type id SOAP_TYPE___ns1__GetProfiles */
};
#endif

#ifndef SOAP_TYPE___ns1__AddConfiguration
#define SOAP_TYPE___ns1__AddConfiguration (1555)
/* Operation wrapper: */
struct __ns1__AddConfiguration
{
public:
	_ns1__AddConfiguration *ns1__AddConfiguration;	/* optional element of type ns1:AddConfiguration */
public:
	int soap_type() const { return 1555; } /* = unique type id SOAP_TYPE___ns1__AddConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemoveConfiguration
#define SOAP_TYPE___ns1__RemoveConfiguration (1559)
/* Operation wrapper: */
struct __ns1__RemoveConfiguration
{
public:
	_ns1__RemoveConfiguration *ns1__RemoveConfiguration;	/* optional element of type ns1:RemoveConfiguration */
public:
	int soap_type() const { return 1559; } /* = unique type id SOAP_TYPE___ns1__RemoveConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__DeleteProfile
#define SOAP_TYPE___ns1__DeleteProfile (1563)
/* Operation wrapper: */
struct __ns1__DeleteProfile
{
public:
	_ns1__DeleteProfile *ns1__DeleteProfile;	/* optional element of type ns1:DeleteProfile */
public:
	int soap_type() const { return 1563; } /* = unique type id SOAP_TYPE___ns1__DeleteProfile */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoSourceConfigurations
#define SOAP_TYPE___ns1__GetVideoSourceConfigurations (1567)
/* Operation wrapper: */
struct __ns1__GetVideoSourceConfigurations
{
public:
	ns1__GetConfiguration *ns1__GetVideoSourceConfigurations;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1567; } /* = unique type id SOAP_TYPE___ns1__GetVideoSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoEncoderConfigurations
#define SOAP_TYPE___ns1__GetVideoEncoderConfigurations (1570)
/* Operation wrapper: */
struct __ns1__GetVideoEncoderConfigurations
{
public:
	ns1__GetConfiguration *ns1__GetVideoEncoderConfigurations;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1570; } /* = unique type id SOAP_TYPE___ns1__GetVideoEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioSourceConfigurations
#define SOAP_TYPE___ns1__GetAudioSourceConfigurations (1573)
/* Operation wrapper: */
struct __ns1__GetAudioSourceConfigurations
{
public:
	ns1__GetConfiguration *ns1__GetAudioSourceConfigurations;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1573; } /* = unique type id SOAP_TYPE___ns1__GetAudioSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioEncoderConfigurations
#define SOAP_TYPE___ns1__GetAudioEncoderConfigurations (1576)
/* Operation wrapper: */
struct __ns1__GetAudioEncoderConfigurations
{
public:
	ns1__GetConfiguration *ns1__GetAudioEncoderConfigurations;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1576; } /* = unique type id SOAP_TYPE___ns1__GetAudioEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAnalyticsConfigurations
#define SOAP_TYPE___ns1__GetAnalyticsConfigurations (1579)
/* Operation wrapper: */
struct __ns1__GetAnalyticsConfigurations
{
public:
	ns1__GetConfiguration *ns1__GetAnalyticsConfigurations;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1579; } /* = unique type id SOAP_TYPE___ns1__GetAnalyticsConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetMetadataConfigurations
#define SOAP_TYPE___ns1__GetMetadataConfigurations (1582)
/* Operation wrapper: */
struct __ns1__GetMetadataConfigurations
{
public:
	ns1__GetConfiguration *ns1__GetMetadataConfigurations;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1582; } /* = unique type id SOAP_TYPE___ns1__GetMetadataConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioOutputConfigurations
#define SOAP_TYPE___ns1__GetAudioOutputConfigurations (1585)
/* Operation wrapper: */
struct __ns1__GetAudioOutputConfigurations
{
public:
	ns1__GetConfiguration *ns1__GetAudioOutputConfigurations;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1585; } /* = unique type id SOAP_TYPE___ns1__GetAudioOutputConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioDecoderConfigurations
#define SOAP_TYPE___ns1__GetAudioDecoderConfigurations (1588)
/* Operation wrapper: */
struct __ns1__GetAudioDecoderConfigurations
{
public:
	ns1__GetConfiguration *ns1__GetAudioDecoderConfigurations;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1588; } /* = unique type id SOAP_TYPE___ns1__GetAudioDecoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__SetVideoSourceConfigurationResponse
#define SOAP_TYPE___ns1__SetVideoSourceConfigurationResponse (1592)
/* Operation wrapper: */
struct __ns1__SetVideoSourceConfigurationResponse
{
public:
	ns1__SetConfigurationResponse ns1__SetVideoSourceConfigurationResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1592; } /* = unique type id SOAP_TYPE___ns1__SetVideoSourceConfigurationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__SetVideoSourceConfiguration
#define SOAP_TYPE___ns1__SetVideoSourceConfiguration (1593)
/* Operation wrapper: */
struct __ns1__SetVideoSourceConfiguration
{
public:
	_ns1__SetVideoSourceConfiguration *ns1__SetVideoSourceConfiguration;	/* optional element of type ns1:SetVideoSourceConfiguration */
public:
	int soap_type() const { return 1593; } /* = unique type id SOAP_TYPE___ns1__SetVideoSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE___ns1__SetVideoEncoderConfigurationResponse (1596)
/* Operation wrapper: */
struct __ns1__SetVideoEncoderConfigurationResponse
{
public:
	ns1__SetConfigurationResponse ns1__SetVideoEncoderConfigurationResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1596; } /* = unique type id SOAP_TYPE___ns1__SetVideoEncoderConfigurationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__SetVideoEncoderConfiguration
#define SOAP_TYPE___ns1__SetVideoEncoderConfiguration (1597)
/* Operation wrapper: */
struct __ns1__SetVideoEncoderConfiguration
{
public:
	_ns1__SetVideoEncoderConfiguration *ns1__SetVideoEncoderConfiguration;	/* optional element of type ns1:SetVideoEncoderConfiguration */
public:
	int soap_type() const { return 1597; } /* = unique type id SOAP_TYPE___ns1__SetVideoEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioSourceConfigurationResponse
#define SOAP_TYPE___ns1__SetAudioSourceConfigurationResponse (1600)
/* Operation wrapper: */
struct __ns1__SetAudioSourceConfigurationResponse
{
public:
	ns1__SetConfigurationResponse ns1__SetAudioSourceConfigurationResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1600; } /* = unique type id SOAP_TYPE___ns1__SetAudioSourceConfigurationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioSourceConfiguration
#define SOAP_TYPE___ns1__SetAudioSourceConfiguration (1601)
/* Operation wrapper: */
struct __ns1__SetAudioSourceConfiguration
{
public:
	_ns1__SetAudioSourceConfiguration *ns1__SetAudioSourceConfiguration;	/* optional element of type ns1:SetAudioSourceConfiguration */
public:
	int soap_type() const { return 1601; } /* = unique type id SOAP_TYPE___ns1__SetAudioSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE___ns1__SetAudioEncoderConfigurationResponse (1604)
/* Operation wrapper: */
struct __ns1__SetAudioEncoderConfigurationResponse
{
public:
	ns1__SetConfigurationResponse ns1__SetAudioEncoderConfigurationResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1604; } /* = unique type id SOAP_TYPE___ns1__SetAudioEncoderConfigurationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioEncoderConfiguration
#define SOAP_TYPE___ns1__SetAudioEncoderConfiguration (1605)
/* Operation wrapper: */
struct __ns1__SetAudioEncoderConfiguration
{
public:
	_ns1__SetAudioEncoderConfiguration *ns1__SetAudioEncoderConfiguration;	/* optional element of type ns1:SetAudioEncoderConfiguration */
public:
	int soap_type() const { return 1605; } /* = unique type id SOAP_TYPE___ns1__SetAudioEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetMetadataConfigurationResponse
#define SOAP_TYPE___ns1__SetMetadataConfigurationResponse (1608)
/* Operation wrapper: */
struct __ns1__SetMetadataConfigurationResponse
{
public:
	ns1__SetConfigurationResponse ns1__SetMetadataConfigurationResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1608; } /* = unique type id SOAP_TYPE___ns1__SetMetadataConfigurationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__SetMetadataConfiguration
#define SOAP_TYPE___ns1__SetMetadataConfiguration (1609)
/* Operation wrapper: */
struct __ns1__SetMetadataConfiguration
{
public:
	_ns1__SetMetadataConfiguration *ns1__SetMetadataConfiguration;	/* optional element of type ns1:SetMetadataConfiguration */
public:
	int soap_type() const { return 1609; } /* = unique type id SOAP_TYPE___ns1__SetMetadataConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioOutputConfigurationResponse
#define SOAP_TYPE___ns1__SetAudioOutputConfigurationResponse (1612)
/* Operation wrapper: */
struct __ns1__SetAudioOutputConfigurationResponse
{
public:
	ns1__SetConfigurationResponse ns1__SetAudioOutputConfigurationResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1612; } /* = unique type id SOAP_TYPE___ns1__SetAudioOutputConfigurationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioOutputConfiguration
#define SOAP_TYPE___ns1__SetAudioOutputConfiguration (1613)
/* Operation wrapper: */
struct __ns1__SetAudioOutputConfiguration
{
public:
	_ns1__SetAudioOutputConfiguration *ns1__SetAudioOutputConfiguration;	/* optional element of type ns1:SetAudioOutputConfiguration */
public:
	int soap_type() const { return 1613; } /* = unique type id SOAP_TYPE___ns1__SetAudioOutputConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioDecoderConfigurationResponse
#define SOAP_TYPE___ns1__SetAudioDecoderConfigurationResponse (1616)
/* Operation wrapper: */
struct __ns1__SetAudioDecoderConfigurationResponse
{
public:
	ns1__SetConfigurationResponse ns1__SetAudioDecoderConfigurationResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1616; } /* = unique type id SOAP_TYPE___ns1__SetAudioDecoderConfigurationResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioDecoderConfiguration
#define SOAP_TYPE___ns1__SetAudioDecoderConfiguration (1617)
/* Operation wrapper: */
struct __ns1__SetAudioDecoderConfiguration
{
public:
	_ns1__SetAudioDecoderConfiguration *ns1__SetAudioDecoderConfiguration;	/* optional element of type ns1:SetAudioDecoderConfiguration */
public:
	int soap_type() const { return 1617; } /* = unique type id SOAP_TYPE___ns1__SetAudioDecoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___ns1__GetVideoSourceConfigurationOptions (1620)
/* Operation wrapper: */
struct __ns1__GetVideoSourceConfigurationOptions
{
public:
	ns1__GetConfiguration *ns1__GetVideoSourceConfigurationOptions;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1620; } /* = unique type id SOAP_TYPE___ns1__GetVideoSourceConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE___ns1__GetVideoEncoderConfigurationOptions (1623)
/* Operation wrapper: */
struct __ns1__GetVideoEncoderConfigurationOptions
{
public:
	ns1__GetConfiguration *ns1__GetVideoEncoderConfigurationOptions;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1623; } /* = unique type id SOAP_TYPE___ns1__GetVideoEncoderConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___ns1__GetAudioSourceConfigurationOptions (1626)
/* Operation wrapper: */
struct __ns1__GetAudioSourceConfigurationOptions
{
public:
	ns1__GetConfiguration *ns1__GetAudioSourceConfigurationOptions;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1626; } /* = unique type id SOAP_TYPE___ns1__GetAudioSourceConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE___ns1__GetAudioEncoderConfigurationOptions (1629)
/* Operation wrapper: */
struct __ns1__GetAudioEncoderConfigurationOptions
{
public:
	ns1__GetConfiguration *ns1__GetAudioEncoderConfigurationOptions;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1629; } /* = unique type id SOAP_TYPE___ns1__GetAudioEncoderConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetMetadataConfigurationOptions
#define SOAP_TYPE___ns1__GetMetadataConfigurationOptions (1632)
/* Operation wrapper: */
struct __ns1__GetMetadataConfigurationOptions
{
public:
	ns1__GetConfiguration *ns1__GetMetadataConfigurationOptions;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1632; } /* = unique type id SOAP_TYPE___ns1__GetMetadataConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___ns1__GetAudioOutputConfigurationOptions (1635)
/* Operation wrapper: */
struct __ns1__GetAudioOutputConfigurationOptions
{
public:
	ns1__GetConfiguration *ns1__GetAudioOutputConfigurationOptions;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1635; } /* = unique type id SOAP_TYPE___ns1__GetAudioOutputConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE___ns1__GetAudioDecoderConfigurationOptions (1638)
/* Operation wrapper: */
struct __ns1__GetAudioDecoderConfigurationOptions
{
public:
	ns1__GetConfiguration *ns1__GetAudioDecoderConfigurationOptions;	/* optional element of type ns1:GetConfiguration */
public:
	int soap_type() const { return 1638; } /* = unique type id SOAP_TYPE___ns1__GetAudioDecoderConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoEncoderInstances
#define SOAP_TYPE___ns1__GetVideoEncoderInstances (1642)
/* Operation wrapper: */
struct __ns1__GetVideoEncoderInstances
{
public:
	_ns1__GetVideoEncoderInstances *ns1__GetVideoEncoderInstances;	/* optional element of type ns1:GetVideoEncoderInstances */
public:
	int soap_type() const { return 1642; } /* = unique type id SOAP_TYPE___ns1__GetVideoEncoderInstances */
};
#endif

#ifndef SOAP_TYPE___ns1__GetStreamUri
#define SOAP_TYPE___ns1__GetStreamUri (1646)
/* Operation wrapper: */
struct __ns1__GetStreamUri
{
public:
	_ns1__GetStreamUri *ns1__GetStreamUri;	/* optional element of type ns1:GetStreamUri */
public:
	int soap_type() const { return 1646; } /* = unique type id SOAP_TYPE___ns1__GetStreamUri */
};
#endif

#ifndef SOAP_TYPE___ns1__StartMulticastStreamingResponse
#define SOAP_TYPE___ns1__StartMulticastStreamingResponse (1649)
/* Operation wrapper: */
struct __ns1__StartMulticastStreamingResponse
{
public:
	ns1__SetConfigurationResponse ns1__StartMulticastStreamingResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1649; } /* = unique type id SOAP_TYPE___ns1__StartMulticastStreamingResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__StartMulticastStreaming
#define SOAP_TYPE___ns1__StartMulticastStreaming (1650)
/* Operation wrapper: */
struct __ns1__StartMulticastStreaming
{
public:
	ns1__StartStopMulticastStreaming *ns1__StartMulticastStreaming;	/* optional element of type ns1:StartStopMulticastStreaming */
public:
	int soap_type() const { return 1650; } /* = unique type id SOAP_TYPE___ns1__StartMulticastStreaming */
};
#endif

#ifndef SOAP_TYPE___ns1__StopMulticastStreamingResponse
#define SOAP_TYPE___ns1__StopMulticastStreamingResponse (1652)
/* Operation wrapper: */
struct __ns1__StopMulticastStreamingResponse
{
public:
	ns1__SetConfigurationResponse ns1__StopMulticastStreamingResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1652; } /* = unique type id SOAP_TYPE___ns1__StopMulticastStreamingResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__StopMulticastStreaming
#define SOAP_TYPE___ns1__StopMulticastStreaming (1653)
/* Operation wrapper: */
struct __ns1__StopMulticastStreaming
{
public:
	ns1__StartStopMulticastStreaming *ns1__StopMulticastStreaming;	/* optional element of type ns1:StartStopMulticastStreaming */
public:
	int soap_type() const { return 1653; } /* = unique type id SOAP_TYPE___ns1__StopMulticastStreaming */
};
#endif

#ifndef SOAP_TYPE___ns1__SetSynchronizationPoint
#define SOAP_TYPE___ns1__SetSynchronizationPoint (1657)
/* Operation wrapper: */
struct __ns1__SetSynchronizationPoint
{
public:
	_ns1__SetSynchronizationPoint *ns1__SetSynchronizationPoint;	/* optional element of type ns1:SetSynchronizationPoint */
public:
	int soap_type() const { return 1657; } /* = unique type id SOAP_TYPE___ns1__SetSynchronizationPoint */
};
#endif

#ifndef SOAP_TYPE___ns1__GetSnapshotUri
#define SOAP_TYPE___ns1__GetSnapshotUri (1661)
/* Operation wrapper: */
struct __ns1__GetSnapshotUri
{
public:
	_ns1__GetSnapshotUri *ns1__GetSnapshotUri;	/* optional element of type ns1:GetSnapshotUri */
public:
	int soap_type() const { return 1661; } /* = unique type id SOAP_TYPE___ns1__GetSnapshotUri */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoSourceModes
#define SOAP_TYPE___ns1__GetVideoSourceModes (1665)
/* Operation wrapper: */
struct __ns1__GetVideoSourceModes
{
public:
	_ns1__GetVideoSourceModes *ns1__GetVideoSourceModes;	/* optional element of type ns1:GetVideoSourceModes */
public:
	int soap_type() const { return 1665; } /* = unique type id SOAP_TYPE___ns1__GetVideoSourceModes */
};
#endif

#ifndef SOAP_TYPE___ns1__SetVideoSourceMode
#define SOAP_TYPE___ns1__SetVideoSourceMode (1669)
/* Operation wrapper: */
struct __ns1__SetVideoSourceMode
{
public:
	_ns1__SetVideoSourceMode *ns1__SetVideoSourceMode;	/* optional element of type ns1:SetVideoSourceMode */
public:
	int soap_type() const { return 1669; } /* = unique type id SOAP_TYPE___ns1__SetVideoSourceMode */
};
#endif

#ifndef SOAP_TYPE___ns1__GetOSDs
#define SOAP_TYPE___ns1__GetOSDs (1673)
/* Operation wrapper: */
struct __ns1__GetOSDs
{
public:
	_ns1__GetOSDs *ns1__GetOSDs;	/* optional element of type ns1:GetOSDs */
public:
	int soap_type() const { return 1673; } /* = unique type id SOAP_TYPE___ns1__GetOSDs */
};
#endif

#ifndef SOAP_TYPE___ns1__GetOSDOptions
#define SOAP_TYPE___ns1__GetOSDOptions (1677)
/* Operation wrapper: */
struct __ns1__GetOSDOptions
{
public:
	_ns1__GetOSDOptions *ns1__GetOSDOptions;	/* optional element of type ns1:GetOSDOptions */
public:
	int soap_type() const { return 1677; } /* = unique type id SOAP_TYPE___ns1__GetOSDOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__SetOSDResponse
#define SOAP_TYPE___ns1__SetOSDResponse (1680)
/* Operation wrapper: */
struct __ns1__SetOSDResponse
{
public:
	ns1__SetConfigurationResponse ns1__SetOSDResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1680; } /* = unique type id SOAP_TYPE___ns1__SetOSDResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__SetOSD
#define SOAP_TYPE___ns1__SetOSD (1681)
/* Operation wrapper: */
struct __ns1__SetOSD
{
public:
	_ns1__SetOSD *ns1__SetOSD;	/* optional element of type ns1:SetOSD */
public:
	int soap_type() const { return 1681; } /* = unique type id SOAP_TYPE___ns1__SetOSD */
};
#endif

#ifndef SOAP_TYPE___ns1__CreateOSD
#define SOAP_TYPE___ns1__CreateOSD (1685)
/* Operation wrapper: */
struct __ns1__CreateOSD
{
public:
	_ns1__CreateOSD *ns1__CreateOSD;	/* optional element of type ns1:CreateOSD */
public:
	int soap_type() const { return 1685; } /* = unique type id SOAP_TYPE___ns1__CreateOSD */
};
#endif

#ifndef SOAP_TYPE___ns1__DeleteOSDResponse
#define SOAP_TYPE___ns1__DeleteOSDResponse (1688)
/* Operation wrapper: */
struct __ns1__DeleteOSDResponse
{
public:
	ns1__SetConfigurationResponse ns1__DeleteOSDResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1688; } /* = unique type id SOAP_TYPE___ns1__DeleteOSDResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__DeleteOSD
#define SOAP_TYPE___ns1__DeleteOSD (1689)
/* Operation wrapper: */
struct __ns1__DeleteOSD
{
public:
	_ns1__DeleteOSD *ns1__DeleteOSD;	/* optional element of type ns1:DeleteOSD */
public:
	int soap_type() const { return 1689; } /* = unique type id SOAP_TYPE___ns1__DeleteOSD */
};
#endif

#ifndef SOAP_TYPE___ns1__GetMasks
#define SOAP_TYPE___ns1__GetMasks (1693)
/* Operation wrapper: */
struct __ns1__GetMasks
{
public:
	_ns1__GetMasks *ns1__GetMasks;	/* optional element of type ns1:GetMasks */
public:
	int soap_type() const { return 1693; } /* = unique type id SOAP_TYPE___ns1__GetMasks */
};
#endif

#ifndef SOAP_TYPE___ns1__GetMaskOptions
#define SOAP_TYPE___ns1__GetMaskOptions (1697)
/* Operation wrapper: */
struct __ns1__GetMaskOptions
{
public:
	_ns1__GetMaskOptions *ns1__GetMaskOptions;	/* optional element of type ns1:GetMaskOptions */
public:
	int soap_type() const { return 1697; } /* = unique type id SOAP_TYPE___ns1__GetMaskOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__SetMaskResponse
#define SOAP_TYPE___ns1__SetMaskResponse (1700)
/* Operation wrapper: */
struct __ns1__SetMaskResponse
{
public:
	ns1__SetConfigurationResponse ns1__SetMaskResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1700; } /* = unique type id SOAP_TYPE___ns1__SetMaskResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__SetMask
#define SOAP_TYPE___ns1__SetMask (1701)
/* Operation wrapper: */
struct __ns1__SetMask
{
public:
	_ns1__SetMask *ns1__SetMask;	/* optional element of type ns1:SetMask */
public:
	int soap_type() const { return 1701; } /* = unique type id SOAP_TYPE___ns1__SetMask */
};
#endif

#ifndef SOAP_TYPE___ns1__CreateMask
#define SOAP_TYPE___ns1__CreateMask (1705)
/* Operation wrapper: */
struct __ns1__CreateMask
{
public:
	_ns1__CreateMask *ns1__CreateMask;	/* optional element of type ns1:CreateMask */
public:
	int soap_type() const { return 1705; } /* = unique type id SOAP_TYPE___ns1__CreateMask */
};
#endif

#ifndef SOAP_TYPE___ns1__DeleteMaskResponse
#define SOAP_TYPE___ns1__DeleteMaskResponse (1708)
/* Operation wrapper: */
struct __ns1__DeleteMaskResponse
{
public:
	ns1__SetConfigurationResponse ns1__DeleteMaskResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SetConfigurationResponse */
public:
	int soap_type() const { return 1708; } /* = unique type id SOAP_TYPE___ns1__DeleteMaskResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__DeleteMask
#define SOAP_TYPE___ns1__DeleteMask (1709)
/* Operation wrapper: */
struct __ns1__DeleteMask
{
public:
	_ns1__DeleteMask *ns1__DeleteMask;	/* optional element of type ns1:DeleteMask */
public:
	int soap_type() const { return 1709; } /* = unique type id SOAP_TYPE___ns1__DeleteMask */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (17)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (18)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (25)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (26)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (27)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (28)
typedef char *_wsa5__MessageID;
#endif

#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (29)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (30)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (31)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (32)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (33)
typedef char *_wsa5__To;
#endif

#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (34)
typedef char *_wsa5__Action;
#endif

#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (36)
typedef ULONG64 _wsa5__RetryAfter;
#endif

#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (37)
typedef char *_wsa5__ProblemHeaderQName;
#endif

#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (38)
typedef char *_wsa5__ProblemIRI;
#endif

#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (39)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (78)
typedef struct ds__SignatureType _ds__Signature;
#endif

#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (86)
typedef struct ds__TransformType _ds__Transform;
#endif

#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (93)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (130)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (160)
typedef std::string xsd__NCName;
#endif

#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (163)
typedef std::string xsd__anySimpleType;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (165)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (179)
typedef std::string xsd__integer;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (181)
typedef std::string xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (184)
typedef std::string xsd__token;
#endif

#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (186)
typedef std::string _xml__lang;
#endif

#ifndef SOAP_TYPE_tt__IntAttrList
#define SOAP_TYPE_tt__IntAttrList (782)
typedef std::string tt__IntAttrList;
#endif

#ifndef SOAP_TYPE_tt__FloatAttrList
#define SOAP_TYPE_tt__FloatAttrList (783)
typedef std::string tt__FloatAttrList;
#endif

#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (784)
typedef std::string tt__StringAttrList;
#endif

#ifndef SOAP_TYPE_tt__StringList
#define SOAP_TYPE_tt__StringList (785)
typedef std::string tt__StringList;
#endif

#ifndef SOAP_TYPE_tt__ReferenceTokenList
#define SOAP_TYPE_tt__ReferenceTokenList (786)
typedef std::string tt__ReferenceTokenList;
#endif

#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (787)
typedef std::string wsnt__AbsoluteOrRelativeTimeType;
#endif

#ifndef SOAP_TYPE_ns1__EncodingTypes
#define SOAP_TYPE_ns1__EncodingTypes (788)
typedef std::string ns1__EncodingTypes;
#endif

#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (789)
typedef std::string tt__Name;
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (823)
typedef std::string tt__NetworkInterfaceConfigPriority;
#endif

#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (827)
typedef int tt__IANA_IfTypes;
#endif

#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (835)
typedef std::string tt__IPv4Address;
#endif

#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (837)
typedef std::string tt__IPv6Address;
#endif

#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (839)
typedef std::string tt__HwAddress;
#endif

#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (843)
typedef std::string tt__DNSName;
#endif

#ifndef SOAP_TYPE_tt__Domain
#define SOAP_TYPE_tt__Domain (845)
typedef std::string tt__Domain;
#endif

#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (851)
typedef xsd__hexBinary tt__Dot11SSIDType;
#endif

#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (859)
typedef xsd__hexBinary tt__Dot11PSK;
#endif

#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (861)
typedef std::string tt__Dot11PSKPassphrase;
#endif

#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (889)
typedef std::string tt__AuxiliaryData;
#endif

#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (933)
typedef std::string tt__Description;
#endif

#ifndef SOAP_TYPE_tt__XPathExpression
#define SOAP_TYPE_tt__XPathExpression (935)
typedef std::string tt__XPathExpression;
#endif

#ifndef SOAP_TYPE_tt__RecordingJobMode
#define SOAP_TYPE_tt__RecordingJobMode (943)
typedef std::string tt__RecordingJobMode;
#endif

#ifndef SOAP_TYPE_tt__RecordingJobState
#define SOAP_TYPE_tt__RecordingJobState (945)
typedef std::string tt__RecordingJobState;
#endif

#ifndef SOAP_TYPE_tt__AudioClassType
#define SOAP_TYPE_tt__AudioClassType (949)
typedef std::string tt__AudioClassType;
#endif

#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (953)
typedef std::string tt__ReferenceToken;
#endif

#ifndef SOAP_TYPE_wstop__FullTopicExpression
#define SOAP_TYPE_wstop__FullTopicExpression (959)
typedef std::string wstop__FullTopicExpression;
#endif

#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (961)
typedef std::string wstop__ConcreteTopicExpression;
#endif

#ifndef SOAP_TYPE_wstop__SimpleTopicExpression
#define SOAP_TYPE_wstop__SimpleTopicExpression (963)
typedef std::string wstop__SimpleTopicExpression;
#endif

#ifndef SOAP_TYPE_tt__ReceiverReference
#define SOAP_TYPE_tt__ReceiverReference (971)
typedef std::string tt__ReceiverReference;
#endif

#ifndef SOAP_TYPE_tt__RecordingReference
#define SOAP_TYPE_tt__RecordingReference (973)
typedef std::string tt__RecordingReference;
#endif

#ifndef SOAP_TYPE_tt__TrackReference
#define SOAP_TYPE_tt__TrackReference (975)
typedef std::string tt__TrackReference;
#endif

#ifndef SOAP_TYPE_tt__JobToken
#define SOAP_TYPE_tt__JobToken (977)
typedef std::string tt__JobToken;
#endif

#ifndef SOAP_TYPE_tt__RecordingJobReference
#define SOAP_TYPE_tt__RecordingJobReference (979)
typedef std::string tt__RecordingJobReference;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of onvifmediaStub.h */
